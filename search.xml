<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>xml第一天笔记</title>
      <link href="/2018/11/07/xml1/"/>
      <url>/2018/11/07/xml1/</url>
      
        <content type="html"><![CDATA[<p>一  XML简单的历史介绍</p><p>1969年 GML   通用标记语言<br>    用于计算机之间的通信,通信就会传输数据,那么就需要一种数据的规范<br>1985年 SGML  标准通用标记语言<br>    对GML进行完善<br>1993年 HTML  超文本的标记语言(HyperText Markup Language)<br>    随着万维网的推广,在SGML的基础上,又出现了HTML语言,用于万维网上的页面展示<br>1998年 XML   可扩展的标记语言(Extensible Markup Language)<br>    HTML有不少的缺陷,HTML语言的标记不能自定义,HTML语言的标记本身不能用来描述数据,HTML语言的标记没有国际化(不同浏览器显示同一页面的效果可能不一样)<br>    W3C组织在1998年推出了可扩展标记语言XML<br>    XML语言的本身是用来替代HTML语言的,但是俩种语言还有一定差异的,所以中间出现了一种过渡的语言:XHTML<br>    但实际上XML语言已经很难替代HTML语言了,因为HTML语言的使用在整个万维网上使用太广泛了。</p><p>3.1　什么是良构<br>良构是一个来自XML的概念。从技术角度而言，它表示文档遵循某种严格的约束，比如每个起始标签都应该有一个匹配的结束标签、元素的开始和结束都在相同的父元素内以及每个实体引用也是事先定义好的。</p><p>第3章 良构<br>把标记转换成符合现代标准的首要任务是实现良构。良构是强大XML工具链条中的基础性环节。良构保证了DOM可操作的文档树结构的唯一性，因而成为可靠的跨浏览器的JavaScript代码的基础。因此，最紧要的第一件事无疑是先实现页面良构化。<br>有效性（validity）尽管也重要，但没有良构紧迫，违反有效性通常也有合理的理由。事实上我常有意发布一些无效的页面。如果要用到一个元素，即使DTD不允许，我仍然会用。这不会产生什么破坏，因为浏览器对不认识的元素置之不理。如果我要在一个blockquote中放入没有被任何元素包裹的原始文本 ，不会产生什么破坏。又比如我要使用HTML 5中的元素（如m，Opera可以认出这个元素，但其他浏览器不能），此时其他浏览器会忽略它。但如果页面乱构，后果则要严重得多。<br>首先，我将不能使用任何XML工具（如XSLT或者SAX）来处理这个页面，只能做到的几乎就是在浏览器中查看它。对一个乱构的页面来说，任何可靠的自动化处理或测试都是非常难以保证的。</p><p>二  XML有什么作用,为什么要学习XML<br>    第一个需求: 数据传输需要一定的格式<br>        1.数据的可读性<br>        2.将来的扩展<br>        3.将来的维护<br>    XML现在已经是业内传输数据的标准,它和语言无关</p><pre><code>第二个需求: 配置文件,之前使用的.properties资源文件中描述的信息不丰富第三个需求: 保存数据,充当小型的数据库    保存者使用数据一般是使用数据库保存,或一般的文件保存,这个时候也可以选择XML文件,因为XML可以描述复杂的数据关系。从普通文件中读取数据的速度肯定是比从数据库中读取数据的速度快,只不过这样不是很安全而已</code></pre><p>三 语法<br>    1.文档声明<br>        XML文件的后缀为.xml<br>        XML文本要求文件有一个头部声明: 用来告诉解析器一些相关信息<br>        &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>        表明当前文件是xml文件,XML版本为1.0,文件内容使用的字符编码为UTF-8<br>        注意:要小心在系统中这个xml文件保存时候的编码,是否和文件内容中设置的编码一致</p><pre><code>    ansi (American National Standards Institute)美国国家标准协会    ansi编码 是这个协会组织制定的一种字符编码    ansi编码在不同国家表示是不用的 中文操作系统中的ansi编码是GB23122.元素    2.1    每个XML文档必须有且只有一个根元素。root    根元素是一个完全包括文档中其他所有元素的元素。    根元素的起始标记要放在所有其他元素的起始标记之前。    根元素的结束标记要放在所有其他元素的结束标记之后。    2.2    xml文件中的标记也可以叫标签、元素、节点。    XML元素指XML文件中出现的标签，一个标签分为开始标签和结束标签，一个标签有如下几种书写形式，例如：    包含标签体：&lt;a&gt;www.baidu.com&lt;/a&gt;    不含标签体的：&lt;a&gt;&lt;/a&gt;, 可以简写为：&lt;a/&gt;    一个标签中也可以嵌套若干子标签。但所有标签必须合理的嵌套，绝对不允许交叉嵌套 ，例如：    &lt;a&gt;你好!&lt;b&gt;程序员&lt;/a&gt;&lt;/b&gt;     这样嵌套是可以的    &lt;a&gt;你好!&lt;b&gt;程序员&lt;/b&gt;&lt;/a&gt;    2.3    对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。    &lt;name&gt;tom&lt;/name&gt;    &lt;name&gt;        tom    &lt;/name&gt;    由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，要特别注意。但是在一些封装好的解析方式中,是可以忽略掉这些空格和换行的.(例如在一些第三方提供的jar包中)    2.4    一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范    区分大小写，例如，&lt;P&gt;和&lt;p&gt;是两个不同的标记。    不能以数字或&quot;_&quot; (下划线)开头。    不能包含空格。3.属性    &lt;student id=&quot;100&quot;&gt;        &lt;name&gt;TOM&lt;/name&gt;    &lt;/student&gt;    属性值用双引号（&quot;）或单引号（&apos;）分隔    一个元素可以有多个属性，它的基本格式为：        &lt;元素名 属性名=&quot;属性值&quot;&gt;    特定的属性名称在同一个元素标记中只能出现一次    属性值不能包括&lt;, &gt;, &amp;4.实体 entity    xml文件中有些特殊的字符是不能直接表示出来的,例如:大于号,小于号,单引号、双引号等等     使用实体的格式: &amp;实体名字;    预定义字符实体,由XML规范预先定义好了    &amp;lt;        &lt;    &amp;gt;        &gt;    &amp;amp;        &amp;    &amp;quot;        &quot;    &amp;apos;        &apos;    自定义实体 ENTITY entity    格式：    &lt;!DOCTYPE 根元素名称[        &lt;!ENTITY 实体名 实体内容&gt;    ]&gt;    eg:    &lt;!DOCTYPE courses[        &lt;!ENTITY company &quot;昆山杰普软件科技有限公司&quot;&gt;    ]&gt;    其中：company为实体名称              &quot;昆山杰普软件科技有限公司&quot;是实体内容          实体的使用：&amp;company;4.注释    &lt;!--这是一个注释--&gt;    注释内容中不要出现- -；    不要把注释放在标记中间；    &lt;Name &lt;!--the name--&gt; &gt; TOM &lt;/Name&gt;    注释不能嵌套；    可以在除标记以外的任何地方放注释5.PCDATA,CDATA    PCDATA (Parsed Character Data) 会被xml文档解析器解析的，但是有些特殊字符需要借助实体才可以被解析器解析。XML文件中的正常内容基本都是PCDATA    CDATA (Character Data) 不会被xml文档解析器解析的，按字符串原样输出。有些内容不想让解析,按照内容原样输出就可以了,这种情况可以使用CDATA    格式：&lt;![CDATA[需要原样输出的字符串]]&gt;          &lt;![CDATA[.....]]&gt;          &lt;&gt;          &lt;!&gt;          &lt;![]&gt;          &lt;![CDATA]&gt;          &lt;![CDATA[]]&gt;          &lt;![CDATA[......]]&gt;6.处理指令    处理指令，简称PI （processing instruction）。处理指令用来指挥解析引擎如何解析XML文档内容。    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></pre><p>四  XML命名空间 namespace<br>    XML 命名空间提供避免元素命名冲突的方法。<br>    在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。</p><pre><code>例如:这个 XML 文档携带着某个表格中的信息：&lt;table&gt;   &lt;tr&gt;       &lt;td&gt;Apples&lt;/td&gt;       &lt;td&gt;Bananas&lt;/td&gt;   &lt;/tr&gt;&lt;/table&gt;这个 XML 文档携带有关桌子的信息（一件家具）：&lt;table&gt;   &lt;name&gt;茶几&lt;/name&gt;   &lt;width&gt;80&lt;/width&gt;   &lt;length&gt;120&lt;/length&gt;&lt;/table&gt;假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 &lt;table&gt; 元素，就会发生命名冲突。XML 解析器无法确定如何处理这类冲突。第一种解决方案:    使用前缀来避免命名冲突此文档带有某个表格中的信息：&lt;h:table&gt;   &lt;h:tr&gt;       &lt;h:td&gt;Apples&lt;/h:td&gt;       &lt;h:td&gt;Bananas&lt;/h:td&gt;   &lt;/h:tr&gt;&lt;/h:table&gt;此 XML 文档携带着有关一件家具的信息：&lt;f:table&gt;   &lt;f:name&gt;茶几&lt;/f:name&gt;   &lt;f:width&gt;80&lt;/f:width&gt;   &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt;现在，命名冲突不存在了，这是由于两个文档都使用了不同的名称来命名它们的 &lt;table&gt; 元素 (&lt;h:table&gt; 和 &lt;f:table&gt;)。通过使用前缀，我们创建了两种不同类型的 &lt;table&gt; 元素。第二种解决方案:使用命名空间（Namespaces）这个 XML 文档携带着某个表格中的信息：&lt;h:table xmlns:h=&quot;http://www.briup.com/h&quot;&gt;   &lt;h:tr&gt;   &lt;h:td&gt;Apples&lt;/h:td&gt;   &lt;h:td&gt;Bananas&lt;/h:td&gt;   &lt;/h:tr&gt;&lt;/h:table&gt;此 XML 文档携带着有关一件家具的信息：&lt;f:table xmlns:f=&quot;http://www.briup.com/f&quot;&gt;   &lt;f:name&gt;茶几&lt;/f:name&gt;   &lt;f:width&gt;80&lt;/f:width&gt;   &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt;与仅仅使用前缀不同，我们为 &lt;table&gt; 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。XML Namespace (xmlns) 属性XML 命名空间属性被放置于元素的开始标签之中(一般都会在根元素中声明)，并使用以下的语法：xmlns:namespace-prefix=&quot;namespaceURI&quot;当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称默认的命名空间（Default Namespaces） 使用以下的语法:xmlns=&quot;namespaceURI&quot;为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。这个 XML 文档携带着某个表格中的信息：&lt;table xmlns=&quot;http://www.briup.com&quot;&gt;   &lt;tr&gt;   &lt;td&gt;Apples&lt;/td&gt;   &lt;td&gt;Bananas&lt;/td&gt;   &lt;/tr&gt;&lt;/table&gt;此 XML 文档携带着有关一件家具的信息：&lt;table xmlns=&quot;http://www.baidu.com&quot;&gt;   &lt;name&gt;茶几&lt;/name&gt;   &lt;width&gt;80&lt;/width&gt;   &lt;length&gt;120&lt;/length&gt;&lt;/table&gt;</code></pre><p>五  XML约束<br>    在XML技术里，可以编写一个文档来约束一个XML文档的书写规范，这称之为XML约束。</p><pre><code>需要XML约束的原因xml由于是可扩展的标记语言,所以在xml文件中的编写太过于自由,这样在很多种情况下并不合适。常用的约束技术XML DTD     DTD文件的后缀名为 .dtd    DTD文件有自己独立的语法规范XML Schema    Schema文件的后缀名为 .xsd    Schema文件符合xml语法规范</code></pre><p>六  DTD Document Type Define<br>    DTD的定义：描述元素、属性和其他杂项在xml文档中的使用规则的说明</p><pre><code>DTD的分类：外部的DTD 内部的DTD 混合的DTD    1).内部的DTD：DTD和xml文档在同一个文件中    例如:    student1.xml文件:    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE students[        &lt;!ELEMENT students (stu+)&gt;        &lt;!ELEMENT stu (id,name,age)&gt;        &lt;!ELEMENT id   (#PCDATA)&gt;        &lt;!ELEMENT name (#PCDATA)&gt;        &lt;!ELEMENT age  (#PCDATA)&gt;    ]&gt;    &lt;students&gt;        &lt;stu&gt;            &lt;id&gt;1&lt;/id&gt;            &lt;name&gt;tom&lt;/name&gt;            &lt;age&gt;20&lt;/age&gt;        &lt;/stu&gt;    &lt;/students&gt;    2).外部的DTD：DTD和xml文档不在同一个文件中    例如:    xml/student2.xml文件    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE students SYSTEM &quot;../dtd/student.dtd&quot;&gt;    &lt;students&gt;        &lt;stu&gt;            &lt;id&gt;1&lt;/id&gt;            &lt;name&gt;tom&lt;/name&gt;            &lt;age&gt;20&lt;/age&gt;        &lt;/stu&gt;    &lt;/students&gt;    dtd/student.dtd文件:    &lt;!ELEMENT students (stu+)&gt;    &lt;!ELEMENT stu (id,name,age)&gt;    &lt;!ELEMENT id   (#PCDATA)&gt;    &lt;!ELEMENT name (#PCDATA)&gt;    &lt;!ELEMENT age  (#PCDATA)&gt;    3).混合的DTD：既有外部DTD，又有内部DTD    例如:    xml/student3.xml文件    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE students SYSTEM &quot;../dtd/student.dtd&quot;[        &lt;!ELEMENT stu (id,name,age)&gt;        &lt;!ELEMENT id   (#PCDATA)&gt;        &lt;!ELEMENT name (#PCDATA)&gt;        &lt;!ELEMENT age  (#PCDATA)&gt;    ]&gt;    &lt;students&gt;        &lt;stu&gt;            &lt;id&gt;1&lt;/id&gt;            &lt;name&gt;tom&lt;/name&gt;            &lt;age&gt;20&lt;/age&gt;        &lt;/stu&gt;    &lt;/students&gt;    dtd/student.dtd文件:    &lt;!ELEMENT students (stu+)&gt;外部的DTD    引用外部dtd的时候又分为俩种:    SYSTEM表示引用的dtd文件在本地     例如:    &lt;!DOCTYPE students SYSTEM &quot;../dtd/student.dtd&quot;&gt;    PUBLIC表示引用的dtd文件是一个公共的文件    格式:注意里面是可以加回车换行的    &lt;!DOCTYPE 根元素 PUBLIC &quot;&quot; &quot;&quot;&gt;    例如:    &lt;!DOCTYPE hibernate-configuration PUBLIC      &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;      &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;    在后面的&quot;如何在Eclipse中给xml文件添加标签自动提示功能&quot;的部分再做说明DTD的目的：    验证该xml文档是否是有效的xml文档    如果一个良构的xml文档满足了DTD的声明就是一个有效的xml文档。    注意：良构 不一定  有效，但是有效一定良构DTD对xml文件中元素的约束：    格式：&lt;!ELEMENT  元素名 (内容模式)&gt;    内容模式：        1).EMPTY：元素不能包含子元素和文本（空元素）        例如:        dtd文件:        &lt;!ELEMENT students (stu)&gt;        &lt;!ELEMENT stu EMPTY&gt;        xml文件:        &lt;students&gt;            &lt;!--这个stu元素中的内容必须为空--&gt;            &lt;stu&gt;&lt;/stu&gt;        &lt;/students&gt;        2).(#PCDATA)：可以包含任何字符数据，但是不能在其中包含任何子元素        例如:        dtd文件:        &lt;!ELEMENT students (stu)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;        xml文件:        &lt;students&gt;            &lt;stu&gt;tom&lt;/stu&gt;        &lt;/students&gt;        3).ANY：元素内容为任意的，主要是使用在元素内容不确定的情况下        例如:        dtd文件:        &lt;!ELEMENT students (stu)&gt;        &lt;!ELEMENT stu ANY&gt;        xml文件:        &lt;students&gt;            &lt;stu&gt;tom&lt;/stu&gt;        &lt;/students&gt;        或者        &lt;students&gt;            &lt;stu&gt;                &lt;name&gt;tom&lt;/name&gt;            &lt;/stu&gt;        &lt;/students&gt;        4).修饰符：() | + * ? , 默认修饰符        () 来给元素分用组         |  在列出的元素中选择一个             例如:            dtd文件:            &lt;!ELEMENT students (stu|student)&gt;            xml文件:            &lt;students&gt;                &lt;!--这里只能出现stu元素或者student元素--&gt;                &lt;!--俩个元素任选其一,不能同时出现--&gt;            &lt;/students&gt;        +  该元素最少出现一次，可以出现多次 (1或n次)            例如:            dtd文件:            &lt;!ELEMENT students (stu+)&gt;            xml文件:            &lt;students&gt;                &lt;stu&gt;&lt;/stu&gt;                &lt;stu&gt;&lt;/stu&gt;                &lt;stu&gt;&lt;/stu&gt;            &lt;/students&gt;        *  该元素允许出现零次到任意多次（0到n次）            例如:            dtd文件:            &lt;!ELEMENT students (stu*)&gt;            xml文件:            &lt;students&gt;                &lt;!--stu出现0次到n次--&gt;                &lt;stu&gt;&lt;/stu&gt;                &lt;stu&gt;&lt;/stu&gt;                &lt;stu&gt;&lt;/stu&gt;            &lt;/students&gt;        ?  该元素可以出现，但只能出现一次 (0到1次)            例如:            dtd文件:            &lt;!ELEMENT students (stu?)&gt;            xml文件:            &lt;students&gt;                &lt;!--stu出现0次到1次--&gt;                &lt;stu&gt;&lt;/stu&gt;            &lt;/students&gt;        ,  对象必须按指定的顺序出现            例如:            dtd文件:            &lt;!ELEMENT students (stu*)&gt;            &lt;!ELEMENT stu (id,name,age)&gt;            xml文件:            &lt;students&gt;                &lt;stu&gt;                    &lt;id&gt;&lt;/id&gt;                    &lt;name&gt;&lt;/name&gt;                    &lt;age&gt;&lt;/age&gt;                &lt;/stu&gt;            &lt;/students&gt;        默认修饰符 就是什么修饰符都没有加            例如:            dtd文件:            &lt;!ELEMENT students (stu)&gt;            xml文件:            &lt;students&gt;                &lt;!--这里只能出现stu元素1次--&gt;                &lt;!--stu元素不出现也验证不通过--&gt;                &lt;stu&gt;&lt;/stu&gt;            &lt;/students&gt;        5).混合元素 子元素是任意类型 出现任意次数 并且没有出现顺序要求            例如:            dtd文件:            &lt;!ELEMENT students (stu*)&gt;            &lt;!ELEMENT stu (#PCDATA|id|name|age)*&gt;            xml文件:            &lt;students&gt;                &lt;stu&gt;&lt;/stu&gt;                &lt;stu&gt;                    &lt;id&gt;&lt;/id&gt;                    &lt;name&gt;&lt;/name&gt;                    &lt;age&gt;&lt;/age&gt;                &lt;/stu&gt;                &lt;stu&gt;tom&lt;/stu&gt;            &lt;/students&gt;            注意:            1 根元素students里面可以出现stu子元素0到n次            2 stu元素中可以写文本也可以写id、name、age子元素            3 id、name、age子元素出现的顺序没有要求            4 id、name、age子元素可以都出现也可以都不出现    注意：浏览器是非验证的解析器，不会验证xml的有效性          可以使用Eclipse去验证xml的有效性</code></pre><p>​<br>    DTD对xml文件中属性的约束：<br>        格式：&lt;!ATTLIST 元素名称<br>                    属性名称    值类型    属性特点<br>                    属性名称    值类型    属性特点<br>              &gt;</p><pre><code>属性类型：    1).CDATA：属性值可以是任何字符（包括数字和中文）        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 id   CDATA #REQUIRED                name CDATA #REQUIRED            &gt;        xml文件:        &lt;students&gt;            &lt;stu id=&quot;1&quot; name=&quot;tom&quot;&gt;&lt;/stu&gt;        &lt;/students&gt;    2).ID：属性值必须唯一,属性值必须满足xml命名规则        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 id   ID    #REQUIRED                name CDATA #REQUIRED            &gt;        xml文件:        &lt;students&gt;            &lt;stu id=&quot;A1&quot; name=&quot;tom&quot;&gt;&lt;/stu&gt;            &lt;stu id=&quot;B1&quot; name=&quot;tom&quot;&gt;&lt;/stu&gt;        &lt;/students&gt;        注意:            1. id和name属性必须出现            2. id属性的值必须满足xml名字规范,例如不能数字开头            3. id属性的值不能重复            4. 多个属性的出现是没有顺序要求的    3).IDREF/IDREFS        IDREF属性的值指向文档中其它地方声明的ID类型的值。        IDREFS同IDREF，但是可以具有由空格分开的多个引用。        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 id   ID            #REQUIRED                pid  IDREFS     #IMPLIED                name CDATA        #REQUIRED            &gt;        xml文件:        &lt;students&gt;            &lt;stu id=&quot;A1&quot; name=&quot;tom&quot;&gt;&lt;/stu&gt;            &lt;stu id=&quot;B1&quot; name=&quot;tom&quot;&gt;&lt;/stu&gt;            &lt;stu id=&quot;C1&quot; name=&quot;tom&quot; pid=&quot;A1 B1&quot;&gt;&lt;/stu&gt;        &lt;/students&gt;        注意:            1. id和name属性必须出现            2. pid属性出现可以,不出现也可以            3. id属性的值必须满足xml名字规范,例如不能数字开头            4. id属性的值不能重复            5. pid属性的值必须是引用其他stu元素的id值            6. pid属性的值可以是多个,使用空格隔开            7. 多个属性的出现是没有顺序要求的    4).enumerated：(枚举值1|枚举值2|枚举值3...),属性值必须在枚举值中        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 id     ID            #REQUIRED                name   CDATA         #REQUIRED                gender (男|女)         #REQUIRED            &gt;        xml文件:        &lt;students&gt;            &lt;stu id=&quot;A1&quot; name=&quot;tom&quot; gender=&quot;男&quot;&gt;&lt;/stu&gt;            &lt;stu id=&quot;B1&quot; name=&quot;tom&quot; gender=&quot;女&quot;&gt;&lt;/stu&gt;        &lt;/students&gt;        注意:            1. id/name/gender属性必须出现            2. id属性的值必须满足xml名字规范,例如不能数字开头            3. id属性的值不能重复            4. gender属性的值必须是男或者女            5. 多个属性的出现是没有顺序要求的属性特点：    1).#REQUIRED：元素的所有实例都必须有该属性        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 name   CDATA   #REQUIRED            &gt;        xml文件:        &lt;students&gt;            &lt;stu name=&quot;&quot;&gt;&lt;/stu&gt;            &lt;stu name=&quot;tom&quot;&gt;&lt;/stu&gt;        &lt;/students&gt;        注意:            1. name属性必须出现            2. name属性的值可以为空也可以不为空    2).#IMPLIED ：属性可以不出现        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 name   CDATA   #IMPLIED            &gt;        xml文件:        &lt;students&gt;                &lt;stu name=&quot;&quot;&gt;&lt;/stu&gt;                &lt;stu name=&quot;tom&quot;&gt;&lt;/stu&gt;                &lt;stu&gt;&lt;/stu&gt;        &lt;/students&gt;        注意:            1. name属性可以出现也可以不出现            2. name属性的值可以为空也可以不为空    3).default-value：属性可以不出现，并且当它不出现的时候是有默认值的，而该属性的默认值就是atttibute-value        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 name   CDATA   &quot;tom&quot;            &gt;        xml文件:        &lt;students&gt;                &lt;stu name=&quot;zhangsan&quot;&gt;&lt;/stu&gt;                &lt;stu&gt;&lt;/stu&gt;        &lt;/students&gt;        注意:            1. name属性可以出现也可以不出现            2. name属性如果不出现则默认值为tom    4).#FIXED ：属性可以不出现，但是如果出现的话必须是指定的属性值        例如:        dtd文件:        &lt;!ELEMENT students (stu*)&gt;        &lt;!ELEMENT stu (#PCDATA)&gt;            &lt;!ATTLIST stu                 name   CDATA   #IMPLIED                school CDATA   #FIXED &quot;briup&quot;            &gt;        xml文件:        &lt;students&gt;                &lt;stu school=&quot;briup&quot;&gt;&lt;/stu&gt;                &lt;stu&gt;&lt;/stu&gt;        &lt;/students&gt;        注意:            1. name/school属性可以出现也可以不出现            2. school属性如果出现那么值一定要是briup</code></pre><p>​<br>    DTD文档的一个实例：<br>        dtd文档:<br>        &lt;!ELEMENT students (student+)&gt;<br>        &lt;!ELEMENT student (name,age?,score*)&gt;<br>            &lt;!ATTLIST student id CDATA #REQUIRED&gt;<br>        &lt;!ELEMENT name (#PCDATA)&gt;<br>            &lt;!ATTLIST name firstName CDATA #IMPLIED&gt;<br>        &lt;!ELEMENT age (#PCDATA)&gt;<br>            &lt;!ATTLIST age xuAge CDATA #FIXED “20”&gt;<br>        &lt;!ELEMENT score (#PCDATA)&gt;<br>            &lt;!ATTLIST score sel (60|80|100) #REQUIRED&gt;</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>unix第三天笔记</title>
      <link href="/2018/11/07/unix3/"/>
      <url>/2018/11/07/unix3/</url>
      
        <content type="html"><![CDATA[<p>4.ls 显示当前目录下文件和目录<br>  ls / 显示/目录下文件和目录<br>  ls /etc 显示家目录下文件和目录<br>  ls -a 显示隐藏文件<br>  ls -R 循环(子目录中的信息显示出来)显示文件<br>  ls -l 显示详细信息<br>  ls -t  按照文件的最后一次的修改时间进行排序<br>  ls -d 显示自己的信息<br> 详细的当前目录自己的信息？<br>   ls -d -l<br> 详细的显示/etc自己目录的信息？<br>   ls -d -l /etc<br>   ls -ld /etc<br>ls -F显示文件类型<br> ls -F /etc<br>   —F显示文件类型<br>      /是目录<br>      *是可执行文件<br>      @是链接文件<br>      none是普通文件<br>5.查看文件类型<br>  file /etc/passwd<br>      文本文件ASCII<br>  file /bin/bash<br>      二进制文件</p><p>6.修改文件权限:chmod<br>  cd<br>  mkdir a<br>  touch a.txt<br>  ls -l<br> a目录同组人增加写权限，<br> 其他人减去一个执行权限。<br>  chmod  g+w,o-x a<br>  ls -l<br> a.txt让所有人都读写执行的权限。<br>  chmod u+x,go+w,go+x a.txt<br>  chmod a=rwx a.txt<br>  ls -l<br> 注意：+-依赖以前的权限<br>       =不依赖以前的权限，重新赋权限<br>  a.txt让所有人都读写执行的权限。<br>   chmod 777 a.txt<br>      1:执行权限<br>      2：写权限<br>      4：读权限<br> a自己读写执行，同组人和其他人读执行权限<br>  chmod  755 a</p><p>7.创建空文件：touch<br>  cd<br>  touch aa.txt b.txt cc.txt  e<br>8.创建目录：mkdir<br> mkdir games<br> mkdir games1 games2 games3<br> mkdir games/test<br> mkdir -p games4/games5/games6<br>注意：如果一次性创建多级目录，如果父目录不存在时，必须加上-p的选项。<br>9.拷贝cp<br>  cp -i a.txt bb.txt<br> -i:提示是否要覆盖目标文件<br>  cp a.txt bb.txt games1<br>  cp -r games1 games2<br> -r:源文件是目录<br>10.移动 mv<br>   mv a.txt bb.txt<br>   mv -i bb.txt b.txt games2<br>   mv games2 games3<br>11.删除文件和目录 rm rmdir<br>   rm aa.txt bb.txt<br>   rmdir games3<br>     注意：rmdir只能删除空目录<br>   rm -r games3<br>     注意：rm -r删除非空目录<br> 12.帮助命令 man<br> 格式：man 命令名字<br>   q：退出man模式<br>   enter:一行一行进行刷新<br>   space：一屏一屏进行刷新<br>   b：一屏一屏回看<br>   f：一屏一屏向前看<br>   /string：查找特定字符串<br>   n—&gt;next：查找下一个特定字符串<br> 例如：man ls<br> 搜索含关键字的命令：<br> man -k tou</p><p>liunx下还可以使用 ls   –-help等</p><p>第四章：元字符<br>元字符：一些有特殊意义的字符，可以替代其他的字符。<br>1)~ 代表家目录<br>2)<em> 匹配0或者多个字符<br>    cd<br>    mkdir test<br>    cd test<br>    touch a.txt b.txt ab.txt ab abc a bc<br>  查询test目录以a开头的文件？<br>     ls a</em><br>  查询test目录以txt为后缀的文件？<br>     ls <em>.txt<br>  删除以b开头的文件？<br>     rm b</em><br>3)? 匹配单个字符(有并且只匹配一个字符)<br>   查询test目录第二个字符为b的文件？<br>     ls ?b<em><br>   查询test目录以a开头的文件,文件名的长度是3字符？<br>     ls a??<br>4)[]从一组字符中匹配单个字符<br>touch link1.txt link2.txt n.txt k.txt<br>  ls </em>[link]<em>.txt<br>  ls </em>link<em>.txt<br>  ls [b-fB-F]</em>.txt<br>5); 连接多个命令<br>   cd /;ls<br>   date;cal;pwd<br>date:显示时间<br>cal:显示当前月的日历<br>cal 4 2014:显示2014年4月的日历<br>cal 2014:显示2014年的日历<br>6)|:管道连接符<br>    前一个命令的输出作为后一个命令的输入<br>ls -l /etc | more<br>more /etc/passwd<br>more:分屏显示内容，一次性显示一屏幕<br>7)&gt;,&lt;,&gt;&gt;</p><blockquote><p>:重定向输出到文件,覆盖文件的内容。<br>cal 4 2014 &gt; test.txt<br>cal 10 2014 &gt; test.txt</p><blockquote><p>:重定向输出到文件,追加文件的内容。<br>cal 7 2013 &gt;&gt; test.txt<br>&lt;:重定向输入到文件<br>cat：默认输入是键盘<br>中断进程：ctrl+c<br>cat &lt; test.txt<br>cat &lt; test.txt &gt; a.txt<br> 等价于—&gt; cp test.txt a.txt</p></blockquote></blockquote><p>1）cat<br>a)显示文件中内容到屏幕，一次性显示所有的内容<br>cat可以多个文件的内容<br>b)将多个文件拼接成一个大的文件<br>cat /etc/passwd<br>cat /etc/passwd /etc/group<br>cat /etc/passwd /etc/group &gt; cat.txt<br>cat /dev/null &gt; cat.txt<br>  cp /etc/passwd /dev/null<br>注意:/dev/null是unix的黑洞<br>     一般将/dev/null作为清空其他文件。<br>   清空文件也可以使用 : &gt; cat.txt<br>      :代表没有任务操作</p><p>2)more:分屏显示文件内容<br>more /etc/passwd /etc/group<br>  h:显示帮助信息<br> 显示/etc/passwd的第6行到第10行数据？<br>   前10 | 后5行<br>   head -10 /etc/passwd | tail -5</p><p>第六章：vi编辑器<br>vi编辑器：命令行编辑器，只使用键盘，不使用鼠标。<br>命令格式：  vi 文件名字<br>三个模式：<br>    命令模式：不可以输入内容，只能使用命令,进入vi的默认模式<br>    输入模式：可以输入内容<br>    最底行模式：光标停在最底行，如保存文件<br>命令模式切换输入模式：<br>     i:插入到光标所在位置的前边<br>     I:插入到光标所在行的行首<br>     a:插入到光标所在位置的后边<br>     A:插入到光标所在行的行尾<br>     o:插入到光标所在行的下一行<br>     O:插入到光标所在行的上一行<br>输入模式切换命令模式：esc<br>命令模式下：<br>   光标的移动：hjkl<br>   删除文本：<br>       x：删除一个字符<br>       dw,2dw,3dw..：删除多少个单词<br>       dd,2dd,3dd…：删除多少行<br>       :3,5d ：删除第3行到第5行<br>  替换文本：重写<br>       r：替换一个字符<br>       cw：替换一个单词<br>       cc：替换一行<br>       C：替换从光标到行尾<br>  拷贝和粘贴：<br>     yw：拷贝词<br>     yy：拷贝行<br>     Y：拷贝行<br>     p：当前行下一行粘贴<br>     P:当前行上一行粘贴</p><pre><code>:3,6co9：拷贝行3到行6在行9之后:3,6m9：移动行3到行6到行9之后</code></pre><p>  保存和退出：<br>     :w 保存文件不退出<br>     :wq  保存退出<br>     :q!   强制退出，不保存<br>     :w newfile  保存成新文件<br>   高级命令：<br>    u:撤销，撤销到上一次保存点<br>    :set nu 设置行号<br>      :set nonu取消行号<br>  :1,$s/hello/world/g 替换全文的hello–&gt;world<br>  :10,20s/hello/world/g  替换第10到20行<br>  :%s/hello/world/g  替换全文<br>    %:代表全文<br>    $:代表文件的末尾<br>命令模式切换最底层模式：<br>   :<br>   ？<br>   /</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>unix第一天笔记</title>
      <link href="/2018/11/07/unix2/"/>
      <url>/2018/11/07/unix2/</url>
      
        <content type="html"><![CDATA[<p>没有做不到的，只有想不到的。<br>学习的方法:多看，多写，多练(看书，看社区，csdn,码农…)<br>                (先抄写例子，后自己写)<br>                (通过项目将所有的知识达到练习的目的)<br>   贵在坚持<br>PPT是纯英文的，看英语文档的能力。<br>   每天积累5个单词，<br>   提高阅读英文文档的能力</p><p>what:unix是一种操作系统。<br>why:你如何选择系统？按照谁更方便满足用户的需求来选择<br>  a)windows:个人用户平台优化，非常容易满足个人的需求，<br>                          比如上网，聊天，聊QQ等<br>  b)unix:企业级用户平台优化，做服务器，163，百度，淘宝<br>       做服务器需要达到的要求：<br>           1)安全性,比如银行系统<br>       2)稳定性高(作为服务器一旦开机之后就不要随意当机的)，<br>                比如说电信,中国移动<br>       3)高效性(访问网站的效率)<br>如果是window是很难这些要求的，所以一般企业级用户会选择unix和liunx。<br>对于我们作为应用程序开发者来选择OS：<br>开发的时候可能会用到window或者unix，<br>但是在部署的时候大多数都是unix.所以就需要对unix有一定的了解。</p><p>how:用3天的时间学习unix的基本操作，命令式操作<br>    培养动手能力和解决问题的能力。<br>一：unix的历史和来源<br>     unix是一个大家庭，由它延生出不同版本和不同系统的类unix系统。<br>       unix<br>     V    BSD<br>       Linux<br>     Ubuntu RedHat<br>二：OS的组成<br>计算机的组成硬件和软件(应用软件,系统软件)<br>系统软件是OS<br>1)Kernel:OS的核心组成部分<br>     管理硬件。<br>     管理内存：内存分配<br>     管理进程：进程调度。<br>     控制系统程序和系统硬件。<br>     管理文件系统：真正创建和删除文件的，用户只是发出命令。<br>     管理交换空间(虚拟内存)，守护进程(精灵)，文件系统。<br>swap space：（交换分区/空间）当系统的物理内存不够用的时候，<br>就需要将物理内存中的一部分空间释放出来，以供当前运行的程<br>序使用。那些被释放的空间可能来自一些很长时间没有什么操作<br>的程序，这些被释放的空间被临时保存到Swap空间中，等到那些<br>程序要运行时，再从Swap中恢复保存的数据到内存中。<br>  内核不断在交换空间和实际的物理内存之间反复交换虚拟内<br>存存储单元中的内容。这使得系统以为它拥有比物理内存更多<br>的可用内存。<br>deamon：（精灵进程、守护进程、后台进程）在操作系统中，一般<br>    系统的服务都是以后台进程的方式存在，而且都会常驻系<br>    统中，直到关机才结束，这类服务称Deamon.</p><p>2)Shell:是用户和kernel之间的接口。有一个界面。<br>        充当了翻译者和解释者。<br>     把人能够识别的高级语言解释成机器语言<br>     把机器语言翻译成高级语言<br>显示当前用户：whoami<br>第一次设置超级用户的密码：<br>   sudo passwd root 或sudo -s<br>        输入当前用户的秘密<br>    输入修改秘密<br>    再次输入修改秘密</p><p>超级用户的名字就是root<br>普通用户切换到超级用户：su<br>     输入超级用户的密码<br>超级用户切换到普通用户：exit<br>普通用户的标识：$<br>超级用户的标识：#<br>3)文件系统：将硬件和软件都映射成文件。可以进行统一管理。<br>  相对路径：以当前路径开头的路径。<br>             相对点随时发生改变<br>  绝对路径：以根目录/开头的路径。<br>             相对点不会发生改变<br>/:unix系统的根路径<br>opt:存放安装的第三方软件，比如java<br>etc:存放配置文件和初始化文件<br>dev:存放设备文件<br>usr:存放用户相关的信息，用户自定义的可执行程序，库等<br>kernel:存放系统核心文件<br>var:存放动态数据文件<br>home:存放用户的家目录，不同用户有不同的家目录<br>   unix是多用户操作系统<br>sbin/bin:系统的可执行程序<br>cdrom:系统的光驱信息<br>boot:系统启动文件<br>lib:系统库文件<br>lost+found:系统碎片，意外关机时保存的数据<br>media:存放手动挂载点<br>mnt:存放自动挂载点<br>proc:进程的缩写，操作系统运行时的动态信息，如CPU，内存使用信息等<br>root:超级用户的家路径<br>run:操作系统和用户运行的进程运行状态，如进程正在运行还是阻塞<br>srv:server的缩写，安装服务器的存放的文件<br>sys:虚拟文件系统，识别不同的U盘<br>tmp:系统需要的临时变量<br>initrd.img:系统启动的镜像</p><p>第二章：<br>1:远程连接<br>telnet 域名/Ip地址<br>  telnet 172.16.0.10<br>      输入用户名和密码<br>     连接成功之后操作的就是服务器机器的资料<br>  查看ip: ifconfig<br>     a)物理环境<br>        ping 172.16.0.10<br>     b)服务开启<br>        1)安装客户端软件,unix默认已经开启<br>     windows需要在打开windows功能中打开Telnet客户端</p><pre><code>2)安装服务器端软件   在线安装sudo apt-get install telnetd   离线安装：图形界面安装   命令安装： ./文件名字</code></pre><p>2.远程退出：exit<br>3.修改普通用户的密码：passwd<br>    修改普通用户密码的要求，对超级用户没有作用<br>        1)密码的长度6到8个字符<br>    2)密码至少包含2个字符和一个数字或者一个特殊字符<br>    3)密码不能和用户名相同<br>    4)新密码和旧密码至少有3个字符不同<br>4.查看用户信息<br>   cat /etc/passwd<br>用户名:密文的占位符:uid:gid:备注:用户的家目录:默认使用shell<br>   sudo cat /etc/shadow 查询密码相关的信息<br>      密码：输入当前用户的密码<br>   使用最小权限原则：所有操作尽量尽量使用普通用户完成。<br>   sudo：临时提升普通用户的权限</p><p>一）基础实验：</p><ol><li><p>Unix中常见shell及其命令(shell的缩写)<br>ls cd cp cat </p></li><li><p>普通用户与超级用户如何进行相互切换<br>普通切超级 su<br> 超级切普通 exit</p></li><li><p>如何修改密码及普通用户修改密码的限制<br>passwd<br> 修改普通用户密码的要求，对超级用户没有作用</p><pre><code>1)密码的长度6到8个字符</code></pre><p>2)密码至少包含2个字符和一个数字或者一个特殊字符<br>3)密码不能和用户名相同<br>4)新密码和旧密码至少有3个字符不同</p></li><li><p>clear、pwd命令的作用<br>clear 清屏<br>pwd  查看当前所在目录</p></li><li><p>cd命令的作用<br>改变目录<br> a)如果进入的文件不在当前目录下必须以绝对路径形式改变  在briup目录中进入etc：cd /etc<br> b)如果进入的文件在当前目录可以绝对或相对路径改变<br> c)返回上级目录 cd ..</p></li><li><p>ls命令的作用及常见的选项的作用（-a、-R、-t、-l、-F）<br>ls -a /etc:查看所有文件，包括隐藏文件<br> ls -R /etc 显示子目录或者子子目录直到最后的里面的信息<br> ls -t /etc:根据最后一次修改的时间排序显示<br> ls -l 显示当前目录下的文件和目录的详细信息<br> ls -F /etc:显示文件或目录类型 / 代表目录 *代表可执行文件 (none) 文件</p></li></ol><p>7.如何创建文件<br> touch 创建文件或者更新访问和修改文件的时间</p><p>8.如何创建目录<br> mkdir 创建目录</p><p>二）扩展实验：</p><ol><li>切换到管理员的时候可以用su和su -，su与su - 的区别(观察实验现象)<br> su 切换成超级管理员所在目录还是当前目录<br> su -切换之后为根目录</li></ol><p>2.如何查看文件的最后一次访问时间<br>  ls </p><p>3.如何复制文件<br>  cp 复制文件</p><p>4.如何删除文件和目录<br>rm 删除文件<br>rm  -r 删除目录<br>rmdir 删除空目录</p><p>5.如何给文件改名或者移动文件到另一个地方<br>mv  a.txt b.txt(b.txt 不存在则代表修改名字，存在则代表移动)</p><p>三）作业：</p><ol><li><p>操作系统的三大组成及各自作用<br>a)kernel内核<br>  1.管理硬件<br>  2.管理内存（内存分配）<br>  3.管理进程</p><pre><code>程序  静态的进程   启动程序之后形成进程  动态的  可以启动多个进程线程  进程里面可以开辟多个线程</code></pre><p>  4.控制系统硬件和系统程序（驱动）<br>  5.管理交换空间（虚拟内存）</p><pre><code>从硬件中启动一块内存，操作系统通过频繁的换入换出达到我们的内存够用的效果</code></pre><p>  6.管理守护进程</p><pre><code>运行在后台，系统启动时它启动，系统关闭时它关闭</code></pre><p>  7.管理文件系统 对文件操作</p><p>b)shell  用户所发送的命令界面<br> 是用户和kernel之间的接口<br> 扮演解释者和翻译者<br> 将我们所发送的命令解释成机器所识别的机器语言<br> 将机器所返回的结果翻译成我们所能识别的高级语言</p><p>c)file system   文件系统</p><pre><code>所有硬件都会映射成一个文件（由目录，子目录以及文件）形成的一个倒立的树形结构</code></pre></li><li><p>swap space、deamon的作用<br>管理交换空间（虚拟内存）<br>swap space:从硬件中启动一块内存，操作系统通过频繁的换入换出达到我们的内存够用的效果<br>deamon:运行在后台，系统启动时它启动，系统关闭时它关闭</p></li><li><p>Unix中相对路径与绝对路径的区别，相对路径的参照物<br>相对路径   相对于当前路径  </p><pre><code>     a.txt相对点不会以/开头</code></pre><p>绝对路径   相对于根路径</p><pre><code>/etc/a.txt</code></pre></li><li><p>Unix常见目录结构/opt、/etc、/dev、/var、/kernel、/home等的作用<br>opt:存放安装的第三方软件，比如java<br>etc:存放配置文件和初始化文件<br>dev:存放设备文件<br>kernel:存放系统核心文件<br>var:存放动态数据文件<br>home:存放用户的家目录，不同用户有不同的家目录<br>unix是多用户操作系统</p></li><li><p>/etc/passwd和/etc/shadow的作用<br>/etc/passwd 查看所有用户信息<br>/etc/shadow 查询密码相关的信息</p></li><li><p>/etc/passwd文件中包含了用户的哪些信息<br>briup:x:1000:1000:briup,,,:/home/briup:/bin/bash<br>用户名:密文的占位符:uid:gid:备注:用户的家目录:默认使用的shell</p></li><li><p>使用passwd命令修改当前用户的密码<br>passwd </p></li><li><p>查看当前目录下所有文件包括隐藏文件的详细列表信息<br> ls  -a</p></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>unix第一天笔记</title>
      <link href="/2018/11/07/unix1/"/>
      <url>/2018/11/07/unix1/</url>
      
        <content type="html"><![CDATA[<p>没有做不到的，只有想不到的。<br>学习的方法:多看，多写，多练(看书，看社区，csdn,码农…)<br>                (先抄写例子，后自己写)<br>                (通过项目将所有的知识达到练习的目的)<br>   贵在坚持<br>PPT是纯英文的，看英语文档的能力。<br>   每天积累5个单词，<br>   提高阅读英文文档的能力</p><p>what:unix是一种操作系统。<br>why:你如何选择系统？按照谁更方便满足用户的需求来选择<br>  a)windows:个人用户平台优化，非常容易满足个人的需求，<br>                          比如上网，聊天，聊QQ等<br>  b)unix:企业级用户平台优化，做服务器，163，百度，淘宝<br>       做服务器需要达到的要求：<br>           1)安全性,比如银行系统<br>       2)稳定性高(作为服务器一旦开机之后就不要随意当机的)，<br>                比如说电信,中国移动<br>       3)高效性(访问网站的效率)<br>如果是window是很难这些要求的，所以一般企业级用户会选择unix和liunx。<br>对于我们作为应用程序开发者来选择OS：<br>开发的时候可能会用到window或者unix，<br>但是在部署的时候大多数都是unix.所以就需要对unix有一定的了解。</p><p>how:用3天的时间学习unix的基本操作，命令式操作<br>    培养动手能力和解决问题的能力。<br>一：unix的历史和来源<br>     unix是一个大家庭，由它延生出不同版本和不同系统的类unix系统。<br>       unix<br>     V    BSD<br>       Linux<br>     Ubuntu RedHat<br>二：OS的组成<br>计算机的组成硬件和软件(应用软件,系统软件)<br>系统软件是OS<br>1)Kernel:OS的核心组成部分<br>     管理硬件。<br>     管理内存：内存分配<br>     管理进程：进程调度。<br>     控制系统程序和系统硬件。<br>     管理文件系统：真正创建和删除文件的，用户只是发出命令。<br>     管理交换空间(虚拟内存)，守护进程(精灵)，文件系统。<br>swap space：（交换分区/空间）当系统的物理内存不够用的时候，<br>就需要将物理内存中的一部分空间释放出来，以供当前运行的程<br>序使用。那些被释放的空间可能来自一些很长时间没有什么操作<br>的程序，这些被释放的空间被临时保存到Swap空间中，等到那些<br>程序要运行时，再从Swap中恢复保存的数据到内存中。<br>  内核不断在交换空间和实际的物理内存之间反复交换虚拟内<br>存存储单元中的内容。这使得系统以为它拥有比物理内存更多<br>的可用内存。<br>deamon：（精灵进程、守护进程、后台进程）在操作系统中，一般<br>    系统的服务都是以后台进程的方式存在，而且都会常驻系<br>    统中，直到关机才结束，这类服务称Deamon.</p><p>2)Shell:是用户和kernel之间的接口。有一个界面。<br>        充当了翻译者和解释者。<br>     把人能够识别的高级语言解释成机器语言<br>     把机器语言翻译成高级语言<br>显示当前用户：whoami<br>第一次设置超级用户的密码：<br>   sudo passwd root 或sudo -s<br>        输入当前用户的秘密<br>    输入修改秘密<br>    再次输入修改秘密</p><p>超级用户的名字就是root<br>普通用户切换到超级用户：su<br>     输入超级用户的密码<br>超级用户切换到普通用户：exit<br>普通用户的标识：$<br>超级用户的标识：#<br>3)文件系统：将硬件和软件都映射成文件。可以进行统一管理。<br>  相对路径：以当前路径开头的路径。<br>             相对点随时发生改变<br>  绝对路径：以根目录/开头的路径。<br>             相对点不会发生改变<br>/:unix系统的根路径<br>opt:存放安装的第三方软件，比如java<br>etc:存放配置文件和初始化文件<br>dev:存放设备文件<br>usr:存放用户相关的信息，用户自定义的可执行程序，库等<br>kernel:存放系统核心文件<br>var:存放动态数据文件<br>home:存放用户的家目录，不同用户有不同的家目录<br>   unix是多用户操作系统<br>sbin/bin:系统的可执行程序<br>cdrom:系统的光驱信息<br>boot:系统启动文件<br>lib:系统库文件<br>lost+found:系统碎片，意外关机时保存的数据<br>media:存放手动挂载点<br>mnt:存放自动挂载点<br>proc:进程的缩写，操作系统运行时的动态信息，如CPU，内存使用信息等<br>root:超级用户的家路径<br>run:操作系统和用户运行的进程运行状态，如进程正在运行还是阻塞<br>srv:server的缩写，安装服务器的存放的文件<br>sys:虚拟文件系统，识别不同的U盘<br>tmp:系统需要的临时变量<br>initrd.img:系统启动的镜像</p><p>第二章：<br>1:远程连接<br>telnet 域名/Ip地址<br>  telnet 172.16.0.10<br>      输入用户名和密码<br>     连接成功之后操作的就是服务器机器的资料<br>  查看ip: ifconfig<br>     a)物理环境<br>        ping 172.16.0.10<br>     b)服务开启<br>        1)安装客户端软件,unix默认已经开启<br>     windows需要在打开windows功能中打开Telnet客户端</p><pre><code>2)安装服务器端软件   在线安装sudo apt-get install telnetd   离线安装：图形界面安装   命令安装： ./文件名字</code></pre><p>2.远程退出：exit<br>3.修改普通用户的密码：passwd<br>    修改普通用户密码的要求，对超级用户没有作用<br>        1)密码的长度6到8个字符<br>    2)密码至少包含2个字符和一个数字或者一个特殊字符<br>    3)密码不能和用户名相同<br>    4)新密码和旧密码至少有3个字符不同<br>4.查看用户信息<br>   cat /etc/passwd<br>用户名:密文的占位符:uid:gid:备注:用户的家目录:默认使用shell<br>   sudo cat /etc/shadow 查询密码相关的信息<br>      密码：输入当前用户的密码<br>   使用最小权限原则：所有操作尽量尽量使用普通用户完成。<br>   sudo：临时提升普通用户的权限</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三十四天笔记</title>
      <link href="/2018/11/06/index34/"/>
      <url>/2018/11/06/index34/</url>
      
        <content type="html"><![CDATA[<p>package ChatClient;</p><p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.OutputStream;<br>import java.io.OutputStreamWriter;<br>import java.io.PrintWriter;<br>import java.net.<em>;<br>import java.nio.Buffer;<br>import java.util.</em>;</p><p>public class ChatServer {<br>private ServerSocket server;<br>private Set<socket> clients=new HashSet<socket>();</socket></socket></p><p>public static void main(String[] args) throws IOException {<br>    new ChatServer();<br>}<br>public ChatServer() throws IOException {</p><pre><code>server =new ServerSocket(8888);System.out.println(&quot;服务器已经监听了端口……&quot;);while(true){    Socket socket=server.accept();    clients.add(socket);    //获取Ip地址    String ip=socket.getInetAddress().getHostAddress();    System.out.println(&quot;有一个客户进来了，他的ip是：&quot;+ip);    //针对每个客户端，服务器都启动一个线程单独交流，将来将数据转发给所有的客户端    Thread thread=new Thread(new ServerRunnable(clients,socket));    thread.start();</code></pre><p>​<br>        }<br>}<br>}<br>class ServerRunnable implements Runnable{<br>    private Set<socket> clients;<br>    private Socket currentSocket;<br>     public ServerRunnable(Set<socket> clients,Socket socket) {<br>        this.clients=clients;<br>        this.currentSocket=socket;</socket></socket></p><pre><code>}@Overridepublic void run() {    // TODO Auto-generated method stub    //获取ip地址    String ip=currentSocket.getInetAddress().getHostAddress();    //接受和转发消息    BufferedReader br=null;    PrintWriter pw=null;    try {        br=new BufferedReader(new InputStreamReader(                currentSocket.getInputStream()));        String str=null;        //一直监听客户端是否发来数据        while(true)        {            //当读取数据发现不为空说明客户端发送了新的消息            if((str=br.readLine())!=null)            {                System.out.println(ip+&quot;说：&quot;+str);                for(Socket temp:clients)                {                    pw=new PrintWriter(                            new OutputStreamWriter(temp.getOutputStream())) ;                    pw.println(str);                    pw.flush();                }</code></pre><p>​<br>                }</p><pre><code>        }    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p>}</p><p>package ChatClient;</p><p>import java.awt.BorderLayout;<br>import java.awt.Container;<br>import java.awt.FlowLayout;<br>import java.awt.Toolkit;<br>import java.awt.event.ActionEvent;<br>import java.awt.event.ActionListener;<br>import java.awt.event.KeyAdapter;<br>import java.awt.event.KeyEvent;<br>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.OutputStreamWriter;<br>import java.io.PrintWriter;<br>import java.net.Socket;<br>import java.net.UnknownHostException;<br>import java.text.SimpleDateFormat;<br>import java.util.Date;</p><p>import javax.swing.JButton;<br>import javax.swing.JFrame;<br>import javax.swing.JLabel;<br>import javax.swing.JPanel;<br>import javax.swing.JScrollPane;<br>import javax.swing.JSplitPane;<br>import javax.swing.JTextArea;</p><p>public class ChatClient extends JFrame {</p><pre><code>private static final long serialVersionUID = 1L;private Socket socket;private JTextArea sendArea;// 要发送信息的内容区域private JTextArea contentArea;// 聊天记录的内容区域private Container contentPane;private String name;// 当前用户名private String text;public static void main(String[] args) throws UnknownHostException, IOException {    // Socket socket=new Socket(&quot;127.0.0.1&quot;,8888);    new ChatClient(&quot;五&quot;).go();    new ChatClient(&quot;lijin&quot;).go();}public ChatClient(String name) {    try {        this.name = name;        this.setDefaultCloseOperation(EXIT_ON_CLOSE);        initGUI();        socket = new Socket(&quot;127.0.0.1&quot;, 8888);        // 监听服务器端        ClientThread thread = new ClientThread(socket, contentArea);        thread.start();    } catch (UnknownHostException e) {        // TODO Auto-generated catch block        e.printStackTrace();    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}public void initGUI() {    this.setSize(300, 400);    this.setTitle(&quot;我的聊天室&quot;);    contentPane = getContentPane();    int x = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth();    int y = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight();    this.setLocation((x - this.getWidth()) / 2, (y - this.getHeight()) / 2);    this.setResizable(false);    contentArea = new JTextArea();    contentArea.setEditable(false);    JScrollPane logPanel = new JScrollPane(contentArea, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);    sendArea = new JTextArea();    sendArea.addKeyListener(new KeyAdapter() {        public void keyPressed(KeyEvent e) {            if (e.getKeyCode() == KeyEvent.VK_ENTER) {                send();            }        }    });    JScrollPane sendPanel = new JScrollPane(sendArea, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);    // 创建一个分割窗口    JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, logPanel, sendPanel);    splitPane.setDividerLocation(250);    contentPane.add(splitPane, BorderLayout.CENTER);    // 下面的    JPanel jp = new JPanel();    jp.setLayout(new FlowLayout(FlowLayout.RIGHT));    contentPane.add(jp, BorderLayout.SOUTH);    JLabel nameLbl = new JLabel(&quot;用户名：&quot; + this.name + &quot; &quot;);    jp.add(nameLbl);    JButton resetBtn = new JButton(&quot;close&quot;);    resetBtn.addActionListener(new ActionListener() {        public void actionPerformed(ActionEvent e) {            System.exit(0);        }    });    jp.add(resetBtn);    JButton sendBtn = new JButton(&quot;send&quot;);    jp.add(sendBtn);    sendBtn.addActionListener(new ActionListener() {        public void actionPerformed(ActionEvent e) {            send();        }    });}public void go() {    this.setVisible(true);}// 发送public void send() {    String msg = sendArea.getText();    SimpleDateFormat formater = new SimpleDateFormat(&quot;HH:mm:ss&quot;);    String date = formater.format(new Date());    String sendStr = name + &quot;&quot; + date + &quot;&quot; + msg;    PrintWriter pw = null;    try {        pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));        pw.println(sendStr);        pw.flush();    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }    // 清空发送框    sendArea.setText(&quot;&quot;);}</code></pre><p>}<br>// 客户端线程，一直监听服务器端所返回的消息</p><p>class ClientThread extends Thread {<br>    private Socket socket;<br>    private JTextArea contentArea;</p><pre><code>public ClientThread(Socket socket, JTextArea contentArea) {    this.socket = socket;    this.contentArea = contentArea;}public void run() {    BufferedReader br = null;    try {        br = new BufferedReader(new InputStreamReader(socket.getInputStream()));        String str = null;        while (true) {            if ((str = br.readLine()) != null) {                System.out.println(str);                contentArea.append(str+&apos;\n&apos;);            }        }    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    } finally {        try {            if (br != null)                br.close();            if (socket != null) {                socket.close();            }        } catch (Exception e2) {            // TODO: handle exception        }    }}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三十三天笔记</title>
      <link href="/2018/11/05/index33/"/>
      <url>/2018/11/05/index33/</url>
      
        <content type="html"><![CDATA[<p>五：基于TCP的Socket编程步骤：</p><p>套接字：代表通信节点</p><p>1）服务器程序编写：</p><p>​    ①调用ServerSocket(int port)创建一个服务器端套接字，</p><p>​      并绑定到指定端口上；</p><p>​    ②调用accept()，监听连接请求，如果客户端请求连接，</p><p>​      则接受连接，返回通信套接字；</p><p>​    ③调用Socket类的getOutputStream()和</p><p>​      getInputStream获取输出流和输入流，</p><p>​      开始网络数据的发送和接收；</p><p>​    ④最后关闭通信套接字。</p><p>2）客户端程序编写：</p><p>​    ①调用Socket()创建一个流套接字，并连接到服务器端； </p><p>​    ②调用Socket类的getOutputStream()</p><p>​     和getInputStream获取输出流和输入流，</p><p>​     开始网络数据的发送和接收； </p><p>​    ③最后关闭通信套接字。</p><p>六：基于UDP的Socket编程步骤：</p><p>   1）服务器端基于UDP编程：</p><p>​    a)调用DatagramSocket(int port)创建一个数据报套接字，并绑定到指定端口上；</p><p>​    b)调用DatagramPacket(byte[] buf, int length)，</p><p>​      建立一个字节数组以接收客户端的UDP包 ；</p><p>​    c)调用DatagramSocket类的receive()，</p><p>​      接收客户端的UDP包并放在上一步创建的数据包中；</p><p>​    d)创建数据包，用来存放发送给客户端响应数据。</p><p>​    int port = dp.getPort();</p><p>​    InetAddress address=dp.getAddress();</p><p>​    String msg=new Date().toString();</p><p>​    buf=msg.getBytes();</p><p>​    DatagramPacket dp1=new DatagramPacket(buf,buf.length,address,port);</p><p>​    e)向客户端发送数据包DatagramSocket.send(DatagramPacket)</p><p>​    f)最后关闭数据报套接字。</p><p>​    其中第四，五是选择性的。</p><p>   2）客户端程序编写：</p><p>​    a)调用DatagramSocket()创建一个数据报套接字。 </p><p>​    b)调用DatagramPacket(byte[] buf, int length, </p><p>​    InetAddress address, int port)，建立要发送的UDP包；</p><p>​    包含发给服务器的数据，服务器地址，服务器的端口。</p><p>​    c)调用DatagramSocket类的send(dp)，发送UDP包；</p><p>​    d)创建数据包，用来存放服务器端返回响应数据。</p><p>​       DatagramPacket dp1=new DatagramPacket(buf,buf.length);</p><p>​    e)接收服务器端响应数据ds.receive(dp1);</p><p>​    f)最后关闭数据报套接字。</p><p>​    其中第四，五是选择性的。</p><p>​    day15</p><p>一. AWT</p><p>   图形用户界面(Graphics User Interface, GUI)</p><p>   是用户与程序交互的窗口，它比基于命令行的界</p><p>   面更直观并且更友好。</p><p>   GUI的基本类库位于java.awt包中.</p><p>   这个包也被称为抽象窗口工具箱(Abstract Window Toolkit, AWT)。</p><p>   AWT按照面向对象的思想来创建GUI，</p><p>   它提供了容器类、众多的组件类和布局管理器类。</p><p>   而现在的的组件包更多的使用javax.swing.*中的组件。</p><p>   因为该组件的风格可以由当前系统决定。</p><p>   而java.awt.*中的组件是使用sun公司的统一风格。</p><p>  AWT构建图形用户界面的机制包括：</p><p>​     a)提供了一些容器组件(如Frame和Panel), </p><p>​       用来容纳其他的组件(如按钮Button、</p><p>​       复选框Checkbox和文本框TextField)。</p><p>​     b)用布局管理器来管理组件在容器上的布局；</p><p>​     c)利用监听器来响应各种事件，实现用户与</p><p>​     程序的交互。一个组件如果注册了某种事件</p><p>​     的监听器，由这个组件触发的特定事件就会</p><p>​     被监听器接收和响应；</p><p>二. 创建GUI的步骤</p><p>   步骤一：选择一个容器</p><p>​       javax.swing包中提供了一个抽象类JComponent，</p><p>​       它是所有除了菜单类组件之外的AWT组件的父类。</p><p>​       Container类表示容器，继承了Component类。容</p><p>​       器用来存放别的组件, </p><p>​       有两种类型的容器：Window和JPanel。</p><ol><li>Window和它的子类JFrame</li></ol><p>​    Window是不依赖于其他容器而独立存在的容器。</p><p>​    Window有两个子类：Frame和Dialog。</p><p>​    Frame带有标题，而且可以调整大小。</p><p>​    Dialog可以被移动，但是不能改变大小。</p><p>​    Frame有一个构造方法——Frame(String title)，</p><p>​    通过它可以创建一个以参数为标题的Frame对象。</p><p>​    Frame的add()方法向容器中加入其他组件。</p><p>​    当Frame被创建后，它是不可见的，必须通过以下</p><p>​    步骤使Frame成为可见的。</p><p>​          1) setSize(int width, int height)显示设置Frame的大小，</p><p>​      或者调用pack()方法自动确定Frame的大小。</p><p>​      pack()方法会确保Frame容器中的组件都会有与</p><p>​      布局相适应的合理大小。</p><p>​          2) setVisible(true)方法使Frame成为可见的。</p><p>帮同学们复习一下线程</p><p>要求：</p><p>\1. 类MyStack：实现堆栈功能</p><p>\2. 类Producer extends Thread，要求如下：</p><p>​    做20次producer的操作，每次操作随机产生一个’a’~’z’的char类型数据放入MyStack中</p><p>​    放入完成后，输出放入的数据，然后sleep(300)</p><p>\3. 类Consumer extends Thread，要求如下：</p><p>​    做20次consumer的操作，每次从MyStack中取出一个数据</p><p>​    取出后，输出取出的数据，然后sleep(300)</p><p>\4. 使用TestThread进行测试</p><p>char value = (char)(‘a’+Math.random()*26)</p><p>public class MyStack {</p><p>​    private ArrayList data;</p><p>​    public MyStack() {</p><p>​        data = new ArrayList();</p><p>​    }</p><p>​    public void push(Object o) {</p><p>​        data.add(o);</p><p>​        System.out.println(“存:”+o);</p><p>​    }</p><p>​    public char pop() {</p><p>​        int size = data.size();</p><p>​        if (size &gt; 0) {</p><p>​            char a = (char) data.get(data.size() - 1);</p><p>​            data.remove(data.size() - 1);</p><p>​            return a;</p><p>​        } else {</p><p>​            return 1;</p><p>​        }</p><p>​    }</p><p>​    public int getSize() {</p><p>​        return data.size();</p><p>​    }</p><p>}</p><p>public class Producer extends Thread{</p><p>​    private MyStack ms;</p><p>​    </p><p>public Producer(MyStack ms) {</p><p>​        this.ms = ms;</p><p>​    }</p><p>@Override</p><p>public void run() {</p><p>​    for (int i = 0; i &lt; 20; i++) {</p><p>​        char value = (char)(‘a’+Math.random()*26);</p><p>​        ms.push(value);</p><p>​    }</p><p>​    try {</p><p>​        sleep(300);</p><p>​    } catch (InterruptedException e) {</p><p>​        // TODO Auto-generated catch block</p><p>​        e.printStackTrace();</p><p>​    }</p><p>}</p><p>}</p><p>public class TestThread {</p><p>public static void main(String[] args) {</p><p>​    MyStack ms=new MyStack();</p><p>​    Producer pd=new Producer(ms);</p><p>​    Consumer cs=new Consumer(ms);</p><p>​    pd.start();</p><p>​    cs.start();</p><p>}</p><p>}</p><p>package com.briup.en;</p><p>public class Student {<br>    private String name;<br>    private int age;<br>    private Gender gender;</p><pre><code>public Student(String name, int age, Gender gender) {    super();    this.name = name;    this.age = age;    this.gender = gender;}public Student() {    super();}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}public Gender getGender() {    return gender;}public void setGender(Gender gender) {    this.gender = gender;}@Overridepublic String toString() {    return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, gender=&quot; + gender            + &quot;]&quot;;}</code></pre><p>public static void main(String[] args) {<br>    Student stu=new Student(“张三”,20,Gender.MALE);<br>}<br>}</p><p>package com.briup.en;</p><p>public enum Gender {<br>MALE,FEMALE,f;<br>}</p><p>package com.briup.GUI;</p><p>import java.awt.Color;<br>import java.awt.Container;<br>import java.awt.FlowLayout;<br>import java.awt.Font;</p><p>import javax.swing.JButton;<br>import javax.swing.JFrame;<br>import javax.swing.JLabel;<br>import javax.swing.JTextField;</p><p>public class FirstGUI {<br>//第一步找容器,就相当于桌子<br>    private JFrame frame;<br>    //相当于桌布<br>    private Container contentPane;<br>    //文本框<br>    private JTextField num1Text,num2Text,num3Text;<br>    //文本<br>    private JLabel addLbl,resultLbl;<br>    //按钮<br>    private JButton addBtn,clearBtn,exitBtn;</p><pre><code>//初始化容器public FirstGUI(){    frame=new JFrame(&quot;计算器&quot;);    //社设置容器大小    frame.setSize(500, 200);    //设置窗体所在位置    frame.setLocation(300, 200);    //设置容器大小不能被改变    frame.setResizable(false);    //设置容器点击退出按钮退出该应用程序    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    //frame.setBackground(Color.BLUE);    //获取桌布    contentPane=frame.getContentPane();    //contentPane.setBackground(Color.PINK);    Color c=new Color(200,100,199);    contentPane.setBackground(c);    //设置布局管理器    contentPane.setLayout(new FlowLayout());    initGUI();}//初始化组件public void initGUI(){    num1Text=new JTextField(10);//初始化文本框长度    num2Text=new JTextField(10);    num3Text=new JTextField(10);    addLbl=new JLabel(&quot;+&quot;);    resultLbl=new JLabel(&quot;=&quot;);    addBtn=new JButton(&quot;计算&quot;);    clearBtn=new JButton(&quot;清空&quot;);    exitBtn=new JButton(&quot;退出&quot;);    //设置字体大小    Font font=new Font(&quot;楷体&quot;, Font.BOLD, 25);    num1Text.setFont(font);    num2Text.setFont(font);    num3Text.setFont(font);    addLbl.setFont(font);    resultLbl.setFont(font);    addBtn.setFont(font);    clearBtn.setFont(font);    exitBtn.setFont(font);    //禁用第三个文本框    num3Text.setEditable(false);    //文本框从右往左输入    num1Text.setHorizontalAlignment(JTextField.RIGHT);    num2Text.setHorizontalAlignment(JTextField.RIGHT);    num3Text.setHorizontalAlignment(JTextField.RIGHT);    contentPane.add(num1Text);    contentPane.add(addLbl);    contentPane.add(num2Text);    contentPane.add(resultLbl);    contentPane.add(num3Text);    contentPane.add(addBtn);    contentPane.add(clearBtn);    contentPane.add(exitBtn);}//显示界面public void go(){    frame.setVisible(true);//显示界面}public static void main(String[] args) {    new FirstGUI().go();;}</code></pre><p>}</p><p>package com.briup.net;</p><p>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;<br>import java.net.SocketException;<br>import java.util.Date;</p><p>//基于UDP的服务器端<br>public class UDPServer {<br>public static void main(String[] args) {</p><pre><code>try {    //创建DatagramSocket    DatagramSocket ds=new DatagramSocket(9999);    //创建一个空的数据包使用DatagramPacket    byte[] buff=new byte[1024];    DatagramPacket dp=new DatagramPacket(buff, 0, buff.length);    //接收客户端发过来的数据包并把其放到第二步对象中     ds.receive(dp);     System.out.println(&quot;from client:&quot;+new String(dp.getData(),0,dp.getLength()));     //创建要发送给客户端的数据包     //发送内容，以及目的地，     buff=new Date().toString().getBytes();     InetAddress address = dp.getAddress();//获取客户端地址       int port = dp.getPort();//获取端口号       DatagramPacket dp1=new                DatagramPacket(buff, buff.length, address, port);       //发送数据包       ds.send(dp1);       //关闭资源       ds.close();} catch (SocketException e) {    // TODO Auto-generated catch block    e.printStackTrace();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}</code></pre><p>}<br>}</p><p>package com.briup.net;</p><p>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;<br>import java.net.SocketException;<br>import java.net.UnknownHostException;</p><p>//基于UDP的客户端<br>public class UDPClient {<br>public static void main(String[] args) {</p><pre><code>try {    //创建DatagramSocket对象    DatagramSocket ds=new DatagramSocket();    //发送数据包    String msg=&quot;please give me date&quot;;    byte[] buff=msg.getBytes();    InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);    DatagramPacket dp=new             DatagramPacket(buff, buff.length, address, 9999);    //发送数据包    ds.send(dp);    //接收服务器端返回的数据    byte[] buff1=new byte[1024];    DatagramPacket dp1=new DatagramPacket(buff1, buff1.length);    ds.receive(dp1);    System.out.println(&quot;from server:&quot;+new String(dp1.getData(),0,dp1.getLength()));    ds.close();} catch (SocketException e) {    // TODO Auto-generated catch block    e.printStackTrace();} catch (UnknownHostException e) {    // TODO Auto-generated catch block    e.printStackTrace();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}</code></pre><p>}<br>}</p><p>package com.briup.net;</p><p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.ServerSocket;<br>import java.net.Socket;<br>import java.util.Date;</p><p>public class TCPServer2 {<br>private ServerSocket ss;<br>public TCPServer2(){<br>    try {<br>        ss=new ServerSocket(9999);<br>        System.out.println(“服务器已经启动”);<br>        while(true){<br>            Socket socket = ss.accept();<br>            new ServerThread(socket).start();<br>        }<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }</p><p>}<br>public static void main(String[] args) {<br>    new TCPServer2();<br>}<br>}<br>class ServerThread extends Thread{<br>    Socket socket;<br>     PrintWriter out;<br>      BufferedReader br;<br>    public ServerThread(Socket socket){<br>        this.socket=socket;<br>    }<br>    public void run(){<br>        //读写数据操作<br>        //3.读写数据<br>        try{<br>                InputStream is = socket.getInputStream();//获取管道输入流<br>                 br=new BufferedReader(<br>                        new InputStreamReader(is));<br>                String msg = br.readLine();<br>                System.out.println(“客户端说:”+msg);<br>                //给客户端返回数据<br>                out = new PrintWriter(socket.getOutputStream());<br>                out.println(new Date().toString());<br>                out.flush();<br>        }catch(Exception e){<br>            e.printStackTrace();<br>        }finally{<br>        //4.关闭资源  先开的后关<br>            try {<br>                if(out!=null) out.close();<br>                if(br!=null) br.close();<br>                if(socket!=null) socket.close();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }</p><pre><code>}}</code></pre><p>}</p><pre>package com.briup.net;import java.net.*;import java.util.Date;import java.io.*;//基于TCP协议的服务器端public class TCPServer {public static void main(String[] args){    ServerSocket ss=null;      PrintWriter out = null;      BufferedReader br=null;      Socket socket=null;    try {        //1.创建serversocket对象        ss=new ServerSocket(9999);        System.out.println("服务器端在9999端口启动");        while(true){        //2.等待客户端的连接        //accept具有阻塞功能，可以一直停留在这，直到获取客户端连入         socket=ss.accept();        System.out.println("有客户端来了");        //3.读写数据        InputStream is = socket.getInputStream();//获取管道输入流         br=new BufferedReader(                new InputStreamReader(is));        String msg = br.readLine();        System.out.println("客户端说:"+msg);        //给客户端返回数据        out = new PrintWriter(socket.getOutputStream());        out.println(new Date().toString());        out.flush();        }    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }finally{        //4.关闭资源  先开的后关            try {                if(out!=null) out.close();                if(br!=null) br.close();                if(socket!=null) socket.close();            } catch (IOException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }    }}}</pre><pre>package com.briup.net;import java.net.*;import java.io.*;//基于TCP协议的客户端public class TCPClient {public static void main(String[] args) {    PrintWriter out=null;    BufferedReader br=null;    //1.创建Socket对象    Socket socket=null;    try {        socket=new Socket("127.0.0.1",9999);        //2.读写数据        //先往服务器端写数据         out=new PrintWriter(                socket.getOutputStream());//管道输出流        out.println("你好，服务器，请给我当前时间");        out.flush();        //读取服务器端返回的数据         br=new BufferedReader(                new InputStreamReader(socket.getInputStream()));        String msg = br.readLine();        System.out.println("服务器端说:"+msg);    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }finally{        //3.关闭资源  先开的后关        try {            if(out!=null) out.close();            if(br!=null) br.close();            if(socket!=null) socket.close();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }}}}</pre><pre>package com.briup.net;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class URLTest {    public static void main(String[] args) {        //创建URL对象        try {            URL url=new URL("http://localhost:8888/tomcat.png");            //打开输入流            //InputStream is = url.openStream();            URLConnection conn = url.openConnection();            conn.connect();//真正连接服务器            InputStream is = conn.getInputStream();            //文件输出流            FileOutputStream fos=new FileOutputStream("src/com/briup/net/img.png");            byte[] buff=new byte[1024];            int len=-1;            while((len=is.read(buff))!=-1){                fos.write(buff, 0, len);            }            fos.flush();        } catch (MalformedURLException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三十二天笔记</title>
      <link href="/2018/11/02/index32/"/>
      <url>/2018/11/02/index32/</url>
      
        <content type="html"><![CDATA[<p>net网络：服务器端的涉及到多线程编程，<br>         和客户端和服务器端数据的通信<br>一：计算机网络<br>计算机网络是连接全球计算机资源的网络环境可以资源共享，通信等<br>最简单的网络形式由两台计算机组成。</p><p>二：网络的协议<br>协议：在网络上进行数据通信(数据交换)时所使用的规范(标准)。<br>      不同层具有各自不同的协议。</p><p>三:OSI(Open System Interconnection)参考模型<br>物理层：二进制传输，确定如何在通信信道上传递比特流；<br>数据链路层：加强物理层的传输功能，建立一条无差错的传输线路；<br>网络层：在网络中数据到达目的地有很多线路，网络层就是负责找出最佳的传输线路；<br>传输层：传输层为源端计算机到目的端计算机提供可靠的数据传输服务，隔离网络的上<br>下层协议，使得上层网络应用的协议与下层无关；<br>会话层：在两个相互通信的应用进程之间建立、<br>        组织和协调其相互之间的通信；<br>表示层：处理被传送数据的表示问题，也就<br>        是信息的语法和语义，<br>       如有必要将使用一种通用的格式在多种格式中进行转换；<br>应用层：为用户的应用程序提供网络通信服务；</p><p>OSI(Open System Interconnection)参考模型并不是物理实体上存在这七层，<br>这只是功能的划分，是一个抽象的参考模型。进行网络通信时，每层提供本层对应的功能；<br>1）通信实体的对等层之间不允许直接通信，<br>  它们之间是虚拟通信，实际通信在最底层完成；<br>2）各层之间是严格单向依赖；<br>3）上层使用下层提供的服务 — Service user；<br>4）下层向上层提供服务 — Service provider。<br>5）对等层实体之间虚拟通信；<br>6）下层向上层提供服务，实际通信在最底层完成。</p><p>OSI各层所使用的协议<br>1）应用层：远程登录协议Telnet、文件传输协议FTP<br>          （网上下载一个软件或者资料的时候就会使用<br>      该协议）、 超文本传输协议HTTP（使用较多，<br>      通过IE浏览一个网页的时候就使用该协议）<br>      、域名服务DNS（使用较多，通过网络访问一<br>      个计算机一般不使用该主机的IP地址，而是通<br>      过该主机的域名访问）、简单邮件传输协议SMTP<br>      （通过Foxmail发送邮件）、邮局协议POP3等（<br>      通过Foxmail收邮件);</p><p>2）传输层：传输控制协议TCP、用户数据报协议UDP；<br>TCP：面向连接的可靠的传输协议；在利用TCP协<br>    议进行通信的时候，首先要经过三步握手建<br>    立起通信双方的连接，一旦连接建立后就可<br>    以通信了。TCP协议提供数据确认和重传的<br>    机制，保证数据一定能够到达数据接收端。<br>    像打电话。<br>UDP：是无连接的，不可靠的传输协议；<br>     采用UDP协议进行通信时，不需要建立连接，<br>     可以直接向一个IP地址发送数据，至于是不<br>     是能够收到不能保证，发送过程中数据有可<br>     能丢失、IP地址可能不存在、再者IP地址代<br>     表的主机没有运行等原因都可能导致不能接<br>     收到数据。</p><p>TCP/IP:有保障，成本较高。<br>       是一种可靠的协议，通信之前先建立连接。<br>       适合较小的数据量，保障通信质量。<br>       如：上传和下载文件。<br>UDP：无保障，通信成本较低。<br>     是一种不可靠的协议，通信之前不会建立连接，发送数据包。<br>     数据包中包含目的地的地址。<br>     适合于大数据量，不介意丢失少量数据的通信。<br>      如：视频聊天</p><p>3）网络层：网际协议IP、Internet互联网控制报<br>          文协议ICMP、Internet组管理协议IGMP。</p><p>四：IP地址和端口号<br>IP地址：最重要的路由寻址<br>1）网络中每台主机都必须有一个惟一的IP地址；<br>2）IP地址是一个逻辑地址；<br>3）因特网上的IP地址具有全球唯一性；<br>4）32位，4个字节，常用点分十进制的格式表示，例如：192.168.0.16。</p><p>端口：用来标识唯一的应用程序<br>     使用一个16位的数字来表示，它的范围是0–65535<br>     ,1024以下的端口号保留给预定义的服务。例如：<br>     23-telnet,21-ftp,25-邮件传输,http使用80端口</p><p>五：基于TCP的Socket编程步骤：<br>套接字：代表通信节点<br>1）服务器程序编写：<br>    ①调用ServerSocket(int port)创建一个服务器端套接字，<br>      并绑定到指定端口上；<br>    ②调用accept()，监听连接请求，如果客户端请求连接，<br>      则接受连接，返回通信套接字；<br>    ③调用Socket类的getOutputStream()和<br>      getInputStream获取输出流和输入流，<br>      开始网络数据的发送和接收；<br>    ④最后关闭通信套接字。<br>2）客户端程序编写：<br>    ①调用Socket()创建一个流套接字，并连接到服务器端；<br>    ②调用Socket类的getOutputStream()<br>     和getInputStream获取输出流和输入流，<br>     开始网络数据的发送和接收；<br>    ③最后关闭通信套接字。</p><p>package com.briup.io;<br>import java.io.*;<br>//读数据类<br>class ReadFrom{<br>    private RandomAccessFile raf;<br>    public ReadFrom(RandomAccessFile raf){<br>        this.raf=raf;<br>    }<br>    public synchronized int read(long pos,byte[] buff) throws IOException{<br>        raf.seek(pos);<br>        return raf.read(buff);</p><pre><code>} </code></pre><p>}<br>//写数据类<br>class WriteTo{<br>    private RandomAccessFile raf;<br>    public WriteTo(RandomAccessFile raf){<br>        this.raf=raf;<br>    }<br>    public synchronized void write(byte[] buff,int len,long pos) throws IOException{<br>        raf.seek(pos);<br>        raf.write(buff, 0, len);<br>    }<br>}<br>public class RandomAccessFileTest {<br>    public static void main(String[] args){<br>        File file=new File(“src/com/briup/io/a.txt”);<br>        long len=file.length();<br>        //目标文件<br>        File f=new File(“src/com/briup/io/test”);</p><pre><code>    try {        //读        RandomAccessFile raf1=new RandomAccessFile(file, &quot;r&quot;);        //写        RandomAccessFile raf2=new RandomAccessFile(f, &quot;rw&quot;);        ReadFrom rf=new ReadFrom(raf1);        WriteTo wt=new WriteTo(raf2);        Thread[] t=new Thread[3];        for(int i=0;i&lt;3;i++){            t[i]=new CopyData(i*len/3,(i+1)*len/3,rf,wt);            t[i].start();        }    } catch (FileNotFoundException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p>}<br>class CopyData extends Thread{<br>    private long begin;//开始位置<br>    private long end;//结束位置<br>    private ReadFrom rf;<br>    private WriteTo wt;<br>    public CopyData(long begin,long end,ReadFrom rf,WriteTo wt){<br>        this.begin=begin;<br>        this.end=end;<br>        this.rf=rf;<br>        this.wt=wt;<br>    }<br>    public void run(){<br>        byte[] buff=new byte[128];<br>        int length=0;</p><pre><code>        try {            while(begin&lt;end){                length=rf.read(begin, buff);                if(begin+length&gt;end)//判断每段最后一点的有效长度                    length=(int)(end-begin);                wt.write(buff, length, begin);                begin+=length;            }        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }}</code></pre><p>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class PipedStreamTest {<br>public static void main(String[] args){<br>    PipedInputStream pis=null;<br>    PipedOutputStream pos=null;</p><pre><code>try {    pis=new PipedInputStream();    //pos=new PipedOutputStream(pis);//需要将管道连接    pos=new PipedOutputStream();    pis.connect(pos);//第二种也是将管道连接    Sender1 s=new Sender1(pos);    Fecter1 f=new Fecter1(pis);    s.start();    f.start();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}</code></pre><p>}<br>}<br>//写数据的线程<br>class Sender1 extends Thread{<br>    private PipedOutputStream pos;<br>    public Sender1(PipedOutputStream pos){<br>        this.pos=pos;<br>    }<br>    @Override<br>    public void run(){<br>        DataOutputStream dos=new DataOutputStream(pos);<br>        for(int i=1;i&lt;=10;i++){<br>            try {<br>                dos.writeInt(i);<br>                dos.flush();<br>                sleep(1000);<br>            } catch (IOException | InterruptedException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }</p><pre><code>    }}</code></pre><p>}<br>//读数据线程<br>class Fecter1 extends Thread{<br>    private PipedInputStream pis;<br>    public Fecter1(PipedInputStream pis){<br>        this.pis=pis;<br>    }<br>    public void run(){<br>        DataInputStream dis=new DataInputStream(pis);<br>        for(int i=1;i&lt;=10;i++){<br>            try {<br>                //readInt()<br>                //具有阻塞功能，一旦发现没有数据就会阻塞，<br>                //释放cpu，这样写数据线程就可以使用，之后在进行读<br>                int v=dis.readInt();<br>                System.out.println(v);<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}</p><p>package com.briup.io;<br>import java.io.<em>;<br>public class FileTest {<br>public static void main(String[] args){<br>    //创建文件对象<br>    File file=new File(“src/com/briup/io”);<br>    //System.out.println(file.isDirectory());//判断文件是否是一个目录<br>    String[] list=file.list();<br>    /</em>for(String temp:list){<br>        System.out.println(temp);<br>    }*/<br>    File f=new File(file,”test”);<br>    System.out.println(f.exists());//判断文件是否存在<br>    if(!f.exists()){<br>        try {<br>            f.createNewFile();//创建文件<br>        } catch (IOException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }//创建文件<br>    }</p><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class FileCopy2 {<br>public static void main(String[] args){<br>       //第一步选择合适的流<br>      FileReader fr=null;<br>      FileWriter fw=null;<br>      //第二步初始化流<br>      try {<br>        fr=new FileReader(“src/com/briup/io/FileCopy2.java”);<br>        fw=new FileWriter(“src/com/briup/io/aa.txt”);<br>        char[] buff=new char[128];<br>        int length=-1;<br>        while((length=fr.read(buff))!=-1){<br>            fw.write(buff, 0, length);<br>        }<br>        fw.flush();//必须刷新<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>        CloseUtil.close(fw, fr);<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.<em>;<br>public class FileCopy {<br>public static void main(String[] args){<br>    //第一步：选择合适的流<br>    FileInputStream fis=null;<br>    FileOutputStream fos=null;<br>    //第二步创建流对象<br>    try {<br>        //读取路径<br>        fis=new FileInputStream(<br>                new File(“src/com/briup/io/FileCopy.java”));<br>        //存放路径<br>        fos=new FileOutputStream(<br>                new File(“src/com/briup/io/a.txt”));<br>        //第三步读写数据<br>          /</em>int temp=-1;<br>          while((temp=fis.read())!=-1){<br>              //System.out.print((char)temp);<br>              fos.write(temp);//写入文件<br>          }*/<br>          byte[] buff=new byte[30];<br>          int length=-1;<br>          while((length=fis.read(buff))!=-1){<br>              //System.out.println(new String(buff,0,length));<br>              fos.write(buff, 0, length);<br>          }<br>    } catch (FileNotFoundException e) {</p><pre><code>    e.printStackTrace();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}finally{    try {        //关闭资源        fis.close();        fos.close();    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;</p><p>import com.briup.pojo.Employee;</p><p>public class EmployeeTest {<br>public static void main(String[] args){<br>      ObjectInputStream ois=null;<br>      ObjectOutputStream oos=null;<br>      try {<br>        oos=new ObjectOutputStream(<br>                  new FileOutputStream(“src/com/briup/io/emp”));<br>        Employee e1=new Employee(1, “张三”, 5000);<br>        Employee e2=new Employee(2,”李四”,6000);<br>        Employee e3=new Employee(3,”王五”,4000);<br>        oos.writeObject(e1);<br>        oos.writeObject(e2);<br>        oos.writeObject(e3);<br>        ois=new ObjectInputStream(<br>                new FileInputStream(“src/com/briup/io/emp”));<br>          Employee t1=(Employee)ois.readObject();<br>          System.out.println(t1);<br>          Employee t2=(Employee)ois.readObject();<br>          System.out.println(t2);<br>          /<em>Object temp=null;<br>          while((temp=ois.readObject())!=null){<br>              System.out.println((Employee)temp);<br>          }error</em>/</p><pre><code>} catch (IOException e) {    e.printStackTrace();} catch (ClassNotFoundException e) {    // TODO Auto-generated catch block    e.printStackTrace();}finally{    CloseUtil.close(ois, oos);}</code></pre><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;</p><p>public class DataStreamTest {<br>public static void main(String[] args){<br>    DataInputStream dis=null;<br>    DataOutputStream dos=null;<br>    try {<br>        dos=new DataOutputStream(<br>                new FileOutputStream(“src/com/briup/io/data”));<br>         dos.writeInt(20);<br>         dos.writeBoolean(true);<br>         dos.writeDouble(5.9);<br>         dos.writeUTF(“hello world”);<br>         dis=new DataInputStream(<br>                 new FileInputStream(“src/com/briup/io/data”));<br>         int i=dis.readInt();<br>         boolean flag=dis.readBoolean();<br>         double d=dis.readDouble();<br>         String s=dis.readUTF();<br>         System.out.println(i+”:”+flag+”:”+d+”:”+s);<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>        CloseUtil.close(dis, dos);<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class CloseUtil {<br>public static void close(InputStream is,OutputStream os){<br>    try {<br>        if(is!=null) is.close();<br>        if(os!=null) os.close();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }</p><p>}<br>public static void close(Writer is,Reader os){<br>    try {<br>        if(is!=null) is.close();<br>        if(os!=null) os.close();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }</p><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class BufferedTest2 {<br>public static void main(String[] args){<br>    BufferedReader br=null;<br>    BufferedWriter bw=null;<br>    try {<br>        br=new BufferedReader(<br>                new InputStreamReader(<br>                        new FileInputStream(<br>                                “src/com/briup/io/BufferedTest2.java”),”utf-8”));<br>        bw=new BufferedWriter(<br>                new OutputStreamWriter(<br>                        new FileOutputStream(“src/com/briup/io/aaa.txt”),”utf-8”));<br>        String line=null;<br>        while((line=br.readLine())!=null){<br>            //bw.write(line+”\n”);<br>            bw.write(line);<br>            bw.newLine();//插入换行符，会根据系统判定</p><pre><code>    }    bw.flush();} catch (FileNotFoundException e) {    // TODO Auto-generated catch block    e.printStackTrace();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}finally{    CloseUtil.close(bw, br);}</code></pre><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class BufferedStreamTest {<br>public static void main(String[] args){<br>    //第一步选择合适的流<br>    BufferedInputStream bis=null;<br>    BufferedOutputStream bos=null;<br>    FileInputStream fis=null;<br>    FileOutputStream fos=null;<br>    //第二步创建流对象<br>    try {<br>        fis=new FileInputStream(<br>                new File(“src/com/briup/io/FileCopy.java”));<br>        bis=new BufferedInputStream(fis);<br>        fos=new FileOutputStream(“src/com/briup/io/a.txt”);<br>        bos=new BufferedOutputStream(fos);<br>    //第三步读写数据<br>        byte[] buff=new byte[128];<br>        int length=-1;<br>        while((length=bis.read(buff))!=-1){<br>            bos.write(buff, 0, length);<br>        }<br>        bos.flush();//手动刷新到输出流中<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>            try {<br>                if(fis!=null) fis.close();<br>                if(fos!=null) fos.close();<br>                if(bis!=null) bis.close();<br>                if(bos!=null) bos.close();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.<em>;<br>public class BufferedRWTest {<br>public static void main(String[] args){<br>    BufferedReader br=null;<br>    //BufferedWriter bw=null;<br>    PrintWriter pw=null;<br>    try {<br>        br=new BufferedReader(<br>                new FileReader(“src/com/briup/io/BufferedRWTest.java”));<br>        /</em>bw=new BufferedWriter(<br>                new FileWriter(“src/com/briup/io/aa.txt”));<em>/<br>        pw=new PrintWriter(“src/com/briup/io/aa.txt”);<br>        /</em>char[] buff=new char[128];<br>        int length=-1;<br>        while((length=br.read(buff))!=-1){<br>            bw.write(buff, 0, length);<br>        }<br>        bw.flush();//必须刷新*/<br>        String line=null;<br>        while((line=br.readLine())!=null){<br>            //bw.write(line+”\n”);<br>            //bw.write(line);<br>            //bw.newLine();//插入换行符，会根据系统判定<br>            pw.println(line);<br>        }<br>        //bw.flush();<br>        pw.flush();<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>        //CloseUtil.close(bw, br);<br>        CloseUtil.close(pw, br);<br>    }<br>}<br>}</p><p>package com.briup.net;<br>import java.net.<em>;<br>import java.io.</em>;<br>//基于TCP协议的客户端<br>public class TCPClient {<br>public static void main(String[] args) {<br>    //1.创建Socket对象<br>    Socket socket=null;<br>    try {<br>        socket=new Socket(“127.0.0.1”,9999);<br>        //2.读写数据<br>        //先往服务器端写数据<br>        PrintWriter out=new PrintWriter(<br>                socket.getOutputStream());//管道输出流<br>        out.println(“你好，服务器，请给我当前时间”);<br>        out.flush();<br>        //读取服务器端返回的数据<br>        BufferedReader br=new BufferedReader(<br>                new InputStreamReader(socket.getInputStream()));<br>        String msg = br.readLine();<br>        System.out.println(“服务器端说:”+msg);</p><pre><code>} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}</code></pre><p>}<br>}</p><p>package com.briup.net;<br>import java.net.<em>;<br>import java.util.Date;<br>import java.io.</em>;<br>//基于TCP协议的服务器端<br>public class TCPServer {<br>public static void main(String[] args){</p><pre><code>ServerSocket ss=null;try {    //1.创建serversocket对象    ss=new ServerSocket(9999);    System.out.println(&quot;服务器端在9999端口启动&quot;);    //2.等待客户端的连接    //accept具有阻塞功能，可以一直停留在这，直到获取客户端连入    Socket socket=ss.accept();    System.out.println(&quot;有客户端来了&quot;);    //3.读写数据    InputStream is = socket.getInputStream();//获取管道输入流    BufferedReader br=new BufferedReader(            new InputStreamReader(is));    String msg = br.readLine();    System.out.println(&quot;客户端说:&quot;+msg);    //给客户端返回数据    PrintWriter out=new PrintWriter(socket.getOutputStream());    out.println(new Date().toString());    out.flush();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}</code></pre><p>}<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三十一天笔记</title>
      <link href="/2018/11/01/index31/"/>
      <url>/2018/11/01/index31/</url>
      
        <content type="html"><![CDATA[<p>e)ObjectInputStream和ObjectOutputStream<br>   针对于类类型的数据(对象)进行操作。<br>  序列化：将对象保存到文件中或者传输到网络的过程<br>  反序列化：将文件中或者网络中将对象读取到程序的过程<br>  进行序列化或者反序列化的类必须实现Serializable接口。<br>  该接口是一个空接口，只是起到了标识的作用，<br>  标识该对象可以进行序列化和反序列化操作。<br>  serialVersionUID用来表明实现序列化类的不<br>  同版本间的兼容性。如果你修改了此类, 要修<br>  改此值。否则以前用老版本的类序列化的类恢<br>  复时会出错。<br>  transient：该修饰的属性不会被序列化。是透明的属性。</p><p>f)PipedInputStream,PipedOutputStream<br>   管道输入，输出流，<br>   针对线程读取和写入数据<br>   connect():管道输入流连接到管道输出流</p><p>g)Reader,Writer抽象类<br>  是所有字符流输出和输入的父类。<br>  字符流是在字节流的基础上进行字符编码(UTF-8,GBK,GB2312…)<br>h)InputStreamReader,OutputStreamWriter<br>  一组转换流—&gt;字节和字符之间的转换。<br>  InputStreamReader：字节转换成字符的桥梁<br>  OutputStreamWriter:字符转换成字节的桥梁<br>i)BufferedReader,BufferedWriter<br>  带有缓冲区的字符流。<br>   1)保存hello,您好时指定编码方式。<br>      取数据时也指定编码方式。<br>   2)采用这种方式完成文件的拷贝工作。<br>j)FileReader和FileWriter<br>  针对文件的字符流<br>k)PrintWriter,PrintStream<br>  都是输出流,可以进行格式化输出<br>  PrintWriter:即可以包装字符类，也可以包装字节流。<br>  PrintStream即可以输出字符，也可以输出字节</p><p>L)File对象<br>M)RandomAccessFile<br>  在文件的任意位置进行读和写的操作<br>  seek(long),read(),writer();<br>  当操作大文件的时候使用该类。</p><p>package com.briup.io;<br>import java.io.*;<br>public class BufferedTest2 {<br>public static void main(String[] args){<br>    BufferedReader br=null;<br>    BufferedWriter bw=null;<br>    try {<br>        br=new BufferedReader(<br>                new InputStreamReader(<br>                        new FileInputStream(<br>                                “src/com/briup/io/BufferedTest2.java”),”utf-8”));<br>        bw=new BufferedWriter(<br>                new OutputStreamWriter(<br>                        new FileOutputStream(“src/com/briup/io/aaa.txt”),”utf-8”));<br>        String line=null;<br>        while((line=br.readLine())!=null){<br>            //bw.write(line+”\n”);<br>            bw.write(line);<br>            bw.newLine();//插入换行符，会根据系统判定</p><pre><code>    }    bw.flush();} catch (FileNotFoundException e) {    // TODO Auto-generated catch block    e.printStackTrace();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}finally{    CloseUtil.close(bw, br);}</code></pre><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class BufferedStreamTest {<br>public static void main(String[] args){<br>    //第一步选择合适的流<br>    BufferedInputStream bis=null;<br>    BufferedOutputStream bos=null;<br>    FileInputStream fis=null;<br>    FileOutputStream fos=null;<br>    //第二步创建流对象<br>    try {<br>        fis=new FileInputStream(<br>                new File(“src/com/briup/io/FileCopy.java”));<br>        bis=new BufferedInputStream(fis);<br>        fos=new FileOutputStream(“src/com/briup/io/a.txt”);<br>        bos=new BufferedOutputStream(fos);<br>    //第三步读写数据<br>        byte[] buff=new byte[128];<br>        int length=-1;<br>        while((length=bis.read(buff))!=-1){<br>            bos.write(buff, 0, length);<br>        }<br>        bos.flush();//手动刷新到输出流中<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>            try {<br>                if(fis!=null) fis.close();<br>                if(fos!=null) fos.close();<br>                if(bis!=null) bis.close();<br>                if(bos!=null) bos.close();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.<em>;<br>public class BufferedRWTest {<br>public static void main(String[] args){<br>    BufferedReader br=null;<br>    //BufferedWriter bw=null;<br>    PrintWriter pw=null;<br>    try {<br>        br=new BufferedReader(<br>                new FileReader(“src/com/briup/io/BufferedRWTest.java”));<br>        /</em>bw=new BufferedWriter(<br>                new FileWriter(“src/com/briup/io/aa.txt”));<em>/<br>        pw=new PrintWriter(“src/com/briup/io/aa.txt”);<br>        /</em>char[] buff=new char[128];<br>        int length=-1;<br>        while((length=br.read(buff))!=-1){<br>            bw.write(buff, 0, length);<br>        }<br>        bw.flush();//必须刷新*/<br>        String line=null;<br>        while((line=br.readLine())!=null){<br>            //bw.write(line+”\n”);<br>            //bw.write(line);<br>            //bw.newLine();//插入换行符，会根据系统判定<br>            pw.println(line);<br>        }<br>        //bw.flush();<br>        pw.flush();<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>        //CloseUtil.close(bw, br);<br>        CloseUtil.close(pw, br);<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class CloseUtil {<br>public static void close(InputStream is,OutputStream os){<br>    try {<br>        if(is!=null) is.close();<br>        if(os!=null) os.close();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }</p><p>}<br>public static void close(Writer is,Reader os){<br>    try {<br>        if(is!=null) is.close();<br>        if(os!=null) os.close();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }</p><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;</p><p>import com.briup.pojo.Employee;</p><p>public class EmployeeTest {<br>public static void main(String[] args){<br>      ObjectInputStream ois=null;<br>      ObjectOutputStream oos=null;<br>      try {<br>        oos=new ObjectOutputStream(<br>                  new FileOutputStream(“src/com/briup/io/emp”));<br>        Employee e1=new Employee(1, “张三”, 5000);<br>        Employee e2=new Employee(2,”李四”,6000);<br>        Employee e3=new Employee(3,”王五”,4000);<br>        oos.writeObject(e1);<br>        oos.writeObject(e2);<br>        oos.writeObject(e3);<br>        ois=new ObjectInputStream(<br>                new FileInputStream(“src/com/briup/io/emp”));<br>          Employee t1=(Employee)ois.readObject();<br>          System.out.println(t1);<br>          Employee t2=(Employee)ois.readObject();<br>          System.out.println(t2);<br>          /<em>Object temp=null;<br>          while((temp=ois.readObject())!=null){<br>              System.out.println((Employee)temp);<br>          }error</em>/</p><pre><code>} catch (IOException e) {    e.printStackTrace();} catch (ClassNotFoundException e) {    // TODO Auto-generated catch block    e.printStackTrace();}finally{    CloseUtil.close(ois, oos);}</code></pre><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;</p><p>public class DataStreamTest {<br>public static void main(String[] args){<br>    DataInputStream dis=null;<br>    DataOutputStream dos=null;<br>    try {<br>        dos=new DataOutputStream(<br>                new FileOutputStream(“src/com/briup/io/data”));<br>         dos.writeInt(20);<br>         dos.writeBoolean(true);<br>         dos.writeDouble(5.9);<br>         dos.writeUTF(“hello world”);<br>         dis=new DataInputStream(<br>                 new FileInputStream(“src/com/briup/io/data”));<br>         int i=dis.readInt();<br>         boolean flag=dis.readBoolean();<br>         double d=dis.readDouble();<br>         String s=dis.readUTF();<br>         System.out.println(i+”:”+flag+”:”+d+”:”+s);<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>        CloseUtil.close(dis, dos);<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class PipedStreamTest {<br>public static void main(String[] args){<br>    PipedInputStream pis=null;<br>    PipedOutputStream pos=null;</p><pre><code>try {    pis=new PipedInputStream();    //pos=new PipedOutputStream(pis);//需要将管道连接    pos=new PipedOutputStream();    pis.connect(pos);//第二种也是将管道连接    Sender1 s=new Sender1(pos);    Fecter1 f=new Fecter1(pis);    s.start();    f.start();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}</code></pre><p>}<br>}<br>//写数据的线程<br>class Sender1 extends Thread{<br>    private PipedOutputStream pos;<br>    public Sender1(PipedOutputStream pos){<br>        this.pos=pos;<br>    }<br>    @Override<br>    public void run(){<br>        DataOutputStream dos=new DataOutputStream(pos);<br>        for(int i=1;i&lt;=10;i++){<br>            try {<br>                dos.writeInt(i);<br>                dos.flush();<br>                sleep(1000);<br>            } catch (IOException | InterruptedException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }</p><pre><code>    }}</code></pre><p>}<br>//读数据线程<br>class Fecter1 extends Thread{<br>    private PipedInputStream pis;<br>    public Fecter1(PipedInputStream pis){<br>        this.pis=pis;<br>    }<br>    public void run(){<br>        DataInputStream dis=new DataInputStream(pis);<br>        for(int i=1;i&lt;=10;i++){<br>            try {<br>                //readInt()<br>                //具有阻塞功能，一旦发现没有数据就会阻塞，<br>                //释放cpu，这样写数据线程就可以使用，之后在进行读<br>                int v=dis.readInt();<br>                System.out.println(v);<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class FileCopy2 {<br>public static void main(String[] args){<br>       //第一步选择合适的流<br>      FileReader fr=null;<br>      FileWriter fw=null;<br>      //第二步初始化流<br>      try {<br>        fr=new FileReader(“src/com/briup/io/FileCopy2.java”);<br>        fw=new FileWriter(“src/com/briup/io/aa.txt”);<br>        char[] buff=new char[128];<br>        int length=-1;<br>        while((length=fr.read(buff))!=-1){<br>            fw.write(buff, 0, length);<br>        }<br>        fw.flush();//必须刷新<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>        CloseUtil.close(fw, fr);<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.<em>;<br>public class FileCopy {<br>public static void main(String[] args){<br>    //第一步：选择合适的流<br>    FileInputStream fis=null;<br>    FileOutputStream fos=null;<br>    //第二步创建流对象<br>    try {<br>        //读取路径<br>        fis=new FileInputStream(<br>                new File(“src/com/briup/io/FileCopy.java”));<br>        //存放路径<br>        fos=new FileOutputStream(<br>                new File(“src/com/briup/io/a.txt”));<br>        //第三步读写数据<br>          /</em>int temp=-1;<br>          while((temp=fis.read())!=-1){<br>              //System.out.print((char)temp);<br>              fos.write(temp);//写入文件<br>          }*/<br>          byte[] buff=new byte[30];<br>          int length=-1;<br>          while((length=fis.read(buff))!=-1){<br>              //System.out.println(new String(buff,0,length));<br>              fos.write(buff, 0, length);<br>          }<br>    } catch (FileNotFoundException e) {</p><pre><code>    e.printStackTrace();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}finally{    try {        //关闭资源        fis.close();        fos.close();    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p>}<br>}</p><p>package com.briup.pojo;</p><p>import java.io.Serializable;</p><p>public class Employee implements Serializable{</p><p>/**</p><pre><code> *  */private static final long serialVersionUID = 1L;</code></pre><p>private int id;<br>private String name;<br>//transient具有加密功能<br>private transient double salary;<br>public Employee(int id,String name,double salary){<br>    this.id=id;<br>    this.name=name;<br>    this.salary=salary;<br>}<br>public void setId(int id){<br>    this.id=id;<br>}<br>public int getId(){<br>    return id;<br>}<br>public void setName(String name){<br>    this.name=name;<br>}<br>public String getName(){<br>    return name;</p><p>}<br>public void setSalary(double salary){<br>    this.salary=salary;<br>}<br>public double getSalary(){<br>    return salary;<br>}<br>@Override<br>public String toString(){<br>    return “id=”+id+”;name=”+name+”;salary=”+salary;<br>}<br>}</p><p>写Copy类</p><p>要求：将1个文件的内容同时复制到多个文件</p><p>import java.io.File;</p><p>import java.io.FileInputStream;</p><p>import java.io.FileOutputStream;</p><p>import java.io.IOException;</p><p>public class CopyTest {</p><p>public static void main(String[] args) {</p><p>​    File file1=new File(“src/file1.txt”);</p><p>​    File file2=new File(“src/file2.txt”);</p><p>​    File file3=new File(“src/file3.txt”);</p><p>​    File file4=new File(“src/file4.txt”);</p><p>​    try {</p><p>​        file1.createNewFile();</p><p>​        file2.createNewFile();</p><p>​        file3.createNewFile();</p><p>​        file4.createNewFile();</p><p>​        CopyFile cf=new CopyFile();</p><p>​        cf.show(file1, file2);</p><p>​        cf.show(file1, file3);</p><p>​        cf.show(file1, file4);</p><p>​        </p><p>​    } catch (IOException e) {</p><p>​        // TODO Auto-generated catch block</p><p>​        e.printStackTrace();</p><p>​    }</p><p>}</p><p>}</p><p>class CopyFile{</p><p>​    public void show(File file1,File file2){</p><p>​        FileInputStream in=null;</p><p>​        FileOutputStream out=null;</p><p>​        try {</p><p>​            in=new FileInputStream(file1);</p><p>​            out=new FileOutputStream(file2,false);</p><p>​            int len=-1;</p><p>​            while ((len=in.read())!=-1) {</p><p>​                out.write(len);</p><p>​                out.flush();</p><p>​            }</p><p>​        } catch (Exception e) {</p><p>​            // TODO Auto-generated catch block</p><p>​            e.printStackTrace();</p><p>​        }</p><p>​    }</p><p>}</p><p>写PropertiesFile类</p><p>要求：</p><p>在message文件中存放prop_name=prop_value格式的属性，每行存放一个属性。</p><p>从命令行输入一个属性名，找出其对应的属性值并输出。</p><p>public class PropertiesFile {</p><p>public static void main(String[] args) {</p><p>​    FileReader fr=null;</p><p>​    BufferedReader br=null;</p><p>​    try {</p><p>​        fr=new FileReader(new File(“src/message”));</p><p>​        br=new BufferedReader(fr);</p><p>​        String len=””;</p><p>​        Scanner sc=new Scanner(System.in);</p><p>​        String str=sc.next();</p><p>​        while ((len=br.readLine())!=null) {</p><p>​            String[] strs=len.split(“=”);</p><p>​            if (str.equals(strs[0])) {</p><p>​                System.out.println(strs[1]);</p><p>​            }</p><p>​        }</p><p>​    } catch (Exception e) {</p><p>​        // TODO Auto-generated catch block</p><p>​        e.printStackTrace();</p><p>​    }finally{</p><p>​        </p><p>​            try {</p><p>​                if(br!=null)</p><p>​                    br.close();</p><p>​                if(fr!=null)</p><p>​                fr.close();</p><p>​                </p><p>​            } catch (IOException e) {</p><p>​                // TODO Auto-generated catch block</p><p>​                e.printStackTrace();</p><p>​            }</p><p>​        </p><p>​    }</p><p>}</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三十天笔记</title>
      <link href="/2018/10/31/index30/"/>
      <url>/2018/10/31/index30/</url>
      
        <content type="html"><![CDATA[<p>第七章  IO流</p><p>一：流的概念</p><p>程序的主要任务是操纵数据。</p><p>在Java中，把一组有序的数据序列称为流。</p><p>​    如a.txt的文件拷贝到b.txt中。</p><p>在Java中流是使用统一的方式操作输入和输出的数据。</p><p>从文件中读取，从键盘读取，从网络中读取…</p><p>输出到文件，发送到网络….</p><p>流就是一个对象。所在的包java.io.*</p><p>Java I/O系统负责处理程序的输入和输出，</p><p>java.io包它对各种常见的输入流和输出流进行了抽象。</p><p>二：流的分类</p><p>  1)根据流操作的方向,参照物：当前程序</p><p>​    a)输入流:将数据读取到程序中就是输入流</p><p>​    b)输出流:将程序中的数据写出到文件中就是输出流。</p><p>  2)根据类操作的最小数据单元。</p><p>​    a)字节类：如果数据流中最小的数据单元是字节，</p><p>​              那么称这种流为字节流；</p><p>​          字节流处理单元为 1 个字节，可以操作字节和字节数组</p><p>​    b)字符类：如果数据流中最小的数据单元是字符，</p><p>​              那么称这种流为字符流。</p><p>​          字符流处理的单元为 2 个字节的 Unicode 字符，</p><p>​          可以操作字符、字符数组或字符串。</p><p>​          Java内用Unicode 编码存储字符,字符流处理类负责</p><p>​          将外部的其他编码的字符流和java内Unicode 字符</p><p>​          流之间的转换。</p><p>​          字符流（一次可以处理一个缓冲区）一次操作比</p><p>​          字节流（一次一个字节）效率高</p><p>三：需要掌握的流</p><p>a)java.io.InputStream和java.io.OutputStream</p><p>  分别表示字节输入流和字节输出流，</p><p>  是所有字节输入和输出流的父类.其中的方法参照下面的四</p><p>b)FileInputStream,FileOutputStream</p><p>  针对文件进行字节操作。</p><p>c)BufferedOutputStream和BufferInputStream流</p><p>  带有缓冲区的流。—调用flush()刷新缓冲流。</p><p>  增强输入和输出流的性能。</p><p>  提高读写的效率。</p><p>  包装流是可以对其他流进行重新包装。</p><p>d)DataInputStream和DataOutputStream.</p><p>  针对于基本数据类型进行操作</p><p>  在java.io包中，java.io.InputStream表示字节输入流，</p><p>java.io.OutputStream表示字节输出流，它们都是抽象类，</p><p>不能被实例化。</p><p>InputStream类提供了一系列和读取数据有关的方法：</p><p>\1. read(): 从输入流读取数据：有三种重载形式：　</p><p> a)int read(): 从输入流读取一个8位的字节，</p><p>​              把它转换为0-255之间的整数，并返回这一整数。</p><p>​          例如，如果读到的字节为9，则返回9，如果读到</p><p>​          的字节为-9，则返回247。如果遇到输入流的结尾，则返回-1;</p><p> b)int read(byte[] b): 从输入流读取若干个字节，把它们保存</p><p>​            到参数b指定的字节数组中。返回的整数表示读取的字节数。</p><p>​        如果遇到输入流的结尾，则返回-1;</p><p> c)int read(byte[] b, int off, int len): 从输入流读取若干个字节，</p><p>​         把它们保存到参数b指定的字节数组中。 返回的整数表示读取的字节数。</p><p>​     参数off指定在字节数组中开始保存数据的起始下标，参数len指定读取</p><p>​     的字节数目。返回的整数表示实现读取的字节数。如果遇到输入流的结</p><p>​     尾，则返回-1;</p><p>以上第一个read方法从输入流读取一个字节，而其余两个read方法从输入</p><p>流批量读取若干字节。在从文件或键盘读数据时，采用后面两个read方法</p><p>可以减少进行物理读文件或键盘的次数，因此能提高I/O操作的效率。</p><p>\2. void close(): 关闭输入流，InputStream类本身的close()方法不执</p><p>  行任何操作。它的一些子类覆盖了close()方法，在close()方法中释</p><p>  放和流有关的系统资源。</p><p>\3. int available(): 返回可以从输入流</p><p>​        中读取的字节数目；</p><p>\4. skip(long): 从输入流中跳过参数n指定数目的字节。</p><p>\5. boolean markSupported()，void mark(int)，void reset(): </p><p>如果要从流中重复读入数据，先用markSupported()方法来判断这</p><p>个流是否支持重复读入数据，如果返回true，则表明可以在流上设</p><p>置标记。接下来调用mark(int readLimit)方法从流的当前位置开始</p><p>设置标记。最后调用reset()方法，该方法使输入流重新定位到刚才</p><p>做了标记的起始位置。这样就可以重复读取做过标记的数据了。</p><p>　OuputStream类提供了一系列和写数据有关的方法：</p><p>\1. write(): 向输出流写入数据：有三种重载形式：</p><p> a)void write(int b):向输出流写入一个字节；</p><p> b)void write(byte[] b): 把参数b指定的字节数组中的所有字节写到输出流；</p><p> c)void write(byte[] b, int off, int len): 把参数b指定的字节数组中的所</p><p>​      有字节写到输出流，参数off指定字节数组的起始下标，从这个位置开始</p><p>​      输出由参数len指定数目的字节； 以上第一个write方法从输出流写入一</p><p>​      个字节，而其余两个write方法从输出流批量写出若干字节。在向文件或</p><p>​      控制台写数据时，采用后面两个write方法可以减少进行物理读文件或键</p><p>​      盘的次数，因此能提高I/O操作的效率。</p><p>\2. void close(): 关闭输出流，OutputStream类本身的close()</p><p>方法不执行任何操作。它的一些子类覆盖了close()方法，在</p><p>close()方法中释放和流有关的系统资源。</p><p>\3. void flush(): OutputStream类本身的flush()方法不执行</p><p>任何操作，它的一些带有缓冲区的子类(</p><p>比如BufferedOutputStream和PrintStream类)覆盖了flush()方法。</p><p>通过带缓冲区的输出流写数据时，数据先保存在缓冲区中，积累</p><p>到一定程度才会真正写到输出流中。缓冲区通常用字节数组实现，</p><p>实际上是指一块内存空间。flush()方法强制把缓冲区内的数据写到输出流中。</p><p>package com.briup.io;<br>import java.io.*;</p><p>public class DataStreamTest {<br>public static void main(String[] args){<br>    DataInputStream dis=null;<br>    DataOutputStream dos=null;<br>    try {<br>        dos=new DataOutputStream(<br>                new FileOutputStream(“src/com/briup/io/data”));<br>         dos.writeInt(20);<br>         dos.writeBoolean(true);<br>         dos.writeDouble(5.9);<br>         dos.writeUTF(“hello world”);<br>         dis=new DataInputStream(<br>                 new FileInputStream(“src/com/briup/io/data”));<br>         int i=dis.readInt();<br>         boolean flag=dis.readBoolean();<br>         double d=dis.readDouble();<br>         String s=dis.readUTF();<br>         System.out.println(i+”:”+flag+”:”+d+”:”+s);<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>        CloseUtil.close(dis, dos);<br>    }<br>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class CloseUtil {<br>public static void close(InputStream is,OutputStream os){<br>    try {<br>        if(is!=null) is.close();<br>        if(os!=null) os.close();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }</p><p>}<br>}</p><p>package com.briup.io;<br>import java.io.<em>;<br>public class FileCopy {<br>public static void main(String[] args){<br>    //第一步：选择合适的流<br>    FileInputStream fis=null;<br>    FileOutputStream fos=null;<br>    //第二步创建流对象<br>    try {<br>        //读取路径<br>        fis=new FileInputStream(<br>                new File(“src/com/briup/io/FileCopy.java”));<br>        //存放路径<br>        fos=new FileOutputStream(<br>                new File(“src/com/briup/io/a.txt”));<br>        //第三步读写数据<br>          /</em>int temp=-1;<br>          while((temp=fis.read())!=-1){<br>              //System.out.print((char)temp);<br>              fos.write(temp);//写入文件<br>          }*/<br>          byte[] buff=new byte[30];<br>          int length=-1;<br>          while((length=fis.read(buff))!=-1){<br>              //System.out.println(new String(buff,0,length));<br>              fos.write(buff, 0, length);<br>          }<br>    } catch (FileNotFoundException e) {</p><pre><code>    e.printStackTrace();} catch (IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();}finally{    try {        //关闭资源        fis.close();        fos.close();    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p>}<br>}</p><p>package com.briup.io;<br>import java.io.*;<br>public class BufferedStreamTest {<br>public static void main(String[] args){<br>    //第一步选择合适的流<br>    BufferedInputStream bis=null;<br>    BufferedOutputStream bos=null;<br>    FileInputStream fis=null;<br>    FileOutputStream fos=null;<br>    //第二步创建流对象<br>    try {<br>        fis=new FileInputStream(<br>                new File(“src/com/briup/io/FileCopy.java”));<br>        bis=new BufferedInputStream(fis);<br>        fos=new FileOutputStream(“src/com/briup/io/a.txt”);<br>        bos=new BufferedOutputStream(fos);<br>    //第三步读写数据<br>        byte[] buff=new byte[128];<br>        int length=-1;<br>        while((length=bis.read(buff))!=-1){<br>            bos.write(buff, 0, length);<br>        }<br>        bos.flush();//手动刷新到输出流中<br>    } catch (FileNotFoundException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    } catch (IOException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }finally{<br>            try {<br>                if(fis!=null) fis.close();<br>                if(fos!=null) fos.close();<br>                if(bis!=null) bis.close();<br>                if(bos!=null) bos.close();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br>    }<br>}<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十九天笔记</title>
      <link href="/2018/10/30/index29/"/>
      <url>/2018/10/30/index29/</url>
      
        <content type="html"><![CDATA[<p>一:线程互斥<br>   并发访问的线程加上同步锁之后就称为线程互斥。<br>   谁抢到了对象锁的线程就先执行。<br>   没有抢到对象锁的线程就等待对象锁。<br>   加同步锁，加在共享对象上。<br>   每一个对象都有唯一的一把锁。<br>   lock对象锁—-&gt;执行代码——&gt;unlock对象锁</p><p>synchronized(共享区){临界区}<br>共享区：多线程同时操作同一个对象<br>临界区：多线程对共享区进行操作的代码区<br>synchronized可以放在方法上，就是一个同步方法。</p><p>将所有影响的方法都定义成线程安全的方法就变成了线程安全的类。<br>线程安全的类—效率低</p><p>二:线程的通信—&gt;线程同步(操作的也是同一个对象)<br>线程互斥谁先抢到对象锁就谁先执行(如抛绣球)。<br>线程同步会控制线程执行的先后顺序。<br>        线程同步线程会有依赖关系。<br>一个boy存钱，一个girl取钱。必须先存钱后取钱。就是线程同步。<br>重复(存钱—-&gt;取钱)<br>存钱之后通知可以取钱。<br>取钱之后通知可以存钱。<br>并且是先存后取<br>   男:标志位flag = false;存钱 flag=true;<br>   女:标志位flag = true;取钱 flag=false;<br>模拟生成者和消费者—针对产品<br> 生成者:从1到100累加的和作为产品。<br> 消费者:打印该产品。<br>线程通信的步骤：<br>1)找到共有对象。<br>2)wait(),notify(),notifyAll()—Object类中的方法。<br>    需要对同一个资源等待，唤醒才有效。<br>    是针对对象进行等待和通知。这些方法一定要放在<br>    synchronized关键字中，用来保护共有资源。<br> 生产者生成产品之后通知消费者–notify<br> 消费者等待生产者生产产品—wait<br>3)保证wait()执行在notifyAll()方法的前面.使用标志变量。<br> notifyAll()之前先判断有没有线程在等待。<br> 如果有就通知，没有就小睡一下只有有等待线程出现。</p><p>sleep():不会释放对象锁。<br>wait()：让当前线程进入等待状态，会释放对象锁。<br>notify()：通知等待中的某个线程进入到就绪状态。会释放对象锁。<br>notifyAll():通知等待中的所有线程进入到就绪状态。会释放对象锁。<br>可以通过公交车和人和师傅来说明</p><p>三：线程的死锁<br> 多个线程同时操作多个对象很容易产生死锁。<br> 解决方式：给多个对象加对象锁的时候。<br>           将加锁的顺序保持一致，就可以避免死锁。<br>四：Thread类中其他方法<br>yield():当前线程让出CPU，给比自己优先级别还高的线程。<br>    如果当前没有比自己优先级还高的线程就没有效果。<br>setPrioirity(int)设置线程的优先级.整数越大优先级越高。<br>         取值范围在1到10.<br>         但是设置优先级高就不一定会先执行，<br>         还是会看CPU的调度。</p><p>package com.briup.thread;</p><p>public class Result {<br>private int value;<br>private boolean wait=false;<br>public int getValue(){<br>    synchronized(this){<br>        try {<br>            this.setWait(true);<br>            this.wait();//等待<br>            //wait具有阻塞功能<br>        } catch (InterruptedException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>    }<br>    return value;<br>}<br>public void setValue(int value){<br>    this.value=value;<br>    while(!this.isWait()){<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>    }<br>    //通知消费者来消费产品<br>            synchronized(this){<br>                this.notifyAll();//通知所有等待的线程<br>            }<br>}<br>public boolean isWait(){<br>    return wait;<br>}<br>public void setWait(boolean wait){<br>    this.wait=wait;<br>}<br>}</p><p>package com.briup.thread;</p><p>public class NumberThread extends Thread{<br>    static int i=1;<br> @Override<br> public void run(){<br>    //int i=1;<br>    for(;i&lt;=100;i++){<br>        System.out.println(getName()+”:”+i);<br>        try {<br>            sleep(1000);//睡眠 毫秒<br>        } catch (InterruptedException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>    }<br> }<br> public static void main(String[] args){<br>     Thread t1=new NumberThread();//创建线程对象<br>     Thread t2=new NumberThread();<br>     t1.start();//启动线程 不能直接通过对象调用run方法<br>     t2.start();<br> }<br>}</p><p>package com.briup.thread;</p><p>public class NumberRunnable implements Runnable{<br>      int i=1;<br> @Override<br> public void run(){</p><pre><code>for(;i&lt;=100;i++){    //Thread.currentThread().getName()获取当前正在执行的线程名称    System.out.println(            Thread.currentThread().getName()+&quot;:&quot;+i);    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p> }<br> public static void main(String… args){<br>     /<em>Runnable r=new NumberRunnable();<br>     Thread t1=new Thread(r);<br>     Thread t2=new Thread(r);</em>/<br>     //第二种<br>     Runnable r1=new NumberRunnable();<br>     Thread t1=new Thread(r1);<br>     Runnable r2=new NumberRunnable();<br>     Thread t2=new Thread(r2);<br>     t1.start();<br>     t2.start();<br> }<br>}</p><p>package com.briup.thread;</p><p>public class InterruptTest extends Thread{<br> @Override<br> public void run(){<br>    System.out.println(getName()+”will sleep”);<br>    try {<br>        sleep(10*1000);<br>    } catch (InterruptedException e) {<br>        System.out.println(getName()+” interrupted”);<br>    }<br>    System.out.println(getName()+” over…”);</p><p>}<br> public static void main(String… args){<br>     Thread t1=new InterruptTest();<br>     Thread t2=new InterruptTest();<br>     t2.start();<br>     t1.start();<br>     try {<br>        Thread.sleep(1000);//让主线程睡眠，先执行子线程<br>        t1.interrupt();//中断t1线程<br>        System.out.println(t1.isInterrupted());<br>        System.out.println(t2.isInterrupted());<br>        Thread.interrupted();//清空中断操作记录<br>        System.out.println(t1.isInterrupted());<br>        System.out.println(t2.isInterrupted());<br>    } catch (InterruptedException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }//</p><p> }<br>}</p><p>package com.briup.thread;</p><p>public class GuiTuTest extends Thread{<br>    private static boolean flag=false;<br>    public GuiTuTest(String name){<br>        super(name);<br>    }<br>    @Override<br>    public void run(){<br>            int sum=0;//走的长度<br>            while(sum&lt;=100){<br>                if(flag)<br>                    return;<br>                int race=(int)(Math.random()*10+1);<br>                sum+=race;<br>                System.out.println(getName()+” running “+sum);<br>                try {<br>                    sleep(1000);<br>                } catch (InterruptedException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br>            }<br>            flag=true;<br>    }<br>public static void main(String… args){<br>    System.out.println(“比赛开始…”);<br>    Thread rabbit=new GuiTuTest(“兔子”);<br>    Thread wugui=new GuiTuTest(“乌龟”);<br>    rabbit.start();<br>    wugui.start();</p><pre><code>try {    //main线程等待rabbit和wugui线程执行    rabbit.join();    wugui.join();} catch (InterruptedException e) {    // TODO Auto-generated catch block    e.printStackTrace();}System.out.println(&quot;比赛结束...&quot;);System.out.println(&quot;兔子:&quot;+rabbit.isAlive());</code></pre><p>}<br>}</p><p>package com.briup.thread;</p><p>public class AccountTest extends Thread{<br>private Account account;<br>public AccountTest(String name,Account account){<br>    super(name);//起个线程名称<br>    this.account=account;<br>}<br>@Override<br>public void run(){<br>    double amt=0.0;<br>    //double amt=account.withdeaw(1000);<br>    /<em>synchronized(account){<br>        //amt=account.deposit(1000);<br>        amt=account.withdeaw(1000);<br>    }</em>/<br>    //amt=account.deposit(1000);<br>    amt=account.withdeaw(1000);<br>    System.out.println(getName()+” from “<br>    +account.getAccountNo()+” deposit “<br>            +amt+”,balance=”+account.getBalance());<br>}<br>public static void main(String… args){<br>    //创建一个账户对象<br>    Account account=new Account(“1452361”,1000);<br>    Thread girl=new AccountTest(“girl”,account);<br>    Thread boy=new AccountTest(“boy”,account);</p><pre><code>boy.start();girl.start();</code></pre><p>}<br>}</p><p>package com.briup.thread;</p><p>public class Account {<br>private String accountNo;//账户<br>private double balance;<br>public Account(String accountNo,double balance){<br>    this.accountNo=accountNo;<br>    this.balance=balance;<br>}<br>public String getAccountNo(){<br>    return accountNo;<br>}<br>public double getBalance(){<br>    return balance;<br>}<br>//存钱<br>public double deposit(double amt){<br>    if(amt&lt;=0) return 0.0;<br>    synchronized(this){<br>        double temp=balance;<br>        temp+=amt;<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>        balance=temp;<br>        return amt;<br>    }</p><p>​<br>}<br>//取钱<br>public synchronized double withdeaw(double amt){</p><pre><code>if(amt&lt;=0 || amt&gt;balance) return 0.0;double temp=balance;temp-=amt;try {    Thread.sleep(1000);} catch (InterruptedException e) {    // TODO Auto-generated catch block    e.printStackTrace();}balance=temp;return amt;</code></pre><p>}<br>}</p><p>二：写MyQueue类，实现线程安全的队列</p><p>提示：队列中存储Object类型的数据，操作逻辑为先进先出</p><p>public class MyQueue {</p><p>public static ArrayList data=new ArrayList();</p><p>public MyQueue(){</p><p>}</p><p>public void in(Object o){</p><p>​    data.add(o);</p><p>}</p><p>public Object out(Object i){</p><p>​    int size=data.size();</p><p>​    System.out.println(“取:”+i);</p><p>​    if(size&gt;0)</p><p>​        return data.remove(i);</p><p>​    else </p><p>​        return null;</p><p>}</p><p>public int getSize(){</p><p>​    return data.size();</p><p>}</p><p>}</p><p>创建线程类InsertThread用于将数据写入队列中</p><p>创建线程类ReadThread用于从队列中读取数据并输出</p><p>写MyQueueTest类，创建多个线程对MyQueue类进行测试</p><p>public class MyQueueTest {</p><p>​    public static boolean flag = false;</p><p>​    public static void main(String[] args) throws InterruptedException {</p><p>​         MyQueue myQueue = new MyQueue();</p><p>​        InsertThread insum = new InsertThread(“插入”,myQueue);</p><p>​        ReadThread outsum =new ReadThread(“取出”,myQueue);</p><p>​        </p><p>​        insum.start();</p><p>​        // insum.setPriority(10);//优先级，建议性提高抢到线程</p><p>​        outsum.start();</p><p>​        // outsum.join();//和优先级一样都是提高抢到线程频率</p><p>​        // outsum.setPriority(1);</p><p>​    }</p><p>​    </p><p>}</p><p>class Num {</p><p>}</p><p>class InsertThread extends Thread {</p><p>​    private  MyQueue myQueue;;</p><p>​    public InsertThread(String name,MyQueue myQueue){</p><p>​        super(name);</p><p>​        this.myQueue=myQueue;</p><p>​    }</p><p>​    @Override</p><p>​    public void run() {</p><p>​        while(!MyQueueTest.flag){</p><p>​            try {</p><p>​                Thread.sleep(1000);</p><p>​            } catch (InterruptedException e) {</p><p>​                // TODO Auto-generated catch block</p><p>​                e.printStackTrace();</p><p>​            }</p><p>​        }</p><p>​            synchronized (Num.class) {</p><p>​                for (int i = 0; i &lt; 5; i++) {</p><p>​                    System.out.print(“存:” + i + “ “);</p><p>​                    myQueue.in(i);</p><p>​                }</p><p>​                System.out.println();</p><p>​                Num.class.notifyAll();</p><p>​        }</p><p>​    }</p><p>}</p><p>class ReadThread extends Thread {</p><p>​    private  MyQueue myQueue;;</p><p>​    public ReadThread(String name,MyQueue myQueue){</p><p>​        super(name);</p><p>​        this.myQueue=myQueue;</p><p>​    }</p><p>​    @Override</p><p>​    public void run() {</p><p>​            synchronized (Num.class) {</p><p>​                if (myQueue.data.size() == 0) {</p><p>​                    try {</p><p>​                        System.out.println(“空集合,你先存吧”);</p><p>​                        MyQueueTest.flag=true;</p><p>​                        Num.class.wait();</p><p>​                    } catch (InterruptedException e) {</p><p>​                        // TODO Auto-generated catch block</p><p>​                        e.printStackTrace();</p><p>​                    }</p><p>​                    for (int i = 0; i &lt; 5; i++) {</p><p>​                        myQueue.out(i);</p><p>​                        </p><p>​                    }</p><p>​                } </p><p>​        }</p><p>​    }</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十八天笔记</title>
      <link href="/2018/10/29/index28/"/>
      <url>/2018/10/29/index28/</url>
      
        <content type="html"><![CDATA[<p>五：线程的状态<br> a)新建状态：线程对象已经创建，还没有在其上调用start()方法。</p><p> b)就绪状态： 线程已经准备好了，等待CPU的调度，<br>              当线程有资格运行，但调度程序还没有把它选定<br>              为运行线程时线程所处的状态。当start()方法调用时，<br>          线程首先进入就绪状态。在线程运行之后或者从阻塞、<br>          等待或睡眠状态回来后，也返回到就绪状态。</p><p> c)运行状态：线程调度程序从可运行池中选择一个线程作为<br>             当前线程时线程所处的状态。这也是线程进入<br>         运行状态的唯一一种方式。CPU正在执行的线程。</p><p> d)等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。<br>                       实际上这个三状态组合为一种，<br>               其共同点是：线程仍旧是活的，<br>               但是当前没有条件运行。换句话说，<br>               它是可运行的，但是如果某件事件<br>               出现，他可能返回到就绪状态。</p><p> e)死亡状态：当线程的run()方法完成时就认为它死去。<br>          这个线程对象也许是活的，但是，它已经不<br>      是一个单独执行的线程。线程一旦死亡，就<br>      不能复生。 如果在一个死去的线程上调用<br>      start()方法，会抛出java.lang.IllegalThreadStateException异常。</p><p>六：中断线程<br>   模拟龟兔赛跑(乌龟和兔子同时跑，相互没有影响)<br>     每一步跑1-10m的随机数<br>     总共跑100m,第一种方式两个动物都跑到终点。发扬比赛规则。<br>  1)使用标志变量中断线程。就好像开车一样。<br>  2)使用stop().已经过时了,虽然它确实停止了一个正在运行的线程，<br>    然而，这种方法是不安全也是不受提倡的<br>Thread类中的方法：<br>  join():等待线程的执行结束。<br>       在哪个线程中调用就谁等待。<br>       谁调用该方法就等待谁。<br>interrupt():中断阻塞中的线程。<br>            不能中断正在执行的线程。<br>isInterrupted():判断是否被中断<br>static interrupted():清空中断信息</p><p>七：线程的并发访问：多线程同时操作同一个对象。<br>很多ATM—–》每台ATM都会同时在进行工作。就相当于多线程。<br>  卡–&gt;主卡，副卡(同一个账号)</p><p>加同步锁，加在共享对象上。<br>每一个对象都有唯一的一把锁。<br>lock对象锁—-&gt;执行代码——&gt;unlock对象锁<br>多个线程只能是谁抢到了对象锁，谁就可以执行。<br>并发访问的线程加上同步锁之后就称为线程的互斥。</p><p>synchronized(共享区){临界区}<br>共享区：多线程同时操作同一个对象<br>临界区：多线程对共享区进行操作的代码区<br>该对象就是的类就是线程安全的类—效率低。<br>将所有影响的方法都定义成线程安全的方法就变成了线程安全的类。</p><p>synchronized可以放在方法上，就是一个同步方法。</p><p>package com.briup.thread;</p><p>public class NumberThread extends Thread{<br>    static int i=1;<br> @Override<br> public void run(){<br>    //int i=1;<br>    for(;i&lt;=100;i++){<br>        System.out.println(getName()+”:”+i);<br>        try {<br>            sleep(1000);//睡眠 毫秒<br>        } catch (InterruptedException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>    }<br> }<br> public static void main(String[] args){<br>     Thread t1=new NumberThread();//创建线程对象<br>     Thread t2=new NumberThread();<br>     t1.start();//启动线程 不能直接通过对象调用run方法<br>     t2.start();<br> }<br>}</p><p>package com.briup.thread;</p><p>public class NumberRunnable implements Runnable{<br>      int i=1;<br> @Override<br> public void run(){</p><pre><code>for(;i&lt;=100;i++){    //Thread.currentThread().getName()获取当前正在执行的线程名称    System.out.println(            Thread.currentThread().getName()+&quot;:&quot;+i);    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p> }<br> public static void main(String… args){<br>     /<em>Runnable r=new NumberRunnable();<br>     Thread t1=new Thread(r);<br>     Thread t2=new Thread(r);</em>/<br>     //第二种<br>     Runnable r1=new NumberRunnable();<br>     Thread t1=new Thread(r1);<br>     Runnable r2=new NumberRunnable();<br>     Thread t2=new Thread(r2);<br>     t1.start();<br>     t2.start();<br> }<br>}</p><p>package com.briup.thread;</p><p>public class InterruptTest extends Thread{<br> @Override<br> public void run(){<br>    System.out.println(getName()+”will sleep”);<br>    try {<br>        sleep(10*1000);<br>    } catch (InterruptedException e) {<br>        System.out.println(getName()+” interrupted”);<br>    }<br>    System.out.println(getName()+” over…”);</p><p>}<br> public static void main(String… args){<br>     Thread t1=new InterruptTest();<br>     Thread t2=new InterruptTest();<br>     t2.start();<br>     t1.start();<br>     try {<br>        Thread.sleep(1000);//让主线程睡眠，先执行子线程<br>        t1.interrupt();//中断t1线程<br>        System.out.println(t1.isInterrupted());<br>        System.out.println(t2.isInterrupted());<br>        Thread.interrupted();//清空中断操作记录<br>        System.out.println(t1.isInterrupted());<br>        System.out.println(t2.isInterrupted());<br>    } catch (InterruptedException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }//</p><p> }<br>}</p><p>package com.briup.thread;</p><p>public class GuiTuTest extends Thread{<br>    private static boolean flag=false;<br>    public GuiTuTest(String name){<br>        super(name);<br>    }<br>    @Override<br>    public void run(){<br>            int sum=0;//走的长度<br>            while(sum&lt;=100){<br>                if(flag)<br>                    return;<br>                int race=(int)(Math.random()*10+1);<br>                sum+=race;<br>                System.out.println(getName()+” running “+sum);<br>                try {<br>                    sleep(1000);<br>                } catch (InterruptedException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br>            }<br>            flag=true;<br>    }<br>public static void main(String… args){<br>    System.out.println(“比赛开始…”);<br>    Thread rabbit=new GuiTuTest(“兔子”);<br>    Thread wugui=new GuiTuTest(“乌龟”);<br>    rabbit.start();<br>    wugui.start();</p><pre><code>try {    //main线程等待rabbit和wugui线程执行    rabbit.join();    wugui.join();} catch (InterruptedException e) {    // TODO Auto-generated catch block    e.printStackTrace();}System.out.println(&quot;比赛结束...&quot;);System.out.println(&quot;兔子:&quot;+rabbit.isAlive());</code></pre><p>}<br>}</p><p>package com.briup.thread;</p><p>public class AccountTest extends Thread{<br>private Account account;<br>public AccountTest(String name,Account account){<br>    super(name);//起个线程名称<br>    this.account=account;<br>}<br>@Override<br>public void run(){<br>    //double amt=account.withdeaw(1000);<br>    double amt=account.deposit(1000);<br>    System.out.println(getName()+” from “<br>    +account.getAccountNo()+” deposit “<br>            +amt+”,balance=”+account.getBalance());<br>}<br>public static void main(String… args){<br>    //创建一个账户对象<br>    Account account=new Account(“1452361”,1000);<br>    Thread girl=new AccountTest(“girl”,account);<br>    Thread boy=new AccountTest(“boy”,account);<br>    girl.start();<br>    boy.start();<br>}<br>}</p><p>package com.briup.thread;</p><p>public class Account {<br>private String accountNo;//账户<br>private double balance;<br>public Account(String accountNo,double balance){<br>    this.accountNo=accountNo;<br>    this.balance=balance;<br>}<br>public String getAccountNo(){<br>    return accountNo;<br>}<br>public double getBalance(){<br>    return balance;<br>}<br>//存钱<br>public double deposit(double amt){<br>    if(amt&lt;=0) return 0.0;</p><pre><code>synchronized(this){    double temp=balance;    temp+=amt;}try {    Thread.sleep(1000);} catch (InterruptedException e) {    // TODO Auto-generated catch block    e.printStackTrace();}balance=temp;return amt;    </code></pre><p>}<br>//取钱<br>public double withdeaw(double amt){<br>    if(amt&lt;=0 || amt&gt;balance) return 0.0;<br>    double temp=balance;<br>    temp-=amt;<br>    try {<br>        Thread.sleep(1000);<br>    } catch (InterruptedException e) {<br>        // TODO Auto-generated catch block<br>        e.printStackTrace();<br>    }<br>    balance=temp;<br>    return amt;<br>}<br>}</p><p>​    1．线程由以下哪些部分组成？（选三项）ABC</p><p>​    A．虚拟的CPU</p><p>​    B．CPu执行的代码</p><p>​    C．支持代码工作的数据</p><p>​    D．进程</p><p>​    </p><p>​    2．创建线程的时候必须实现哪项接口?A</p><p>​    A．  Runnable</p><p>​    B．  Thread</p><p>​    C．  Run</p><p>​    D．  Start</p><p>​    </p><p>​    3．启动一个线程的方法是哪项？C</p><p>​    A． join()</p><p>​    B.  run f)</p><p>​    C．start()</p><p>​    D．sleep()</p><p>​    </p><p>​    4．当一个处于阻塞状态的线程解除阻塞后，它将回到哪个状态？D</p><p>​    A.运行中状态</p><p>​    B．结束状态</p><p>​    C．新建状态</p><p>​    D．可运行状态</p><p>​    </p><p>​     5．可以通过继承哪个类来创建线程？A</p><p>​    A. Thread</p><p>​    B．Runnable</p><p>​    C．tart</p><p>​    D．run </p><p>一：实现龟兔赛跑</p><p>提示：可以采用Math.random()取得0~1之间的随机数模拟比赛进程，</p><p>如总距离为100米，在随机数0~0.3之间代表兔子跑，每次跑2米，</p><p>在0.3~1之间代表乌龟跑，每次跑1米，先跑完100米者为胜利者</p><p>Race类：产生RabbitAndTurtle的两个实例，分别代表兔子和乌龟</p><p>RabbitAndTurtle类：继承Thread类，实现赛跑的逻辑</p><p>public class GuiTuPlay extends Thread{</p><p>private String name;</p><p>private double m;</p><p>private static int a;//乌龟</p><p>private static int b;//兔子</p><p>private static boolean flag;</p><p>public GuiTuPlay(String name) {</p><p>​    this.name = name;</p><p>​    flag=true;</p><p>}</p><p>@Override</p><p>​    public void run() {</p><p>​    while (flag==true) {</p><p>​        m=Math.random();</p><p>​        if (m&gt;=0.0&amp;&amp;m&lt;=0.3) {</p><p>​            b+=2;</p><p>​            System.out.println(“兔子走了”+b);</p><p>​            if (b==100) {</p><p>​                System.out.println(“兔子赢了”);</p><p>​                flag=false;</p><p>​            }</p><p>​        }else if (m&gt;0.3&amp;&amp;m&lt;=1.0) {</p><p>​            a+=1;</p><p>​            System.out.println(“乌龟走了”+a);</p><p>​            if (a==100) {</p><p>​                flag=false;</p><p>​                System.out.println(“乌龟赢了”);</p><p>​                </p><p>​            }</p><p>​        }</p><p>​    }</p><p>​    </p><p>​    }</p><p>public static void main(String[] args) throws InterruptedException {</p><p>​    Thread tuzi=new GuiTuPlay(“兔子”);</p><p>​    Thread wugui=new GuiTuPlay(“乌龟”);</p><p>​    tuzi.start();</p><p>​    tuzi.join();</p><p>​    wugui.start();</p><p>}</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十七天笔记</title>
      <link href="/2018/10/29/index27%20/"/>
      <url>/2018/10/29/index27%20/</url>
      
        <content type="html"><![CDATA[<p>线程<br>一：线程<br>线程是程序执行的最小单位。<br>进程是系统进程资源分配和系统调度的最小单位。是动态的。<br>程序是静态的。<br>线程和进程的目的：多任务—&gt;效率高<br>同时性<br> 在同一个时间点只能执行一个进程或线程<br> 在同一个时间段可以执行多个进程或线程<br>进程数据不共享，每个进程都有自己的独立内存空间。<br>线程数据共享<br>一个程序可以启动多个进程<br>一个进程可以启动多个线程<br>线程必须通过进程启动，不能独立存在的。</p><p>.class运行在JVM上，.class就是一个一个的线程。<br>JVM就是一个进程。</p><p>二：线程的三要素<br>CPU： 运行线程，所有线程共享CPU。<br>      只有线程抢占CPU成功才会执行。<br>代码：线程运行过程中执行的代码块。<br>      线程启动之后会执行public void run()的方法。<br>数据：变量<br>      1)局部变量是多线程不共享<br>      2)extends  Thread之后静态变量是共享<br>                          实例变量不共享<br>      3)implements Runnable之后静态变量是共享的<br>                          实例变量也共享</p><p>三：使用线程<br>第一种方式：class MyThread extends Thread{<br>        public void run(){<br>        }<br>    }<br>创建线程：Thread t1=new MyThread();<br>启动线程： t1.start();<br>使用方法：getName(),sleep();</p><p>第二种方式：class MyThread implements Runnable{<br>        public void run(){<br>        }<br>      }<br>创建线程：MyThread m=new MyThread();<br>    Thread t1 = new Thread(t1);<br>启动线程： t1.start();<br>使用方法：Thread.currentThread().getName()<br>         Thread.sleep();<br>Thread类中的方法：<br>getName():获取当前线程的名字<br>static sleep(long):强制当前正在执行的线程休眠(暂停执行),以“减慢线程”。<br>static currentThread():获取当前正在执行的线程。</p><p>注意：***<br>线程的运行时抢占式，所以线程的执行结果是不可预知的。</p><p>四：为什么要有两种方式<br>   java单继承<br>class Test extends Student implements Runnable{<br>} </p><p>五：线程的状态<br> a)新建状态：线程对象已经创建，还没有在其上调用start()方法。</p><p> b)就绪状态： 线程已经准备好了，等待CPU的调度，<br>              当线程有资格运行，但调度程序还没有把它选定<br>              为运行线程时线程所处的状态。当start()方法调用时，<br>          线程首先进入就绪状态。在线程运行之后或者从阻塞、<br>          等待或睡眠状态回来后，也返回到就绪状态。</p><p> c)运行状态：线程调度程序从可运行池中选择一个线程作为<br>             当前线程时线程所处的状态。这也是线程进入<br>         运行状态的唯一一种方式。CPU正在执行的线程。</p><p> d)等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。<br>                       实际上这个三状态组合为一种，<br>               其共同点是：线程仍旧是活的，<br>               但是当前没有条件运行。换句话说，<br>               它是可运行的，但是如果某件事件<br>               出现，他可能返回到就绪状态。</p><p> e)死亡状态：当线程的run()方法完成时就认为它死去。<br>          这个线程对象也许是活的，但是，它已经不<br>      是一个单独执行的线程。线程一旦死亡，就<br>      不能复生。 如果在一个死去的线程上调用<br>      start()方法，会抛出java.lang.IllegalThreadStateException异常。</p><p>package com.briup.thread;</p><p>public class NumberRunnable implements Runnable{<br>      int i=1;<br> @Override<br> public void run(){</p><pre><code>for(;i&lt;=100;i++){    //Thread.currentThread().getName()获取当前正在执行的线程名称    System.out.println(            Thread.currentThread().getName()+&quot;:&quot;+i);    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><p> }<br> public static void main(String… args){<br>     /<em>Runnable r=new NumberRunnable();<br>     Thread t1=new Thread(r);<br>     Thread t2=new Thread(r);</em>/<br>     //第二种<br>     Runnable r1=new NumberRunnable();<br>     Thread t1=new Thread(r1);<br>     Runnable r2=new NumberRunnable();<br>     Thread t2=new Thread(r2);<br>     t1.start();<br>     t2.start();<br> }<br>}</p><p>package com.briup.thread;</p><p>public class NumberThread extends Thread{<br>    static int i=1;<br> @Override<br> public void run(){<br>    //int i=1;<br>    for(;i&lt;=100;i++){<br>        System.out.println(getName()+”:”+i);<br>        try {<br>            sleep(1000);//睡眠 毫秒<br>        } catch (InterruptedException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>    }<br> }<br> public static void main(String[] args){<br>     Thread t1=new NumberThread();//创建线程对象<br>     Thread t2=new NumberThread();<br>     t1.start();//启动线程 不能直接通过对象调用run方法<br>     t2.start();<br> }<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十六天笔记</title>
      <link href="/2018/10/26/index26/"/>
      <url>/2018/10/26/index26/</url>
      
        <content type="html"><![CDATA[<p>异常<br>一：异常<br> 异常是改变程序正常执行流程的意外情况。<br> 异常的条件都是应用级别的异常。系统级别<br> 的异常程序员无法处理。<br>异常：是一个对象,Exception<br>class Exception{<br>    发生问题的主体(Object)<br>    对问题本身的有效描述(String)<br>}</p><p>二：异常的结构<br>try{<br>   //可能出现异常的代码<br>    …<br>    int k= 10/0;<br>    …<br>    …<br>}catch(ExceptionType1 e){<br>….//针对ExceptionType1类型的异常处理<br>}catch(ExceptionType2 e){<br>…//针对ExceptionType2类型的异常处理<br>}<br>…..<br>}finally{<br>     //不管是否碰到异常，都要执行该代码，<br>     //收尾工作(关闭数据库，释放资源….)<br>}<br>…<br>catch中异常类型小异常放在上面<br>             大异常放在下面</p><p>异常：是对象，java.lang.Exception<br>抛出异常：在try中业务逻辑代码出现异常情况，<br>          系统会自动产生异常对象，将该异<br>      常对象抛出给java运行时环境。<br>          这个过程称之为抛出异常。<br>捕获异常：java运行时环境接受到异常对象，<br>         会根据异常对象寻找相应的catch块。<br>     这个过程称之为捕获异常。<br>         如果找不到相应的catch块，<br>     将异常对象交给java运行<br>     时环境，JAVA运行时环境会直接中<br>     断应用程序，并且会打印异常栈的信息。<br>    异常栈的信息会知道在哪行代码出现了什么样的异常。<br>处理异常：异常处理的代码</p><p>三：异常的原理<br>当发生异常的时候，系统将自动抛出异常对象<br>寻找异常处理代码，如果没有找到，将上抛到<br>方法的调用处，依次类推，直到抛给虚拟机程序终止。<br>异常栈可以找到异常真正发生的原因。<br>main(){<br>      a();<br>}<br>a(){<br>      b(); ///处理异常<br>}<br>b(){<br>    c();<br>}<br>c(){<br>   ///Exception<br>}<br>c()—-&gt;b()—-&gt;a()—-&gt;main()—&gt;JVM<br>在c()中发生异常，且所有方法都没有异常处理，所有方法的栈区是否被锁定？(会)<br>有多少方法牵扯进来了，就会有多少方法的栈区被锁定了<br>方法的嵌套调用是非常危险的，栈区被锁定，会等待着内存的释放<br>方法的递归调用也是很非常危险的，你不一定知道调用的次数<br>建议：不要有过分复杂的方法嵌套调用，<br>      不要使用调用次数可能过多的递归算法</p><p>getMessage():返回该异常的详细描述字符串<br>printStackTrack():将该异常的跟踪栈信息输出到标准错误输出</p><p>四：异常分类<br>Exception<br>   uncheck异常(RuntimeException异常)：<br>          包含RuntimeException及子类<br>              在编译期的不需要捕获的异常<br>              不可修复的异常，如连接数据库发生异常<br>          不需要继续向下执行。<br>   check异常：在编译期的必须捕获的异常<br>              可以修复的异常，如输入错误金额，用户名输入错误。处理之后可以继续向下执行。<br>              Exception的子类除了RuntimeException。<br>          如Class.forName(“”)<br>五：异常处理的方式<br>  1)try—catch:自己处理异常<br>  2)throws:自己不处理异常，抛出调用者处理异常。<br> 原则：如果自己能够处理的异常，<br>       就不要抛出调用者处理异常。</p><p>六：自定义异常<br>  1)在项目中建议不抛出系统异常，<br>    因为异常的类名通常应该包含该异常的有用信息。<br>    应该选择合适的异常类，从而可以明确的描述该异常情况，<br>    就应该选择自定义异常。<br>  2)可以把uncheck异常转化为check异常<br>    可以把check异常转化为uncheck异常<br>自定义check异常:<br>class MyException extends Exception<br>自定义uncheck异常:<br>class MyException extends RuntimeException</p><p>throws 异常类型:方法申明的时候抛出异常<br>throw 异常对象:方法体中抛出异常</p><p>七：断言jdk1.4之后<br>开发过程中，在需要的时候提供判断功能.<br>用if判断效率很低，用断言可以提高效率<br>在AssertTest.java加上断言assert b==0:”my assert”;<br>默认情况下，断言是关闭的，所以在运行的时候打开断言输入vm参数-ea<br>断言是在1.4版本之后增加的，如果对1.4版本之前的系统进行重写。<br>需要确认assert是否被用作标识符</p><p>八：异常和系统效率<br>异常处理会影响系统效率，建议只在适当的时候做必要处理</p><p>1.返回值是多少？<br>public int test(){<br>    try{<br>        //int k = 10/0;<br>        int k = 10/1;<br>        return 1;<br>    }catch(Exception e){<br>        return -1;<br>    }finally{<br>        return 0;<br>    }<br>}<br>注意：返回值不能finally块。<br>2.下面的语句哪些是对的？<br>a.try{}<br>b.try{}catch(){}<br>c.try{}finally{}<br>d.try{}catch(){}finally{}<br>e.catch(){}<br>f.finally{}</p><p>package com.briup.ch26;<br>public class MyException extends Exception<br>{<br>    public MyException(){<br>    super();<br>    }<br>    public MyException(String message){<br>    super(message);<br>    }<br>    public MyException(String message,Throwable cause){<br>     super(message,cause);<br>    }<br>    public MyException(Throwable cause){<br>     super(cause);<br>     }<br>}</p><p>package com.briup.ch26;<br>public class FinallyTest<br>{<br>  public static void main(String… args){<br>              int s=test();<br>              System.out.println(s);<br>  }<br>  public static int test(){<br>     /<em> try{<br>       int a=10/0;<br>       return 1;<br>      }catch(Exception e){<br>        return -1;<br>      }finally{<br>      //return 0;<br>           System.out.println(“fff”);<br>      }</em>/<br>     /<em>finally{<br>      int a=10/2;<br>     return a;<br>      }</em>/</p><p>  }<br>}</p><p>package com.briup.ch26;<br>public class Test<br>{<br>    public static void main(String… args) {<br>    Test t=new Test();<br>    try{<br>        t.ss();<br>    }catch(MyException e){<br>       System.out.println(e.getMessage());<br>    }</p><p>​<br>​    </p><pre><code>}public void ss() throws MyException{      try{    int a=10/0;    }catch(ArithmeticException e){      throw new MyException(&quot;除数不能为0&quot;);    }}</code></pre><p>}</p><p>一：</p><p>1)写OwnException类，要求继承Exception类</p><p>public class OwnException extends Exception {</p><p>​    /**</p><p>​     * </p><p>​     */</p><p>​    private static final long serialVersionUID = 1L;</p><p>​    public OwnException() {</p><p>​        super();</p><p>​        // TODO Auto-generated constructor stub</p><p>​    }</p><p>​    public OwnException(String message, Throwable cause,</p><p>​            boolean enableSuppression, boolean writableStackTrace) {</p><p>​        super(message, cause, enableSuppression, writableStackTrace);</p><p>​        // TODO Auto-generated constructor stub</p><p>​    }</p><p>​    public OwnException(String message, Throwable cause) {</p><p>​        super(message, cause);</p><p>​        // TODO Auto-generated constructor stub</p><p>​    }</p><p>​    public OwnException(String message) {</p><p>​        super(message);</p><p>​        // TODO Auto-generated constructor stub</p><p>​    }</p><p>​    public OwnException(Throwable cause) {</p><p>​        super(cause);</p><p>​        // TODO Auto-generated constructor stub</p><p>​    }</p><p>​    </p><p>}</p><p>2)写OwnExceptionSource类，要求包含方法a()，a()抛出OwnException</p><p>public class OwnExceptionSource {</p><p>public void a() throws OwnException{</p><p>​    throw new OwnException(“你的a方法出错了”);</p><p>}</p><p>}</p><p>3)写OwnExceptionHandler类，要求包含main()，在main()中调用OwnExceptionSource类的a()，并处理相关异常</p><p>public class OwnExceptionHandler {</p><p>public static void main(String[] args) throws OwnException {</p><p>​    OwnExceptionSource o=new OwnExceptionSource();</p><p>​    o.a();</p><p>}</p><p>}</p><p>二：</p><p>写DivisionByZero类，包含</p><p>1)division()：要求执行10/0操作，并使用异常处理机制处理产生的异常</p><p>2)main()：调用division()</p><p>public class DivisionByZero {</p><p>public void division(){</p><p>​    try {</p><p>​        int a=10/0;</p><p>​    } catch (Exception e) {</p><p>​        System.out.println(“异常了”);</p><p>​    }</p><p>​    </p><p>}</p><p>public static void main(String[] args) {</p><p>​    DivisionByZero d=new DivisionByZero();</p><p>​    d.division();</p><p>}</p><p>}</p><p>3)修改division()：执行10/0不变，但不在方法中处理产生的异常，改将异常抛出</p><p>public class DivisionByZero {</p><p>public void division(){</p><p>​    </p><p>​        int a=10/0;</p><p>​    </p><p>}</p><p>public static void main(String[] args) {</p><p>​    DivisionByZero d=new DivisionByZero();</p><p>​    d.division();</p><p>}</p><p>}</p><p>4)修改main()：调用division()并处理其抛出的异常</p><p>public class DivisionByZero {</p><p>public void division(){</p><p>​    try {</p><p>​        int a=10/0;</p><p>​    } catch (Exception e) {</p><p>​        e.printStackTrace();</p><p>​    }</p><p>​    </p><p>}</p><p>public static void main(String[] args) {</p><p>​    DivisionByZero d=new DivisionByZero();</p><p>​    d.division();</p><p>}</p><p>}</p><p>三：</p><p>修改TestException.java，要求如下：</p><p>在命令行输入参数不能满足输出要求时,比如说个数，比如说数字类型等，会抛出相应异常，使用异常处理机制处理抛出的异常。</p><p>public class DivisionByZero {</p><p>​    public static void main(String[] args) </p><p>​    {</p><p>​         /* Scanner s = new Scanner(System.in); </p><p>​          System.out.println(“请输入字符串：”); </p><p>​          String line = s.nextLine();</p><p>​          args=new String[3];</p><p>​          args[0]=line;</p><p>​          //数组越界</p><p>​          //Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 1</p><p>​          System.out.println(args[0]);</p><p>​        System.out.println(args[1]);</p><p>​        System.out.println(args[2]);*/</p><p>​        /*int a=0;</p><p>​         Scanner s = new Scanner(System.in); </p><p>​         args=new String[3];</p><p>​        while (a&lt;=2) { </p><p>​             System.out.println(“请输入字符串：”); </p><p>​           String line = s.nextLine(); </p><p>​           args[a]=line;</p><p>​           a++;</p><p>​             } </p><p>​         System.out.println(args[0]);</p><p>​        System.out.println(args[1]);</p><p>​        System.out.println(args[2]);*/</p><p>​        int a=0;</p><p>​         Scanner s = new Scanner(System.in); </p><p>​        args=new String[3];</p><p>​        while (a&lt;=2) { </p><p>​             System.out.println(“请输入字符串：”); </p><p>​          String line = s.nextLine(); </p><p>​          args[a]=line;</p><p>​             a++;</p><p>​            } </p><p>​        System.out.println(Integer.parseInt(args[0]));</p><p>​        //数字类型转换异常</p><p>​        //Exception in thread “main” java.lang.NumberFormatException: For input string: “ss”</p><p>​        System.out.println(args[1]);</p><p>​        System.out.println(args[2]);</p><p>​    }</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十五天笔记</title>
      <link href="/2018/10/26/index25/"/>
      <url>/2018/10/26/index25/</url>
      
        <content type="html"><![CDATA[<p>二. 反射 ：自描述或者自定义<br>  平时我们照镜子的时候，在镜子后面会有自己的影子，<br>其实java中的反射也是类似的，一个类或者对象通过反<br>射可以获得自身的对象，该对象是一个java.lang.Class<br>的对象(就像一个镜像文件)。一个对象或者类获得自身<br>的Class对象的过程称为反射。<br>java.lang.Class：是类镜像，镜像对象<br>Class类镜像的作用可以获取该类和该对象的所有属性，方法<br>和构造器，以及属性方法和构造器修饰符，修改私有属性的值。<br>调用方法和调用构造器等等。<br>Class—-实例化—–&gt;class—–实例化—–&gt;对象<br>对象——抽象化—–&gt;class——抽象化—–&gt;Class<br>抽象：具有相同属性和行为抽象出来<br>public class Class{<br>    Field[] fileds;<br>        Method[] methods;<br>        Constructor[]  cons;<br>}<br>反射API：<br>    java.lang.Class<br>    java.lang.reflect.Field<br>    java.lang.reflect.Method<br>    java.lang.reflect.Array<br>    java.lang.reflect.Constructor<br>class Person{}<br>Person创建100个对象，创建多少个Person的Class类型对象？<br>class Person{}<br>   1个，类加载的时候创建Person的Class类型对象。</p><p>通过反射操作的步骤：<br>1）获取类镜像(Class对象),三种方式<br>   a)Class.forName(String className)<br>   b)数据类型.class<br>   c)对象.getClass()<br>2)通过类镜像实例化对象(不通过new方式创建对象)<br>   Object obj=类镜像对象.newInstance()。<br>      默认会调用class类的无参构造器。<br>3)通过实例化对象操作属性，方法，构造器<br>   a)获取所有的属性(属性名和修饰符和数据类型)。<br>   b)获取所有的方法(方法名和修饰符和返回值和参数列表)<br>   c)获取所有构造器(名字和修饰符和参数列表)<br>   d)修饰属性的值<br>   e)调用方法:invoke()<br>   f)调用指定构造器创建的对象</p><p>什么时候反射：<br>  1)在运行的时候才知道类名<br>  2)在运行的时候才知道属性名<br>  3)在运行的时候才知道方法名<br>反射：<br>    1) 确定一个对象的class<br>    2) 可以获得一个类的修饰符、字段、方法、构造器和父类。<br>    3) 获得接口声明的常量和方法。<br>    4) 创建Class的实例，直到运行时才获得。<br>    5) 运行前即使字段名字不知道，可以到程序运行时获得和修改这些字段的值。<br>    6) 运行前即使对象的方法名不知道，可以到程序运行时触发调用该方法。<br>    7) 运行前创建了一个大小和元素都未知的新数组，<br>       可以到运行时修改数组的元素。</p><p>反射的用途：<br>  1)修改私有属性的值<br>  2)调用任何对象的任何方法<br>  3)不通过new方式创建对象</p><p>反射用途的注意：<br>  1)反射可以让我们利用这个Class对象来获取和<br>修改私有的变量和方法，不通过共有的方法去<br>获得（原来我们例子都是通过一个public的方<br>法来设置和获取私有的变量），可以破坏数据<br>的封装性。<br>  2)反射机制通过在运行时探查字段和方法，<br>从而可以帮助写出通用性很好的程序，<br>这项能力对系统编程来说特别有用，<br>但它并不适合于应用编程。而且，反射是<br>脆弱的——编译不能帮助你发现编译错误，<br>任何错误在运行时被发现并且都会导致异常。<br>导致代码不安全。<br>异常<br>一：异常<br> 异常是改变程序正常执行流程的意外情况。<br> 异常的条件都是应用级别的异常。系统级别<br> 的异常程序员无法处理。<br>异常：是一个对象,Exception<br>class Exception{<br>    发生问题的主体(Object)<br>    对问题本身的有效描述(String)<br>}</p><p>二：异常的结构<br>try{<br>   //可能出现异常的代码<br>    …<br>    int k= 10/0;<br>    …<br>    …<br>}catch(ExceptionType1 e){<br>….//针对ExceptionType1类型的异常处理<br>}catch(ExceptionType2 e){<br>…//针对ExceptionType2类型的异常处理<br>}<br>…..<br>}finally{<br>     //不管是否碰到异常，都要执行该代码，<br>     //收尾工作(关闭数据库，释放资源….)<br>}<br>…<br>catch中异常类型小异常放在上面<br>             大异常放在下面</p><p>异常：是对象，java.lang.Exception<br>抛出异常：在try中业务逻辑代码出现异常情况，<br>          系统会自动产生异常对象，将该异<br>      常对象抛出给java运行时环境。<br>          这个过程称之为抛出异常。<br>捕获异常：java运行时环境接受到异常对象，<br>         会根据异常对象寻找相应的catch块。<br>     这个过程称之为捕获异常。<br>         如果找不到相应的catch块，<br>     将异常对象交给java运行<br>     时环境，JAVA运行时环境会直接中<br>     断应用程序，并且会打印异常栈的信息。<br>    异常栈的信息会知道在哪行代码出现了什么样的异常。<br>处理异常：异常处理的代码</p><p>package com.briup.ch25;<br>public class Exception1<br>{<br>    //描述异常的详细信息<br>    public String message;<br>    //异常发生的原因<br>    public Throwable cause;<br>}</p><p>package com.briup.ch25;<br>public class ExceptionTest<br>{<br>    public static void main(String… args){<br>    System.out.println(“start…”);<br>    try{//放的是正常运行方式<br>     String str=null;<br>    char c=str.charAt(0);<br>    System.out.println(c);<br>    int a=10/0;<br>    System.out.println(“a=”+a);</p><pre><code>}catch(NullPointerException ex){ System.out.println(ex.getMessage());}catch(ArithmeticException e){ System.out.println(&quot;除数为0&quot;); /*try{ }catch(NullPointerException ex){  System.out.println(&quot;不能为空&quot;); }*/}System.out.println(&quot;end...&quot;);}</code></pre><p>}</p><p>package com.briup.ch25;<br>public class ExceptionTest<br>{<br>    public static void main(String… args){<br>    System.out.println(“start…”);<br>    try{//放的是正常运行方式<br>     String str=null;<br>    char c=str.charAt(0);<br>    System.out.println(c);<br>    int a=10/0;<br>    System.out.println(“a=”+a);</p><pre><code>}catch(NullPointerException ex){ System.out.println(ex.getMessage());}catch(ArithmeticException e){ System.out.println(&quot;除数为0&quot;); /*try{ }catch(NullPointerException ex){  System.out.println(&quot;不能为空&quot;); }*/}System.out.println(&quot;end...&quot;);}</code></pre><p>}</p><p>package com.briup.ch24;<br>import java.util.<em>;<br>import java.io.</em>;<br>public class PropertiesTest<br>{<br>    public static void main(String… args) throws Exception{<br>      //查看JVM配置信息<br>      //获取Properties<br>      //Properties p=System.getProperties();<br>      // p.list(System.out);//在标准输出上输出配置信息<br>      //String p1=System.getProperty(“java.home”);<br>     // System.out.println(p1);<br>      Properties pro=new Properties();<br>      //加载文件<br>        pro.load(new FileInputStream(new File(“com/briup/ch24/info.properties”)));<br>         //根据key值取value值<br>         String n=pro.getProperty(“name”);<br>         String a=pro.getProperty(“age”);<br>         String g=pro.getProperty(“gender”);<br>         System.out.println(“n:”+n+”;a:”+a+”;g:”+g);</p><pre><code>}</code></pre><p>}</p><p>package com.briup.ch24;<br>import java.util.*;<br>interface MyList<e><br>{<br>    public void add(E e);<br>    public E remove(int index);<br>    public void set(int index,E e);<br>}<br>public class ListTest<e> implements MyList<e><br>{<br>    private List<e> list;<br>    public ListTest(){<br>    list=new ArrayList<e>();<br>    }<br>    public void add(E e){<br>    list.add(e);<br>    }<br>    public E remove(int index){<br>      return list.remove(index);<br>    }<br>    public void set(int index,E e){<br>    list.set(index,e);<br>    }<br>    public static void main(String… args){</e></e></e></e></e></p><pre><code>MyList&lt;Integer&gt; list=new ListTest&lt;Integer&gt;();list.add(10);}</code></pre><p>}</p><p>package com.briup.ch24;<br>public class GenericsMap&lt;K,V&gt;<br>{<br>    private K key;<br>    private V value;<br>    public GenericsMap(K key,V value){<br>     this.key=key;<br>     this.value=value;<br>    }<br>    public K getKey(){<br>    return key;<br>    }<br>    public V getValue(){<br>     return value;<br>    }<br>    public static void main(String… args){<br>     GenericsMap&lt;Integer,String&gt; gm=new GenericsMap&lt;Integer,String&gt;(10,”aa”);<br>      GenericsMap&lt;String,String&gt; gm1=new GenericsMap&lt;Integer,String&gt;(“bb”,”aa”);<br>    }<br>}</p><p>package com.briup.ch24;<br>public class GenericsList<e><br>{<br>    private E e;<br>    public void setE(E e){<br>    this.e=e;<br>    }<br>    public E getE(){<br>      return e;<br>    }<br>    public static void main(String… args){<br>    GenericsList<string> gl=new GenericsList<string>();<br>       gl.setE(“aa”);<br>       System.out.println(gl.getE());<br>       //gl.setE(true);//error<br>GenericsList<integer> gl1=new GenericsList<integer>();<br> gl1.setE(10);<br> System.out.println(gl1.getE());<br> //gl1.setE(“dd”);<br>    }<br>}</integer></integer></string></string></e></p><p>package com.briup.ch24;<br>public class Student<br>{<br>    private String name;<br>    private int age;<br>    public Student(){</p><pre><code>}public Student(String name,int age){ this.name=name; this.age=age;}public void setName(String name){ this.name=name;}public String getName(){ return name;}public void setAge(int age){ this.age=age;}public int getAge(){ return age;}</code></pre><p>  public static void test(){<br>   System.out.println(“hello test”);<br>  }<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十三天笔记</title>
      <link href="/2018/10/22/index23/"/>
      <url>/2018/10/22/index23/</url>
      
        <content type="html"><![CDATA[<p>Map保存键值对的数据。key是唯一的。<br>如保存是否打开音效，是否打开振动，当前分数，历史最高分，关数。。。</p><p>一：Map类中的方法：HashMap,Hashtable<br>put(Object key,Object value):添加数据到map集合中<br>Set keySet():将map中所有的key取出来放在set集合中<br>Object get(Object key):从map集合中获取数据。<br>Set entrySet():将map中的key和对应的value重新创建成新的对象(Map.Entry)放在set集合中。<br>      Map.Entry:getKey()<br>      Map.Entry:getValue()<br>Set values():将map中所有的value取出来放在collection集合中<br>interface Map{<br>    static interface Entry{</p><pre><code>}</code></pre><p>}<br>collections工具类<br>Arrays给数组提供的工具类<br>二:String,StringBuffer,StringBuilder<br>String:不可变长的字符串<br>StringBuffer:可变长字符串,线程安全<br>StringBuilder:可变长字符串,线程不安全</p><p>String s=”hello”+”world”;</p><p>三:泛型 Generics，很重要的新特性—参数化类型<br>1：why?jdk1.5前后没有泛型和有泛型分别解决下面的问题<br>    1.集合中使用:<br>      jdk1.5之前：1)添加对象都为Object，<br>                    不会进行数据类型的检查。<br>                  2)操作时需要对其进行强制类型转换。<br>           很容易引发ClassCastException异常<br>      jdk1.5之后：使用泛型<br>    a)检查数据类型,将错误尽量控制到编译器<br>    使用泛型的主要是用于集合在add添加数据时，编译器对数据类型的检测。如果不满足泛型中定义的数据类型就添加不成功。<br>    b)另外在操作集合中的数据时不需要进行强制类型转换。<br>      取数据的类型是放进去的类型，减少发生 ClassCastException异常。</p><p>2：泛型实现的机制：类型擦除<br>ArrayList<integer> ArrayList<string> —&gt;ArrayList<br>泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，编译器编译带来类型说明的集合时会去除掉”类型”信息，使程序运行效果不受影响，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样，由于编译生成的字节码会去掉泛型的类型信息，只要跳过编译器，就可以往某个泛型集合中加入其他类型的数据，例如：用反射得到集合，再调用add方法即可。</string></integer></p><p>3：what?  List<e><br> 弱类型:List list，放任意类型<br> 强类型:List<string> list，放指定类型<br>在Java SE 1.5之后,推出泛型。也称之为参数化类型.也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java语言引入泛型的好处是安全简单。<br>  在Java SE 1.5之前，没有泛型的情况的下<br>  通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实<br>际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类<br>型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率<br>   泛型把指定类型的工作推迟到客户端代码声明并实例化类或方法的时候进行。在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。一些强类型编程语言支援泛型，<br>其主要目的是加强类型安全及减少类转换的次数。</string></e></p><p>当集合没有使用泛型的时候，集合中可以添加任何类型的数据。<br>当集合使用泛型的时候，集合中只能添加该泛型及泛型的子类。<br>   List<string>  list = new ArrayList<string>();<br>          list.add(“hello”);<br>      list.add(1);   //error</string></string></p><p>4：术语：ArrayList<e>类定义和ArrayList<integer>类引用中的术语：<br>1)整个称ArrayList<e>为泛型类<br>2)E称为类型变量或类型参数,满足标识符命名规则,一般写大写字母。E,K,V,T</e></integer></e></p><p>3)整个ArrayList<integer>称参数化类型<br>4)Integer称为类型参数的实例或实际类型参数<br>5)&lt;&gt;念typeof<br>6)ArrayList称原始类型</integer></p><p>5：参数化类型与原始类型的兼容性<br> a）参数化类型可以引用一个原始类型：编译器警告<br>List<string> list = new ArrayList(); 这个时候只能添加String类型<br> b）原始类型可以引用一个参数化类型：编译器警告(新的程序可不可以兼容旧的程序)<br>List list = new ArrayList<integer>(); 这个时候可以添加任何对象<br> c）jdk1.7的菱形语法(钻石语法),代码更加简单。<br>List<integer> list = new ArrayList&lt;&gt;();<br> d)参数化类型不考虑类型参数的继承问题(泛型是不存在子父类的)<br>泛型中子父类不能指向的<br>List<object> list = new ArrayList<integer>();  //error<br>泛型中不同类型也是不能指向的<br>List<string> list = new ArrayList<integer>(); //error<br>泛型中不能使用基本数据类型，只能使用引用类型<br>List<int> list = new ArrayList<int>();  //error<br>e)在创建数组实例时，数组的元素不能使用参数化的类型<br>    List<integer>[] listList = new List<integer>[10]; ///error<br>    但是可以使用这样的格式T[].<br>自定义泛型类，泛型方法，泛型接口<br>    1）自定义泛型类,泛型参数必须满足命名规则，但是一般建议大写字母E,T,K,V<br>        a)带有一个泛型参数的泛型：GenericsList.java<br>    eg:  public class 类名&lt;泛型参数列表&gt;{<br>              //类体<br>    }</integer></integer></int></int></integer></string></integer></object></integer></integer></string></p><pre><code>    b)带有多个泛型参数的泛型：GenericsMap.java    eg:  public class 类名&lt;泛型参数列表&gt;{          //类体    }  c)属性为数组或者集合的泛型类  d)泛型类继承泛型类2）自定义泛型接口    public interface 接口名&lt;泛型参数列表&gt;{          //类体}3）自定义泛型方法：   a)泛型方法在泛型类中，它的定义和普通方法是一样的。     public void print(T t){    System.out.println(t);     }   b)泛型方法在普通类中,该方法需要在返回值类型前加上泛型&lt;泛型参数&gt;     eg:     public &lt;T&gt;void print(T t){    System.out.println(&quot;hello&quot;);}</code></pre><p>package com.briup.ch23;<br>public class Student implements Comparable<br>{<br>    private String name;<br>    private int age;<br>    public Student(){<br>    }<br>    public Student(String name,int age){<br>    this.name=name;<br>    this.age=age;<br>    }<br>    public void setName(String name){<br>    this.name=name;<br>    }<br>    public String getName(){<br>     return name;<br>    }<br>    public void setAge(int age){<br>      this.age=age;<br>    }<br>    public int getAge(){<br>     return age;<br>    }<br>    @Override<br>    public boolean equals(Object obj){<br>     if(obj==null)<br>         return false;<br>     if(obj==this)<br>         return true;<br>     if(!obj.getClass().equals(this.getClass()))<br>         return false;<br>     if(obj instanceof Student){<br>       Student stu=(Student)obj;<br>       if(stu.getAge()==this.getAge()&amp;&amp;<br>           stu.getName().equals(this.getName()))<br>           return true;</p><pre><code> } return false;}@Overridepublic int hashCode(){  //return 1;//这种虽然能够让equals方法生效，但是这种方式相当于之后存的对象就需要和之前已存的对象都要进行比较，效率会很低  return name.hashCode()+age;}//自定义排序规则</code></pre><p>  @Override<br>   public int compareTo(Object obj){<br>    if(obj instanceof Student){<br>      Student stu=(Student)obj;<br>       if(stu.getAge()==this.getAge())<br>           return this.getName().compareTo(stu.getName());<br>        return this.getAge()-stu.getAge();<br>    }<br>    return 0;<br>   }<br>    @Override<br>    public String toString(){<br>    return “name=”+name+”,age=”+age;<br>    }<br>}</p><p>package com.briup.ch23;<br>import java.util.<em>;<br>public class MapTest<br>{<br>  public static void main(String… args){<br>    Map map=//new HashMap();<br>            //new Hashtable();<br>            new TreeMap(/</em>new Comparator(){<br>            @Override<br>            public int compare(Object o1,Object o2){<br>              Student stu1=(Student)o1;<br>              Student stu2=(Student)o2;<br>              //return stu1.getName().compareTo(stu2.getName());<br>              return stu2.getName().compareTo(stu1.getName());<br>            }<br>            }<em>/);<br>     //map.put(1,”hello”);//key可以是任意类型<br>    // map.put(2,true);<br>    /</em> map.put(“aa”,20);<br>     map.put(“cc”,”world”);<br>      map.put(“bb”,”ff”);<br>       map.put(“dd”,”ww”);<em>/<br>    // map.remove(“bb”);//删除<br>     //System.out.println(map.get(2));//查询<br>     //map.put(2,false);<br>      //System.out.println(map.get(2));//查询<br>      //System.out.println(map.size());//数据个数<br>      //System.out.println(map.get(3));//如果不存在key值则value为null<br>       //out1(map);<br>       //out2(map);<br>      /</em> map.put(new Student(“bb”,20),”哈哈1”);<br>       map.put(new Student(“aa”,20),”true”);<br>       map.put(new Student(“dd”,20),”哈哈1”);*/</p><pre><code> //map.put(new Student(&quot;aa&quot;,18),10);//out1(map); //out3(map); List list=new ArrayList(); list.add(&quot;aa&quot;); list.add(&quot;bbb&quot;); list.add(true); //工具类 Collections.swap(list,0,2); for(Object obj:list){ System.out.println(obj); }</code></pre><p>  }<br>  //第一种遍历<br>  public static void out1(Map map){<br>      Set keys=map.keySet();//获取key的集合<br>      /<em>Iterator iter=keys.iterator();<br>      while(iter.hasNext()){<br>       Object key=iter.next();<br>       Object value=map.get(key);<br>       System.out.println(key+”:”+value);<br>      }</em>/<br>      for(Object key:keys){<br>         Object value=map.get(key);<br>         System.out.println(key+”:”+value);<br>      }<br>  }<br>  //第二种遍历<br>  //Set entrySet():将map集合中的key和对应的value取出来创建一个新的对象，然后把这个新的对象放到set集合中，这个对象就是Map.Entry对象<br>  //Map.Entry对象维护的是key和对应的value<br>public static void out2(Map map){<br>  Set set= map.entrySet();<br>   /<em>Iterator iter=set.iterator();<br>   while(iter.hasNext()){<br>     Object obj=iter.next();<br>      Map.Entry entry=(Map.Entry)obj;<br>      System.out.print(“key:”+entry.getKey());<br>      System.out.print(“value:”+entry.getValue());<br>   }</em>/<br>   for(Object obj:set){<br>     Map.Entry entry=(Map.Entry)obj;<br>      System.out.print(“key:”+entry.getKey()+” “);<br>      System.out.print(“value:”+entry.getValue());<br>      System.out.println();<br>   }<br>}<br>//第三种遍历<br>//Collection values():取出map中所有的value值，将他们放入到Collection集合中，不能够根据key值获取value值了<br>public static void out3(Map map){<br>   Collection coll=map.values();<br>   /<em>for(Iterator iterator=coll.iterator();iterator.hasNext();){<br>   System.out.println(iterator.next());<br>   }</em>/<br>   for(Object obj:coll){<br>   System.out.println(obj);<br>   }<br>}<br>}</p><p>package com.briup.ch23;<br>import java.util.*;<br>public class Test<br>{<br>    public static void main(String… args){<br>    List<string> list=new ArrayList<string>();<br>    list.add(“aa”);<br>    list.add(“bb”);<br>    }<br>}</string></string></p><p>练习：</p><p>1.使用Properties从外界获取传进的数据。</p><p>2.通过反射实例化User对象.</p><p>   class User{</p><p>​    private int id;//id号</p><p>​    private String name; //用户名</p><p>​    private String password;//密码</p><p>​    //构造器和相应的set,get方法</p><p>​    public boolean checkName(String name){//实现代码}</p><p>​    public User getName(String name){//实现代码}</p><p>   }</p><p>  a)查询API查询该User对象包含哪些属性，属性的名字，访问修饰符等信息。</p><p>   修改某个属性的值，获取某个属性的值。</p><p>  b)查询API查询该User对象包含哪些方法，方法的名字，访问修饰符等信息。</p><p>   通过反射调用某个方法。</p><p>  c)查询API查询该User对象包含哪些构造器，构造器的名字，访问修饰符等信息。</p><p>   通过反射调用构造器。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三天笔记</title>
      <link href="/2018/10/19/index22/"/>
      <url>/2018/10/19/index22/</url>
      
        <content type="html"><![CDATA[<p>一:集合<br>  1)java版的数据结构(对数据进行增删改查的操作)<br>  2)集合框架是别人做好的东西，直接使用就好了。<br>  3)集合只能够保存对象.<br>    基本数据类型的包装类：重要性，<br>    因为集合中只能添加对象，不能添加基本数据类型<br>  4)数组也可以对数据进行增删改查的操作。<br>         但是需要自己封装方法。<br>     集合可以简化代码。</p><p>二：集合框架的组成，所在的包java.util包中。<br>  1)接口：定义需要实现的抽象方法。<br>  2)实现类：将接口中的方法实现，如ArrayList,Hashtable等<br>  3)算法：存放和操作数据的算法。如哈希算法，红黑树算法…</p><p>三:集合的层次结构<br>a)：保存单值<br>Collection:定义保存单值的规范<br>   ——Set:定义保存不可重复无序单值的规范<br>     ———HashSet:哈希算法保存数据，检索效率最高的<br>     ———SortedSet：定义在Set基础上进行排序的规范<br>        ———TreeSet：实现排序规则<br>   ——List:定义保存可重复有序单值的规范<br>      ——LinkedList：使用链表实现List接口<br>      ——Vector：使用数组实现List接口，线程安全的<br>      ——ArrayList：使用数组实现List接口，线程不安全</p><p>b)保存键值对（key—value）<br>Map：定义保存键值对的规范（key不能重复，value可重复）<br>    ————HashMap:是线程不安全,效率高,HashMap允许null key和null value，<br>    ————HashTable:是线程安全,Hashtable不允许null key和null value，<br>    ——SortedMap:定义在Map的基础上进行排序的规范(根据key排序)<br>        ————TreeMap：对map进行排序</p><p>四：增强for循环<br>   a)之前的for循环<br>    for(初始化变量;循环条件;变量的控制){<br>       循环体<br>    }<br>   b)增强for循环：方便遍历集合和数组<br>     for(type element : array){<br>      循环体<br>     }<br>  type:数组或集合中数据的数据类型<br>  element:临时变量<br>  array:数组或集合的引用<br>注意：增强for遍历的集合必须是实现Iterable接口。<br>      不能明确指出数据的下标（位置）</p><p>五：set添加元素的时候，如何判断两个对象是否相等？<br>1）先比较hashCode的值，如果hashCode的值不相等，<br>不会比较equals方法，直接返回两个对象不相等。<br>2）先比较hashCode的值，如果hashCode的值相等，<br>再比较equals方法，如果equals比较两个对象不相等，<br>返回这两个对象不相等。</p><p>六：如何判断元素应该添加在set集合的那个地方？(hashCode的作用)<br>   1)使用哈希算法可以提高检索的效率。<br>     哈希算法底层有一张哈希表。哈希表相对于数组。<br>     哈希表的长度根据算法自己的计算出来的。<br>   2)底层使用哈希算法决定对象所存放的位置<br>     所放的位置=通过对象的hashCode%哈希表的长度<br>一个对象默认hashCode值是由对象的地址根据一定算法计算而得出来的。<br>set中添加元素判断对象是否相同需要重写hashCode方法和equals方法<br>如何重写hashCode方法：在java.lang.Object中<br>重写hashCode方法建议：每个不同的对象放在不同的位置<br>                       将所有会影响判断对象是否相同的<br>               属性的hashCode值相加。<br> public int hashCode(){<br>    //return 1;<br>    return 所有的属性的hashCode值相加;<br> }</p><p>七：TreeSet,TreeMap排序：<br>1）自然排序：将需要排序的类实现java.lang.Comparable<br>public class Student implements Comparable{<br>    public int compareTo(Object obj){<br>        ..排序规则<br>    }<br>}<br>2）覆盖排序：创建TreeSet,TreeMap对象指定排序规则。<br>        当该类无法指定自然排序，就只能使用覆盖排序。<br>        如final String类不能用自然排序，只能用覆盖排序。<br>interface java.util.Comparator{<br>    public int compare(Object o1,Object o2){<br>        ..排序规则<br>    }<br>}<br><strong>**</strong>覆盖排序的优先级高于默认排序<br>Set set = new TreeSet();<br>set.add(“b”);<br>set.add(“a”);<br>set.add(“d”);<br>set.add(“c”);<br>***该代码有没有问题？如果没有问题输出什么内容？<br>如果有问题如何修改？</p><p>jdk1.5的新特性：<br>一：自动装箱和自动拆箱</p><p>1）装箱和拆箱<br>装箱：把基本数据类型转化为类类型<br>拆箱：把类类型转化为基本数据类型<br>java的数据类型分为基本数据类型和引用数据类型。java是面向对象的语言，所以Java就希望<br>并且要求java中操作的都是对象。所以所有的基本数据类型都对应一个包装类。<br>基本数据类型：byte,short,int,long,float,double,boolean,char<br>引用数据类型：类类型，接口类型，数组类型<br>包装类：Byte,Short,Integer,Long,Float,Double,Boolean,Character<br>2)如何进行装箱和拆箱<br>数值类：Byte,Short,Integer,Long,Float,Double<br>                     继承了java.lang.Number<br>                 *Value()从包装类中得到基本数据类型<br>                  也就是拆箱。<br>    其他类：Boolean,Character<br>                          booleanValue()<br>              charValue()<br>      装箱通过new或者是valueOf()方法<br>3)自动装箱和自动拆箱<br>自动装箱：基本数据类型自动转化为类类型<br>自动拆箱：类类型自动转化为基本数据类型<br>4)为什么要增加自动装箱和自动拆箱?<br>    基本数据类型和类类型转换比较方便，不需要<br>    程序员手动转换。对集合的操作更加简单。另外包装类是没有办法进行算术运算的，<br>    所以需要将包装类型转为基本数据类型。<br>             jdk5之前 ——–&gt;add(new Integer(5));<br>             jdk5之后 ——–&gt;add(5)<br>5)缺点<br>      自动装箱：<br>         a:自动装箱不一定调用new方法，也可能调用<br>     valueOf(String s)方法。<br>     b:valueOf()先到缓存池中找该基本数据类型对应<br>     的包装类，如果有，就直接返回该包装类，<br>     如果没有，就调用new方法创建一个新的。<br>     缓存池有一定的大小，1个字节（-128到127）<br>     并不是所有的基本数据类型都有缓存池<br>        byte,boolean:全部缓存<br>        int,short,long:缓存-128到127<br>    float,double:没有缓存<br>    char:缓存Unicode&lt;127</p><p>package com.briup.ch22;<br>import java.util.<em>;<br>public class SetTest<br>{<br>    public static void main(String… args){<br>       //Set set=new TreeSet();//无序不可重复，不能像list根据指定位置赋值<br>       /</em>set.add(“aa”);<br>       set.add(“bb”);<br>       set.add(“bb”);<br>       set.add(true);<br>       set.add(10);<br>       for(Iterator iterator=set.iterator();iterator.hasNext();){<br>       System.out.println(iterator.next());<br>       }<br>       set.remove(“aa”);//只能直接删除数据，不能够根据下标去删<br>       for(Object obj:set){<br>       System.out.println(obj);<br>       }*/<br>       MyComparator c=new MyComparator();<br>       Set set=new TreeSet(c);<br>       set.add(new Student(“zzz”,35));<br>       set.add(new Student(“李四”,20));<br>       set.add(new Student(“张三”,18));<br>       set.add(new Student(“王五”,30));<br>       System.out.println(set);<br>    }<br>    //覆盖排序<br>    static class MyComparator implements Comparator<br>    {<br>        @Override<br>        public int compare(Object o1,Object o2){<br>        Student stu1=(Student)o1;<br>        Student stu2=(Student)o2;<br>        if(stu1.getAge()==stu2.getAge())<br>            return stu1.getName().compareTo(stu2.getName());<br>        return stu2.getAge()-stu1.getAge();<br>        }<br>    }</p><p>​<br>}</p><p>package com.briup.ch22;<br>public class Student implements Comparable<br>{<br>    private String name;<br>    private int age;<br>    public Student(){<br>    }<br>    public Student(String name,int age){<br>    this.name=name;<br>    this.age=age;<br>    }<br>    public void setName(String name){<br>    this.name=name;<br>    }<br>    public String getName(){<br>     return name;<br>    }<br>    public void setAge(int age){<br>      this.age=age;<br>    }<br>    public int getAge(){<br>     return age;<br>    }<br>    @Override<br>    public boolean equals(Object obj){<br>     if(obj==null)<br>         return false;<br>     if(obj==this)<br>         return true;<br>     if(!obj.getClass().equals(this.getClass()))<br>         return false;<br>     if(obj instanceof Student){<br>       Student stu=(Student)obj;<br>       if(stu.getAge()==this.getAge()&amp;&amp;<br>           stu.getName().equals(this.getName()))<br>           return true;</p><pre><code> } return false;}@Overridepublic int hashCode(){  //return 1;//这种虽然能够让equals方法生效，但是这种方式相当于之后存的对象就需要和之前已存的对象都要进行比较，效率会很低  return name.hashCode()+age;}//自定义排序规则</code></pre><p>  @Override<br>   public int compareTo(Object obj){<br>    if(obj instanceof Student){<br>      Student stu=(Student)obj;<br>       if(stu.getAge()==this.getAge())<br>           return stu.getName().compareTo(this.getName());<br>        return this.getAge()-stu.getAge();<br>    }<br>    return 0;<br>   }<br>    @Override<br>    public String toString(){<br>    return “name=”+name+”,age=”+age;<br>    }<br>}</p><p>第六章：高级语言特性</p><p>一）基础实验：</p><p>1.完成ListTest.java测试java.util包下提供的List接口保存数据，</p><p>   删除数据，修改数据和三种遍历数据等(查询相应的API完成)</p><p>public static void main(String[] args) {</p><p>​    List list=new ArrayList();</p><p>​    list.add(“aa”);//增加数据</p><p>​    list.add(“bb”);</p><p>​    list.add(“cc”);</p><p>​    list.remove(2);//删除数据</p><p>​    list.set(1, “dd”);//修改数据</p><p>​    for (int i = 0; i &lt; list.size(); i++) {</p><p>​        System.out.println(list.get(i));</p><p>​    }</p><p>​    for (Iterator iterator = list.iterator(); iterator.hasNext();) {</p><p>​        System.out.println(iterator.next());</p><p>​        </p><p>​    }</p><p>​    for (Object listt : list) {</p><p>​        System.out.println(listt);</p><p>​    }</p><p>}</p><p>2.完成SetTest.java测试java.util包下提供的Set接口保存数据，</p><p>   删除数据，修改数据和二种遍历数据等(查询相应的API完成)</p><p>Set set = new HashSet();// 无序不可重复</p><p>​        set.add(“aa”);// 增加数据</p><p>​        set.add(“bb”);</p><p>​        set.add(“bb”);</p><p>​        set.add(“cc”);</p><p>​        set.remove(“aa”);// 删除数据</p><p>​        set.add(“briup”);</p><p>​        for (Iterator iterator = set.iterator(); iterator.hasNext();) {</p><p>​            System.out.println(iterator.next());</p><p>​        }</p><p>​        for (Object sett : set) {</p><p>​            System.out.println(sett);</p><p>​        }</p><p>3.完成Student.java,StudentTest.java测试java.util包下提</p><p>  供的TreeSet接口保存数据和数据的排序等(查询相应的API完成)</p><p>4.基本数据类型和对应的包装类有什么作用？如何实现转换？</p><p>5.测试下面的代码，看看结果，为什么会出现这样的结果？</p><p>  Integer i1 = 127;</p><p>  Integer i2 = 127;</p><p>  System.out.println(i1==i2);</p><p>  Integer i3 = 128;</p><p>  Integer i4 = 128;</p><p>  System.out.println(i3==i4);</p><p>  true</p><p>  false</p><p>  原因valueOf会将常用的值（-128 to 127）缓存起来，超过127就会创建引用</p><p>二）作业：</p><p>1.编程</p><p>完成readme.txt的作业</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十一天笔记</title>
      <link href="/2018/10/18/index21/"/>
      <url>/2018/10/18/index21/</url>
      
        <content type="html"><![CDATA[<p>一:集合<br>  1)java版的数据结构(对数据进行增删改查的操作)<br>  2)集合框架是别人做好的东西，直接使用就好了。<br>  3)集合只能够保存对象.<br>    基本数据类型的包装类：重要性，<br>    因为集合中只能添加对象，不能添加基本数据类型<br>  4)数组也可以对数据进行增删改查的操作。<br>         但是需要自己封装方法。<br>     集合可以简化代码。</p><p>二：集合框架的组成，所在的包java.util包中。<br>  1)接口：定义需要实现的抽象方法。<br>  2)实现类：将接口中的方法实现，如ArrayList,Hashtable等<br>  3)算法：存放和操作数据的算法。如哈希算法，红黑树算法…</p><p>三:集合的层次结构<br>a)：保存单值<br>Collection:定义保存单值的规范<br>   ——Set:定义保存不可重复无序单值的规范<br>     ———HashSet:哈希算法保存数据，检索效率最高的<br>     ———SortedSet：定义在Set基础上进行排序的规范<br>        ———TreeSet：实现排序规则<br>   ——List:定义保存可重复有序单值的规范<br>      ——LinkedList：使用链表实现List接口<br>      ——Vector：使用数组实现List接口，线程安全的<br>      ——ArrayList：使用数组实现List接口，线程不安全</p><p>b)保存键值对（key—value）<br>Map：定义保存键值对的规范（key不能重复，value可重复）<br>    ————HashMap:是线程不安全,效率高,HashMap允许null key和null value，<br>    ————HashTable:是线程安全,Hashtable不允许null key和null value，<br>    ——SortedMap:定义在Map的基础上进行排序的规范(根据key排序)<br>        ————TreeMap：对map进行排序</p><p>四：增强for循环<br>   a)之前的for循环<br>    for(初始化变量;循环条件;变量的控制){<br>       循环体<br>    }<br>   b)增强for循环：方便遍历集合和数组<br>     for(type element : array){<br>      循环体<br>     }<br>  type:数组或集合中数据的数据类型<br>  element:临时变量<br>  array:数组或集合的引用<br>注意：增强for遍历的集合必须是实现Iterable接口。<br>      不能明确指出数据的下标（位置）</p><p>package com.briup.ch21;<br>import java.util.*;<br>public class ListTest<br>{<br>    public static void main(String… args){<br>      List list=new ArrayList();<br>                //new LinkedList();<br>       list.add(“aa”);<br>       list.add(“bb”);<br>       list.add(10);<br>       list.add(“bb”);<br>       list.add(true);<br>       list.set(2,”cc”);<br>       list.remove(3);<br>       //第一种循环方式<br>       for(int i=0;i&lt;list.size();i++){<br>        System.out.println(list.get(i));<br>       }<br>       //第二种循环方式<br>       for(Iterator iterator=list.iterator();iterator.hasNext();){<br>       System.out.println(iterator.next());<br>       }<br>       //第三种循环方式<br>       Iterator iterator=list.iterator();<br>       while(iterator.hasNext()){<br>        System.out.println(iterator.next());<br>       }<br>    }<br>}</p><p>public class ListTest<br>{<br>    public static void main(String… args){<br>      List list=new LinkedList();<br>         list.add(10);<br>         list.add(“hello”);<br>         list.add(true);<br>         //System.out.println(list.remove(0));<br>          //list.set(1,”world”);<br>          //System.out.println(list.get(1));<br>       for(int i=0;i&lt;list.size();i++){<br>        System.out.println(list.get(i));<br>       }</p><p>​<br>​       </p><pre><code>List list2=new ArrayList();list2.add(50);list2.add(40);list2.add(30);list2.add(20);for(int i=0;i&lt;list2.size();i++){    System.out.println(list2.get(i));   }//迭代器方式</code></pre><p>//       Iterator iter=list.iterator();<br>//       while(iter.hasNext()){<br>//           Object obj=iter.next();<br>//           System.out.println(obj);<br>//       }<br>    }<br>}</p><p>public interface List<br>{<br>    //在指定位置增加数据<br>   public void add(int index,Object obj);<br>   //在最后添加数据<br>   public void add(Object obj);<br>   //删除指定位置对象<br>   public Object remove(int index);<br>   //修改指定位置的数据<br>   public void set(int index,Object obj);<br>   //获取指定位置的数据<br>   public Object get(int index);<br>   //获取数据结构的长度<br>   public int size();<br>   //获取当前数据结构的迭代器<br>    public Iterator iterator();<br>}</p><p>public class LinkedList implements List<br>{<br>    private int size;//当前对象个数<br>    private Node head;//头结点<br>    public LinkedList(){<br>     head=new Node(null,null);<br>    }<br>    @Override<br>    public void add(int index,Object obj){<br>      if(index<0 ||="" index="">size)<br>          return;<br>      Node curr=head;<br>      for(int i=0;i&lt;index;i++){<br>        curr=curr.next;<br>      }<br>     Node node=new Node(obj);<br>     node.next=curr.next;<br>     curr.next=node;<br>     size++;<br>    }<br>    @Override<br>    public void add(Object obj){<br>      add(size,obj);<br>    }<br>    @Override<br>    public Object remove(int index){<br>    if(index<0 ||="" index="">=size) return null;<br>      Node curr=head;//将来要删除的节点<br>      Node pre=null;//上一个节点<br>      for(int i=0;i&lt;=index;i++){<br>          pre=curr;<br>          curr=curr.next;<br>      }<br>      Object obj=curr.getData();<br>      pre.next=curr.next;<br>      curr.next=null;<br>      size–;<br>      return obj;<br>    }<br>    @Override<br>    public void set(int index,Object obj){<br>      if(index<0 ||="" index="">=size) return;<br>      Node curr=head;<br>      for(int i=0;i&lt;=index;i++){<br>        curr=curr.next;<br>      }<br>      curr.setData(obj);//改变对象中真实的数据<br>    }<br>    @Override<br>    public Object get(int index){<br>      if(index<0 ||="" index="">=size) return null;<br>      Node curr=head;<br>      for(int i=0;i&lt;=index;i++){<br>        curr=curr.next;<br>      }<br>      return curr.getData();<br>    }<br>    @Override<br>    public int size(){<br>    return size;<br>    }<br>  public Iterator iterator(){</0></0></0></0></p><p>  return new Iterator(){<br>      private int position=-1;<br>    public boolean hasNext(){<br>        if(position+1&lt;size)<br>         return true;<br>        return false;<br>    }<br>    public Object next(){<br>        if(position+1&lt;size){<br>        return get(++position);<br>        }else{<br>        return null;<br>        }</p><pre><code>}public Object remove(){    if(position==size-1){    return LinkedList.this.remove(position--);    }else{    return null;    }}</code></pre><p>  };<br>  }<br>}</p><p>public class ListTest<br>{<br>    public static void main(String… args){<br>      List list=new LinkedList();<br>         list.add(10);<br>         list.add(“hello”);<br>         list.add(true);<br>         //System.out.println(list.remove(0));<br>          //list.set(1,”world”);<br>          //System.out.println(list.get(1));<br>       for(int i=0;i&lt;list.size();i++){<br>        System.out.println(list.get(i));<br>       }</p><p>​<br>​       </p><pre><code>List list2=new ArrayList();list2.add(50);list2.add(40);list2.add(30);list2.add(20);for(int i=0;i&lt;list2.size();i++){    System.out.println(list2.get(i));   }//迭代器方式</code></pre><p>//       Iterator iter=list.iterator();<br>//       while(iter.hasNext()){<br>//           Object obj=iter.next();<br>//           System.out.println(obj);<br>//       }<br>    }<br>}</p><p>public interface Iterator<br>{<br>    //判断是否有下一个数据<br>    boolean hasNext();<br>    //取下一个数据<br>    Object next();<br>    //删除迭代器中最后一个数据<br>    Object remove();<br>}</p><p>//节点类<br>public class Node<br>{<br>private Object data;//节点中真正的数据<br>public Node next;//下一个对象的地址<br>public Node(Object data){<br> this.data=data;<br>}<br>public Node(Object data,Node next){<br>this.data=data;<br>this.next=next;<br>}<br>public Object getData(){<br>  return data;<br>}<br>public void setData(Object data){<br>this.data=data;<br>}<br>}</p><p>package com.briup.ch21;<br>import java.util.*;<br>public class ListTest<br>{<br>    public static void main(String… args){<br>      List list=new ArrayList();<br>                //new LinkedList();<br>       list.add(“aa”);<br>       list.add(“bb”);<br>       list.add(10);<br>       list.add(“bb”);<br>       list.add(true);<br>       list.set(2,”cc”);<br>       list.remove(3);<br>       //第一种循环方式<br>       for(int i=0;i&lt;list.size();i++){<br>        System.out.println(list.get(i));<br>       }<br>       //第二种循环方式<br>       for(Iterator iterator=list.iterator();iterator.hasNext();){<br>       System.out.println(iterator.next());<br>       }<br>       //第三种循环方式<br>       Iterator iterator=list.iterator();<br>       while(iterator.hasNext()){<br>        System.out.println(iterator.next());<br>       }<br>    }<br>}</p><p>一）基础实验：</p><p> 1)完成ArrayList使用数组实现保存任何类型任何个数可重复的有序的数据结构</p><p> 2)完成LinkedList使用数组实现保存任何类型任何个数可重复的有序的数据结构</p><p>二）扩展实验：</p><p> 1)写MyStack类，实现栈功能。在类中使用ArrayList保存数据。</p><p>写MyQueue类，实现队列功能。在类中使用ArrayList保存数据。</p><p>使用Test.java测试栈和队列</p><p>public class MyQueue {</p><p>private ArrayList data;</p><p>public MyQueue(){</p><p>​    data=new ArrayList();</p><p>}</p><p>public void in(Object o){</p><p>​    data.add(o);</p><p>}</p><p>public Object out(){</p><p>​    int size=data.size();</p><p>​    if(size&gt;0)</p><p>​        return data.remove(0);</p><p>​    else </p><p>​        return null;</p><p>}</p><p>public int getSize(){</p><p>​    return data.size();</p><p>}</p><p>}</p><p>public class MyStack {</p><p>private ArrayList data;</p><p>public MyStack(){</p><p>​    data=new ArrayList();</p><p>}</p><p>public void push(Object o){</p><p>​    data.add(o);</p><p>}</p><p>public Object pop(){</p><p>​    int size=data.size();</p><p>​    if(size&gt;0)</p><p>​        return data.remove(data.size()-1);</p><p>​    else </p><p>​        return null;</p><p>}</p><p>public int getSize(){</p><p>​    return data.size();</p><p>}</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十天笔记</title>
      <link href="/2018/10/18/index20/"/>
      <url>/2018/10/18/index20/</url>
      
        <content type="html"><![CDATA[<p>开发一个数据结构：保存数据和操作数据。<br>任务：可以存放任意类型任意个数的可重复的有序数据。<br>数据结构底层：可以采用数组和链表来实现。<br>调用者：不关心底层是怎么做。对数据进行增删改查的操作。<br>         对于操作者不需要关心底层采用什么实现的，<br>     只需要采用统一的接口完成相同的事情。—-》定义规范。<br>定义标准(规范)：可以采用接口和抽象类。<br>标准一:提供数据增删改查的规范<br>对数据进行增删改查：通用的操作—》定义标准<br>34 57 455 45    80<br>public interface List{<br>    public void add(int index,Object o);<br>    //在最后增加对象<br>    public void add(Object o);<br>        public Object remove(int index);<br>    public Object get(int index);<br>    public int size();<br>    public void set(int index,Object o);<br>    public Iterator iterator();<br>}<br>标准二：<br>遍历元素:迭代器<br>public interface Iterator{<br>    //判断是否有下一个数据<br>    boolean hasNext();<br>    //取下一个数据<br>    Object next();<br>    //删除迭代器中最后一个数据<br>    void remove();<br>}<br>实现三：实现List(数组和链表)<br>//数组<br>class ArrayList implements List{<br>}<br>//链表<br>class LinkedList implements List{<br>}</p><p>package com.briup.ch20;<br>//数组<br>public class ArrayList implements List<br>{<br>    private Object[] elements;//数组<br>    private int length;//数组长度<br>    private int size;//当前对象个数<br>    public ArrayList(){<br>     this(10);<br>    }<br>    public ArrayList(int length){<br>      elements=new Object[length];<br>      this.length=length;<br>    }<br>    //判断是否扩容<br>    private void ensureCap(){<br>      if(size&gt;=length){<br>        Object[] arry=new Object[length+10];<br>        System.arraycopy(elements,0,arry,0,size);<br>        elements=arry;<br>        this.length=length+10;</p><pre><code>  }}//指定为增加数据@Override</code></pre><p> public void add(int index,Object obj){<br>    //判断index是否是非法位置<br>    if(index<0 ||="" index="">size)<br>        return;<br>    //判断空间是否满了<br>       ensureCap();<br>       for(int i=size;i&gt;index;i–){<br>       elements[i]=elements[i-1];<br>       }<br>       //指定位置赋值<br>       elements[index]=obj;<br>       size++;<br> }<br> @Override<br> public void add(Object obj){<br>   add(size,obj);<br> }<br> //指定位置删除<br> @Override<br> public Object remove(int index){<br> //判断是否越界<br>  if(index<0 ||="" index="">=size)<br>      return null;<br>  //先将要删除的临时保存起来<br>  Object obj=elements[index];<br>  for(int i=index;i&lt;size-1;i++){<br>   elements[i]=elements[i+1];<br>  }<br>  elements[–size]=null;</0></0></p><p>  return obj;<br> }<br> @Override<br>public void set(int index,Object obj){<br> //判断位置是否越界<br> if(index<0 ||="" index="">=size)<br>     return;<br>   elements[index]=obj;<br> }<br> @Override<br> public Object get(int index){<br> if(index<0 ||index="">=size)<br>     return null;<br> return elements[index];<br> }<br> @Override<br> public int size(){<br>   return size;<br> }<br> /*<br>-1<br>   0  1   2   3   4<br>   10 20  30  40  50<br> postion=-1<br> postion+1&lt;size 有值<br> position+1=size 无值</0></0></p><p> */<br>@Override<br>public Iterator iterator(){</p><p> return new Iterator(){<br>     private int position=-1;<br>   @Override<br>   public boolean hasNext(){<br>       if(position+1&lt;size)<br>           return true;<br>     return false;<br>   }<br>   @Override<br>public Object next(){<br>   //判断下一是否有值，依次取出来<br>   if(position+1&lt;size){<br>    return get(++position);<br>   }else{<br>   return null;<br>   }<br>   }<br>   @Override<br>public Object remove(){<br>       if(position+1&lt;size){<br>       return ArrayList.this.remove(position–);<br>       }else{<br>        return null;<br>       }</p><p>   }<br> };</p><p>}<br>}</p><p>package com.briup.ch20;<br>public interface Iterator<br>{<br>    //判断是否有下一个数据<br>    boolean hasNext();<br>    //取下一个数据<br>    Object next();<br>    //删除迭代器中最后一个数据<br>    Object remove();<br>}</p><p>package com.briup.ch20;<br>public class LinkedList implements List<br>{<br>    private int size;//当前对象个数<br>    private Node head;//头结点<br>    public LinkedList(){<br>     head=new Node(null,null);<br>    }<br>    @Override<br>    public void add(int index,Object obj){<br>      if(index<0 ||="" index="">size)<br>          return;<br>      Node curr=head;<br>      for(int i=0;i&lt;index;i++){<br>        curr=curr.next;<br>      }<br>     Node node=new Node(obj);<br>     node.next=curr.next;<br>     curr.next=node;<br>     size++;<br>    }<br>    @Override<br>    public void add(Object obj){<br>        add(size,obj);</0></p><pre><code>}@Overridepublic Object remove(int index){    if(index&lt;0||index&gt;size)        return null;    Node curr=head;//代表将来要删除的节点    Node pre=null;//代表上一个节点    for(int i=0;i&lt;=index;i++)    {        pre=curr;        curr=curr.next;    }    Object obj=curr.getData();    pre.next=curr.next;    curr.next=null;    size--;    return obj;}@Overridepublic void set(int index,Object obj){        if(index&lt;0||index&gt;=size)            return;        Node curr=head;        for(int i=0;i&lt;=index;i++)        {            curr=curr.next;        }        curr.setData(obj);</code></pre><p>​<br>    }<br>}</p><p>package com.briup.ch20;<br>public interface List<br>{<br>    //在指定位置增加数据<br>   public void add(int index,Object obj);<br>   //在最后添加数据<br>   public void add(Object obj);<br>   //删除指定位置对象<br>   public Object remove(int index);<br>   //修改指定位置的数据<br>   public void set(int index,Object obj);<br>   //获取指定位置的数据<br>   public Object get(int index);<br>   //获取数据结构的长度<br>   public int size();<br>   //获取当前数据结构的迭代器<br>    public Iterator iterator();<br>}</p><p>package com.briup.ch20;<br>public class ListTest<br>{<br>    public static void main(String… args){<br>      List list=new ArrayList();<br>         list.add(10);<br>         list.add(“hello”);<br>         list.add(true);<br>         //System.out.println(list.remove(0));<br>          //list.set(1,”world”);<br>          //System.out.println(list.get(1));<br>       for(int i=0;i&lt;list.size();i++){<br>        System.out.println(list.get(i));<br>       }<br>       //迭代器方式<br>       Iterator iter=list.iterator();<br>       while(iter.hasNext()){<br>           Object obj=iter.next();<br>           System.out.println(obj);<br>       }<br>    }<br>}</p><p>package com.briup.ch20;<br>//节点类<br>public class Node<br>{<br>private Object data;//节点中真正的数据<br>private Node next;//下一个对象的地址<br>public Node(Object data){<br> this.data=data;<br>}<br>public Node(Object data,Node next){<br>this.data=data;<br>this.next=next;<br>}<br>public Object getData(){<br>  return data;<br>}<br>public void setData(Object data){<br>this.data=data;<br>}<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十九天笔记</title>
      <link href="/2018/10/18/index19/"/>
      <url>/2018/10/18/index19/</url>
      
        <content type="html"><![CDATA[<p>六. 内部类<br>顶层类和内部类的区别：<br>  1)位置:内部类是定义一个类的里面或者一个方法中,或者一个表达式中。<br>     顶层类是定义在package下<br>  2)修饰符：顶层类只能处于public和默认访问级别，<br>            成员内部类可以处于public, protected, private和默认这4种访问级别；<br>作用：<br>  1)可以避免命名冲突。<br>  2)定义类的范围从package变成了类。<br>   在一个类的内部定义的类称为内部类。<br>  3)进行再一次的封装<br>  4)分担外围类的功能</p><p>内部类的分类：<br>    变量按照作用域可分为：<br>      1) 成员变量: 实例变量、静态变量；<br>      2) 局部变量；<br>     同样，内部类按照作用域可分为；<br>      1) 成员内部类: 实例内部类、静态内部类；<br>      2) 局部内部类；<br>      3) 匿名内部类</p><p>a) 静态内部类:用static修饰,相当于静态方法。放在方法外，类里面的。<br>静态内部类具有以下特点：<br>1)静态内部类可以直接访问外部类的静态资源。<br>  如果静态内部类中的变量名字和外围类的变量名字<br>  相同，需要指定访问时的谁的名字。<br>2)静态内部类如果访问外部类的实例成员，<br>  就必须通过外部类的实例去访问。<br>3)静态内部类的实例不会自动持有外部类<br>  的特定实例的引用，<br>  在创建静态内部类的实例时，<br>  不必创建外部类的实例。<br>4)在静态内部类中可以定义静态成员和实例成员。<br>5)外围类可以通过完整的类名直接访<br>  问静态内部类的静态成员。<br>6)外围类可以通过内部类对象<br>调用静态内部类对象的非静态成员。<br>7)在静态内部类中和外围类中创建静态内部类的对象.<br>  静态内部类类名 m=new 静态内部类类名();<br>  在其他类中创建静态内部类的对象:<br>    外围类.静态内部类类名 m=<br>      new 外围类.静态内部类类名();</p><p>b)实例内部类：没有static修饰符。相当于成员变量。放在方法外，类里面的。<br>特点：<br>1)在内部类中,可以直接访问外部类的所有资源(属性和方法)。<br>2)成员内部类不能定义静态的资源，<br>  只能定义非静态的资源。<br>3)外围类不能直接访问成员内部类的资源.<br>   先创建成员内部类的对象，<br>   在通过调用非静态资源(对象.资源)<br>4)在成员内部类中和外围类中创建成员内部类的对象<br>  成员内部类中:类名 m=new 成员内部类类名();<br>  外围类中:类名 m=this.new 成员内部类类名();<br>  在其他类中创建成员内部类的对象:<br>  外围类.成员内部类类名 m=new 外围类().new 成员内部类类名();<br>5)在创建实例内部类的实例时,外部类的实例必须已经存在。<br>6)在成员内部类中调用外围类中同名资源:<br>              外围类.this.资源<br>7)如果实例内部类B与外部类A包含同名的成员，那么在类B中，this.v表示类B的成员， A.this.v表示类A的成员<br>8)实例内部类的实例自动持有外部类的实例的引用。<br>9)外部类实例与内部类实例之间是一对多的关系，<br>  一个内部类实例只会引用一个外部类实例，<br>  而一个外部类实例对应零个或多个内部类实例。</p><p>c) 局部内部类:在一个方法中定义的内部类，它的可见范围是当前方法。和局部变量一样。<br>特点：<br>1)局部内部类只能在当前方法中使用。<br>2)局部内部类和实例内部类一样，不能包含静态成员。<br>3)在局部内部类中定义的内部类也不能被public、protected和private这些访问控制修饰符以及static修饰;<br>4)可以访问外部类的所有成员</p><p>d)匿名内部类：在一个方法中定义的内部类，它的可见范围是当前方法。和局部变量一样<br>特点：<br>1)没有类名，使用接口或者抽象类代替类名<br>2)访问外围类的一切资源(方法和属性)<br>3)访问该方法final修饰的局部变量<br>4)放在方法中或者作为参数。</p><p>几种内部类的区别：</p><ol><li><p>创建<br>a. 声明的位置:<br>  静态内部类：类的内部，方法的外部，用static关键字修饰；<br>  实例内部类：类的内部，方法的外部，不用static关键字修饰；<br>  局部内部类：方法的内部；<br>  匿名内部类：既可以在类的内部，方法的外部，也可以在方法的内部；</p><p>b. 实例化方式:<br>静态内部类：new Outer.Inner();          //在外部类外创建；</p><pre><code>new Inner();                //在外部类内内部类外创建</code></pre><p>实例内部类：new Outer().new Inner();      //在外部类外创建；</p><pre><code>this.new Inner();             //在外部类内内部类外创建 </code></pre><p>局部内部类：new Inner();                  //只能在方法内部创建<br>匿名内部类：new 类名() {};            </p></li></ol><ol start="2"><li>访问<br>a. 外部类访问内部类：<br> 静态内部类：通过完整的类名直接访问静态内部类的静态成员;<br> 实例内部类：通过内部类的实例去访问内部类的成员;<br> 局部内部类：不能访问；<br> 匿名内部类：不能访问；<br>b. 内部类访问外部类：<br> 静态内部类：直接访问外部类的静态成员；<br> 实例内部类：可以直接访问外部类的所有成员;<pre><code>如果实例内部类B与外部类A包含同名的成员，那么在类B中， this.v表示类B的成员，       A.this.v表示类A的成员。</code></pre> 局部内部类：可以直接访问外部类的所有成员, <pre><code>访问所在方法中的final类型的参数和变量；</code></pre> 匿名内部类：可以直接访问外部类的所有成员, <pre><code>访问所在方法中的final类型的参数和变量；</code></pre>为什么要使用内部类？<br>1)分担外围的复杂的功能<br>2)进行再一次的封装<br>3)定义只使用一次的类<br>4)避免命名冲突<br>//成员内部类，静态内部类<br>StaticInnerTest.class<br>StaticInnerTest$MaxMin.class<br>//局部内部类<br>LocalInnerTest.class<br>LocalInnerTest$1MaxMin.class<br>//匿名内部类<br>AnonymousInnerTest.class<br>AnonymousInnerTest$1.class</li></ol><p>内部类的使用：监听事件<br>          工厂模式,在内部类只有在该外围类有意义，<br>          出了该外围类就没有意义了， 就可以将该<br>          类定义成内部类。<br>工厂模式：生产对象<br>public class KFC{<br>    public static 套餐 get套餐(钱,几号套餐){<br>        if(钱够){<br>           if(几号套餐存在){<br>            return new 套餐();<br>            }<br>        }<br>    }<br>        private class 套餐{<br>        private int id;<br>        类型，价格，饮料…..<br>    }<br>}</p><p>套餐 a = KFC.get套餐();</p><p>/////////////////////////////////////</p><p>开发一个数据结构：保存数据和操作数据。<br>任务：可以存放任意类型任意个数的可重复的有序数据。<br>数据结构底层：可以采用数组和链表来实现。<br>调用者：不关心底层是怎么做。对数据进行增删改查的操作。<br>         对于操作者不需要关心底层采用什么实现的，<br>     只需要采用统一的接口完成相同的事情。—-》定义规范。<br>定义标准(规范)：可以采用接口和抽象类。<br>标准一:提供数据增删改查的规范<br>对数据进行增删改查：通用的操作—》定义标准<br>34 57 455 45    80<br>public interface List{<br>    public void add(int index,Object o);<br>    //在最后增加对象<br>    public void add(Object o);<br>        public Object remove(int index);<br>    public Object get(int index);<br>    public int size();<br>    public void set(int index,Object o);<br>    public Iterator iterator();<br>}</p><p>package com.briup.ch19;<br>public class Test<br>{<br>    public static void main(String… args){<br>       new Test().tt();</p><pre><code>}public void tt(){//其他类访问成员内部类   /*InnerTest.Inner in=new InnerTest().new Inner();   //in.a=20;   in.aa();*/   //其他类访问静态内部类   InnerTest.StaticInner ins=new InnerTest.StaticInner();   ins.aa();}</code></pre><p>}</p><p>package com.briup.ch19;<br>public class InnerTest<br>{<br>    private String name=”aa”;<br>    private  int age=10;<br>    private static int score=20;<br>    public void display(){</p><pre><code>//调用成员内部类/*Inner in=new Inner();in.a=20;in.aa();System.out.println(&quot;name:&quot;+name+&quot;;age:&quot;+age);*/}//成员内部类/*public class Inner{    private  int a=10;    public void aa(){    name=&quot;王五&quot;;    System.out.println(name);    }}*///静态内部类/*public static class StaticInner{    private static int bb=10;   private int a=10;   private static int score=10;    public void aa(){        //age=50;        InnerTest in=new InnerTest();        in.display();        in.age=10;        System.out.println(InnerTest.score);   }}*///局部内部类/*public void methodInner(){    class localInner  {        //private static int c=0;        private int aa=10;        public void aaa(){        age=20;        display();        score=30;        }  }  //在内部类所在外部的方法中使用  localInner ln=new localInner();  ln.aaa();}*/public void noInner(){   new NoNameInner(){     public void ni(){       age=30;       display();     }   };}public static void main(String... args){    //new InnerTest().display();    //System.out.println(StaticInner.bb);     //System.out.println(StaticInner.a);</code></pre><p>/<em>StaticInner st=new StaticInner();<br>st.a=20;<br>st.aa();</em>/<br>    }<br>}<br>interface NoNameInner<br>{<br>    public void ni();<br>}</p><p>第六章：高级语言特性</p><p>一）基础实验：</p><p>1） 描述接口，接口的作用？</p><p>​    a.实现了多继承  </p><p>​      对于java中都是单继承，在某些情况下不满足子类条件，所以定义了接口</p><p>​    b.接口是抽象类的抽象</p><p>​        接口中所有的方法都是都是抽象方法</p><p>​    1.8新特性，接口中可以实现静态方法</p><p>​    c.在接口中定义变量修饰符默认都是public static final</p><p>​    d.接口中没有构造器—不能实例化</p><p>​    e.接口可以继承多个接口</p><p>2)equals和==的区别？通过代码测试</p><p>== 判断两个对象的地址</p><p>equals()判断的是两个对象是否相同</p><p>一个类如果没有重写equals方法，那么equals和==所比较的一样都是地址值，String除外</p><p>重写equals方法的规则，来自Object</p><p> 第一步：判断传进来的对象是否是空对象null</p><p>​     return false;</p><p> 第二步：判断传进来的对象是否是当前对象</p><p>​        return true;</p><p> 第三步：判断传进来的数据类型是否和当前的数据类型一致</p><p> 第四步：自定义比较规则</p><p> @Override</p><p> public boolean equals(Object obj){</p><p>   //判断传进来的是否是null对象</p><p>   if(obj==null)</p><p>​     return false;</p><p>   //传进对象是否是当前对象</p><p>   if(obj==this)</p><p>​     return true;</p><p>​     //getClass(),返回类型String,结果就是权限类名</p><p>​     if(!obj.getClass().equals(this.getClass()))</p><p>​    return false;</p><p>​     //自定义比较规则</p><p>​     if(obj instanceof Student){</p><p>​     //根据年龄和姓名比较如果内容都相同则返回true</p><p>​       if(obj.getName().equals(this.getName())&amp;&amp;obj.getAge()==this.getAge())</p><p>​       return true;</p><p>​     }</p><p>​     return false;</p><p>​    </p><p> }</p><p> 如果所比较的类中还有其他类变量，则在比较类时需要将变量所对应的类重写equals方法</p><p>3)toString方法的作用？</p><p>在打印对象时获取所有变量内容，则需要重写toString()方法</p><p>5)内部类的使用</p><p> a)在外围类中完成查找数组的最大数和最小数。</p><p>public class MaxOrMin {</p><p>​    public static void main(String[] args){</p><p>​        Max a=new MaxOrMin().new Max();</p><p>​        int max = a.is[0];</p><p>​        int min = a.is[0];</p><p>​        int sum = 0;</p><p>​        for(int i=0;i&lt;a.is.length;i++){</p><p>​            if(a.is[i]&gt;max){</p><p>​                max=a.is[i];</p><p>​            }</p><p>​            if(a.is[i]&lt;min){</p><p>​                min=a.is[i];</p><p>​            }</p><p>​            sum+=a.is[i];</p><p>​        }</p><p>​        System.out.println(“最小是：”+min);</p><p>​        System.out.println(“最大是：”+max);</p><p>​    }</p><p>​    class Max{</p><p>​         int[] is={3,2,5,35,17,28,21,45,7};</p><p>​    }</p><p>}</p><p> b)在静态内部类中完成查找数组的最大数和最小数。</p><p> public class MaxOrMin {</p><p>​    public static void test(){</p><p>​         int[] is={3,2,5,35,17,28,21,45,7};</p><p>​        int max = is[0];</p><p>​        int min = is[0];</p><p>​        int sum = 0;</p><p>​        for(int i=0;i&lt;is.length;i++){</p><p>​            if(is[i]&gt;max){</p><p>​                max=is[i];</p><p>​            }</p><p>​            if(is[i]&lt;min){</p><p>​                min=is[i];</p><p>​            }</p><p>​            sum+=is[i];</p><p>​        }</p><p>​        System.out.println(“最小是：”+min);</p><p>​        System.out.println(“最大是：”+max);</p><p>​    }</p><p>​    static class Max{</p><p>​        public static void main(String[] args) {</p><p>​            test();</p><p>​        }</p><p>​    }</p><p>}</p><p> c)在实例内部类中完成查找数组的最大数和最小数</p><p> public class MaxOrMin {</p><p>​    public static void main(String[] args) {</p><p>​        Max a = new MaxOrMin().new Max();</p><p>​        a.max();</p><p>​    }</p><p>​    class Max {</p><p>​        public void max() {</p><p>​            int[] is = { 3, 2, 5, 35, 17, 28, 21, 45, 7 };</p><p>​            int max = is[0];</p><p>​            int min = is[0];</p><p>​            int sum = 0;</p><p>​            for (int i = 0; i &lt; is.length; i++) {</p><p>​                if (is[i] &gt; max) {</p><p>​                    max = is[i];</p><p>​                }</p><p>​                if (is[i] &lt; min) {</p><p>​                    min = is[i];</p><p>​                }</p><p>​                sum += is[i];</p><p>​            }</p><p>​            System.out.println(“最小是：” + min);</p><p>​            System.out.println(“最大是：” + max);</p><p>​        }</p><p>​    }</p><p>}</p><p> d) 实例内部类：</p><p>​    将Age比较器定义成实例内部类</p><p>​    //根据年龄比较</p><p>class AgeComparator extends Comparator{</p><p>​    public int compare</p><p>​            (Object o1,Object o2){</p><p>​        Student s1=(Student)o1;</p><p>​        Student s2=(Student)o2;</p><p>​        return s2.getAge()-s1.getAge();</p><p>​    }</p><p>}</p><p> e) 静态内部类：</p><p>​    将Age比较器定义成静态内部类</p><p>​    static class AgeComparator extends Comparator{</p><p>​    public int compare</p><p>​            (Object o1,Object o2){</p><p>​        Student s1=(Student)o1;</p><p>​        Student s2=(Student)o2;</p><p>​        return s2.getAge()-s1.getAge();</p><p>​    }</p><p> f) 局部内部类</p><p>   将Age比较器定义成局部内部类</p><p>   public void d(){</p><p>​    </p><p>​    class AgeComparator extends Comparator{</p><p>​    public int compare</p><p>​            (Object o1,Object o2){</p><p>​        Student s1=(Student)o1;</p><p>​        Student s2=(Student)o2;</p><p>​        return s2.getAge()-s1.getAge();</p><p>​    }</p><p>}</p><p> g) 匿名内部类</p><p>   将Age比较器定义成匿名内部类</p><p>public void e(){</p><p>​    new Comparator{</p><p>​    public int compare</p><p>​            (Object o1,Object o2){</p><p>​        Student s1=(Student)o1;</p><p>​        Student s2=(Student)o2;</p><p>​        return s2.getAge()-s1.getAge();</p><p>​    }</p><p>};</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十七天笔记</title>
      <link href="/2018/10/18/index17/"/>
      <url>/2018/10/18/index17/</url>
      
        <content type="html"><![CDATA[<p>三：抽象类 abstract class===&gt;有得有失<br> a)抽象方法<br>  作用：定义了一个规范<br>  如果一个方法没有实现就必须定义成抽象方法。<br>  抽象方法用来描述系统具有什么功能，<br>  但不提供具体的实现<br> b)抽象类<br>  1)如果一个类中有抽象方法就必须定义成抽象类。<br>    抽象类中不一定有抽象方法。<br>  2)抽象类中也可以包含非抽象方法<br>  3)抽象类中也可以定义实例变量<br>  4)抽象类中也可以定义构造器，<br>    但是没有抽象构造方法，也没有抽象静态方法；<br>  5)抽象类可以包含多个抽象方法。<br>  6)抽象类的作用是提供给其他的子类来进行继承的。<br>  7)继承抽象类必须实现抽象类中的所有抽象方法。<br>    或者将子类也定义成抽象类。<br>  8)抽象类不能被实例化，构造器给创建子类对象用的。<br>  9)抽象类及抽象方法不能被final修饰符修饰<br>c)作用：当不知道方法的具体实现的时候就可以定义<br>   成抽象方法。让子类去实现该方法，完成自己的实现。</p><p>练习：定义比较器Comparator。比较器比较两个对象谁大谁小。<br>      但是真正用什么比较，是由调用者决定的。<br>      所以就需要定义一个比较的规则，即抽象方法。<br>  比较一个Team团队中最大或者最小人。<br>  根据年龄的大小来查找。<br>  根据名字的长度来查找。<br>  public void testComparator(){<br>List<products> products=new ArrayList<products>();<br>products.add(new Products(“费罗列”,100,30));<br>products.add(new Products(“love”,1000,100));<br>products.add(new Products(“德芙”,10000000,10));<br>products.add(new Products(“自行车”,10000,899));<br>products.add(new Products(“行李箱”,8000,569));<br>products.add(new Products(“泳衣”,100,180));<br>//定义比较器 按价格降序<br>Comparator<products> byPrice=new Comparator<products>() {<br>@Override<br>public int compare(Products o1, Products o2) {<br>return  o1.getPrice()&lt;o1.getPrice()?-1:o1.getPrice()&gt;o2.getPrice()?1:0;<br>}<br>};</products></products></products></products></p><p>//定义比较器 按销量降序<br>Comparator<products> byNum=new Comparator<products>() {<br>@Override<br>public int compare(Products o1, Products o2) {<br>return  o1.getNum()&lt;o2.getNum()?-1:o1.getNum()&gt;o2.getNum()?1:0;<br>}<br>};<br>一. 接口<br>1.接口使用的目的：<br>   a)定义规范的<br>   b)解决多重继承问题；例如Fish类继承Animal类，<br>                表明Fish是一种动物，但鱼同样也是一种食物，<br>        如何表示这种关系呢？ 由于Java语言不支持一<br>        个类有多个直接的父类，因此无法用继承关系来<br>        描述鱼既是一种食物，又是一种动物，为了解决<br>        这一问题，Java语言引入接口类型，简称接口。<br>        一个类只能有一个直接的父类，但是可以实现多<br>        个接口。采用这种方式，Java语言对多继承提供<br>        了有力的支持。<br>2.面试题：<br> C,C++是多继承，但Java是单继承？是不是<br> 说Java语言在继承的层面上是不是退步了？<br>  多继承不好的地方：造成代码的浪费<br>            引发继承的多义性<br>   Java使用接口完成多继承的功能。<br>   使用接口可以一个项目多个功能同时开发。<br>3.接口的内容:<br>   a)接口是抽象类的另外一种形式<br>     接口是抽象类的抽象，<br>     抽象类可存在有方法体的方法，<br>     接口中的方法全部为抽象方法；<br>   b)接口中的所有方法均是抽象方法，<br>     默认都是public abstract类型的；<br>   c)接口中的成员变量默认都是public static final类型，<br>     必须被显式初始化；<br>   d)接口中只能包含public static final类型成员变量<br>     和public abstract类型的成员方法；<br>   e)接口中没有构造方法，不能被实例化。<br>   f)接口可以继承多个接口<br>   g)一个类只能继承一个直接的父类，但能实现多个接口。<br>   h)接口告诉程序员做什么事情，不管怎么做。<br>    定义规范，描述该接口有哪些功能。</products></products></p><p>   抽象类和接口比较：</p><pre><code>1. 相同点：   a. 都不能被实例化；   b. 都能包含抽象方法；2. 不同点；   a. 抽象类中可以为部分方法提供默认的实现，   从而避免子类中重复实现它们，提高代码的可   重用性，而接口中只能包含抽象方法；   b. 一个类只能继承一个直接的父类，这个父   类有可能是抽象类；但一个类可以实现多个接口   ，这是接口的优势所在。</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十五天笔记</title>
      <link href="/2018/10/18/index16/"/>
      <url>/2018/10/18/index16/</url>
      
        <content type="html"><![CDATA[<p>一:Static<br>  1)修饰变量(只能修饰实例变量)—–&gt;静态变量<br> 比如:每次闯关游戏的总分数，应该是第一次闯关<br> 的分数+第二次闯关的分数+第三次闯关方法….<br> 这个时候就需要使用static去保存了。<br>     a)所有类实例共享<br>     b)使用静态变量<br>      类名.变量名<br>     c)静态变量是属于这个类<br>       非静态变量是属于对象<br>     d)代码加载到内存静态变量就存在<br>     e)static变量和实例变量的区别：<br>          i)static变量对于每个类而言在内存中只有一个，能被类的所有实例所共享；<br>                实例变量对于每个类的每个实例都有一份，它们之间互不影响；<br>         ii)Java虚拟机在加载类的过程中为static变量分配内存，<br>                 实例变量在加载完类后创建对象时分配内存；<br>         iii)static变量存在方法区，实例变量存在堆区；<br>         v)static变量可以直接通过类名访问，<br>       实例变量通过引用类型变量访问；<br>   2)修饰方法====&gt;静态方法<br>     a)调用时使用<br>        类名.方法名();<br>     b)静态方法不能使用非静态的变量<br>       静态方法在类加载的时候就存在了<br>       非静态变量在对象创建的时候才存在的<br>       非静态方法可以访问静态变量<br>     c)静态方法不能被非静态方法重写<br>       静态方法不能被静态方法重写<br>     d)静态方法用来表示某个类所特有的功能，<br>       这种功能的实现不依赖于类的具体实例，也不依赖于它的子类.<br>       既然如此，当前类必须为静态方法提供实现。<br>       静态方法属于类<br>     e)不能使用this关键字和super关键字；</p><p>   3)静态初始化块—-在类加载时只执行一次<br>     对静态变量进行初始化，当Java虚似机加载类时，就会执行该代码块；<br>      被static所修饰的成员变量和成员方法表明归某个类所有，它不依赖<br>      于类的特定实例，被类的所有实例共享。只要这个类被加载，<br>      Java虚拟机就能根据类名在运行时数据区的方法区内定位到它们。<br>      static{}<br>   4)普通初始化—-每创建一个对象都会被调用的<br>     对非静态变量进行初始化，<br>      {}<br>整个运行的过程中，某一个类只能够有一个对象</p><p>   5)静态导入<br>import java.lang.Math;<br>     使用：Math.random()</p><p>import static java.lang.Math.*;<br>    使用：random()</p><p>二：final<br>  1)修饰变量—-&gt;常量<br>      变量必须初始化，变量的值不允许修改。<br>       final变量都必须显示初始化，<br>         a) 修饰静态变量，只能在定义变量时进行初始化；<br>         b) 修饰实例变量，可以在定义变量时进行初始化，<br>         或者在构造方法中进行初始化；<br>  2)修饰方法<br>      该方法不能够被重写<br>      final 加密(){} 不允许被重写<br>      final 解密(){} 不允许被重写<br>  3)修饰类<br>      该类不能够被继承<br>         String类就是final修饰的类</p><p>第五章：面向对象编程</p><p>\1. 实现多态需要注意什么？</p><p>同一领域(继承同一个类或者实现同一个接口)的不同的对象调用的相同的方法表现不同</p><p>   完成多态需要满足两个条件：</p><p>​     1)父类的引用指向子类的对象</p><p>​     2)子类需要重写父类的方法</p><p>\2. instanceof的关键字的作用</p><p>  instanceof判断该对象是否是该类的实例或者该类的子类的实例</p><p>​     转换规则：被转换的实际对象一定是转换后类型的自身或子类</p><p>\3. 方法重载和方法重写的区别</p><p>重写</p><p>  a)重写方法必须发生在子父类中</p><p>  b)方法的名字必须相同</p><p>  c)参数列表必须相同</p><p>  d)返回值类型必须相同</p><p>  e)可见性可以变大</p><p>​    public &gt; protected &gt;private</p><p>  f)异常不能抛大</p><p>​    Exception&gt;NullPointException</p><p>重载</p><p>  a)方法的重载必须在本类</p><p>  b)方法名字必须相同</p><p>  c)参数列表必须不同</p><p>​       参数的个数不同||</p><p>​       参数的数据类型不同||</p><p>​       参数的顺序不同</p><p>  d)返回值可以不同</p><p>  e)抛出异常可以不同</p><p>  f)访问的修饰符可以不同</p><p>二）扩展实验：</p><p>1.super的作用？</p><p>  a)super用在实例变量上面，很少用</p><p>​    指定父类的实例变量 super.name</p><p>  b)super用在方法中</p><p>​    指定调用父类的方法</p><p>  c)super用在构造器上</p><p>​    调用父类构造器</p><p>​    super(参数列表);</p><p>2.数据类型转换？</p><p>   引用数据类型的转换</p><p>   a)隐式的数据类型转换</p><p>​     子类对象给父类对象做隐式转换</p><p>​     People p1=new Student();</p><p>   b)强制的数据类型转换</p><p>​     父类对象给子类对象做显示转换</p><p>​     Student s1=(Student)p1;</p><p>​     前提必须是能够强转在代码中测试</p><p>​     Teacher t1=(Teacher)p1;//error,强制转换异常</p><p>3.管理研发团队的信息</p><p>class Address{</p><p>​    private String country;</p><p>​    private String city;</p><p>​    private String street;</p><p>}</p><p>class Team{</p><p>​    //学生团队，存放学生对象</p><p>​    private Student[] team;</p><p>​    //研发团队在什么地方</p><p>​    private Address address;</p><p>​    //向团队中添加学生</p><p>​    public void addStudent(Student stu){}</p><p>​    //从团队中删除学生</p><p>​    public void removeStudent(Student stu){}</p><p>​    //从团队中找学生的索引</p><p>​    public int findStudent(Student stu){}</p><p>​    //显示团队中学生的信息</p><p>​    public void display(){}</p><p>}</p><p>\4. 编程：完成exercise文件中的编程作业</p><p> 第六章：高级语言特性</p><p>一）基础实验：</p><p>1)static变量和实例变量的区别?</p><p>​    i)static变量对于每个类而言在内存中只有一个，能被类的所有实例所共享；</p><p>​                实例变量对于每个类的每个实例都有一份，它们之间互不影响；</p><p>​         ii)Java虚拟机在加载类的过程中为static变量分配内存，</p><p>​                 实例变量在加载完类后创建对象时分配内存；</p><p>​         iii)static变量存在方法区，实例变量存在堆区；</p><p>​         v)static变量可以直接通过类名访问，</p><p>​       实例变量通过引用类型变量访问；</p><p>2)编写一个代码计算该类被创建了多少次</p><p>定义一个static int变量每次走类就会相加</p><p>二）作业：</p><p>1.编程</p><p>readme1.txt的作业里面一般都是面试题。能完成就完成</p><p>三)读程序</p><p>1)下面代码输出的结果是：</p><p>public class Test1 {</p><p>​    public static void changeStr(String str){</p><p>​        str=”welcome”;</p><p>​    //System.out.println(str+”111”);</p><p>​    }</p><p>​    public static void main(String[] args) {</p><p>​        String str=”1234”;</p><p>​        changeStr(str);</p><p>​        System.out.println(str);</p><p>​    }</p><p>}</p><p> 1234</p><p>2)下面代码的结果是?（A）</p><p>A. ABDCBDCB</p><p>B. ABCDABCD</p><p>C. Compilation fails.</p><p>D. An exception is thrown at runtime.</p><p>publicclass Test2 {</p><p>​    static boolean foo(char c) {</p><p>​       System.out.print(c);</p><p>​       return true;</p><p>​    }</p><p>​    public static void main(String[] argv) {</p><p>​       int i = 0;</p><p>​       for (foo(‘A’); foo(‘B’) &amp;&amp; (i &lt; 2); foo(‘C’)) {</p><p>​           i++;</p><p>​           foo(‘D’);</p><p>​       }</p><p>​    }</p><p>}</p><p>3)下面哪两个方法满足重写A类方法（A）</p><p>class A {</p><p>protected int method1(int a, int b) { return 0; }</p><p>}</p><p>A. public int method1(int a, int b) { return 0; }</p><p>B. private int method1(int a, int b) { return 0; }</p><p>C. private int method1(int a, long b) { return 0; }</p><p>D. public short method1(int a, int b) { return 0; }</p><p>E. static protected int method1(int a, int b) { return 0; }</p><p>package com.briup.ch17;<br>public class Student extends Person<br>{<br>  private int score;//扩展的属性<br>  public Student(){<br>     this(0);<br>  }<br>  public Student(int score){<br>   setScore(score);<br>  }<br>  public Student(String name,String gender,int age,int score){<br>    super(name,gender,age);<br>    setScore(score);<br>    //this(score);<br>  }</p><p>  public void setScore(int score){<br>     if(score<0 ||="" score="">150)<br>         this.score=0;<br>     else<br>         this.score=score;<br>  }<br>  public int getScore(){<br>    return score;<br>  }<br>  public void display(){<br>    System.out.println(“name:”+getName());<br>    System.out.println(“gender:”+getGender());<br>    System.out.println(“age:”+getAge());<br>    System.out.println(“score:”+score);<br>  }<br>}</0></p><p>package com.briup.ch17;<br>public class Person<br>{<br>    private String name;<br>    private String gender;<br>    private int age;<br>    public Person(){</p><pre><code>}public Person(String name,String gender,int age){    setName(name);    setGender(gender);    setAge(age);}public void setName(String name){   if(name==null)        this.name=&quot;没有名字&quot;;   else       this.name=name;}public String getName(){  return name;}public void setGender(String gender){   this.gender=gender;}public String getGender(){   return gender;}public void setAge(int age){  if(age&lt;0 || age&gt;120)       this.age=0;  else      this.age=age;}public int getAge(){ return age;}</code></pre><p>}</p><p>package com.briup.ch17;<br>public interface InterFaceTest<br>{<br>     int a=0;<br>     public static final int b=10;<br>     /*public InterFaceTest(){//不能有构造器</p><pre><code>}*/public  void add();public static void query(){}</code></pre><p>}<br>interface Aa<br>{<br>}<br>interface Bb extends Aa,InterFaceTest<br>{<br>}<br>class Cc implements Bb,Aa<br>{<br>public  void add(){}<br>}</p><p>package com.briup.ch17;<br>public class FinalTest<br>{<br>    private final int a;<br>    static{</p><pre><code>}public FinalTest(){    a=100;    System.out.println(a);}public  void add(){   final int b;   //System.out.println(b);}public static void main(String... args){new FinalTest();}</code></pre><p>}<br>final class Aa<br>{<br>    public  void add(){</p><pre><code>}</code></pre><p>}<br>class Bb extends Aa<br>{<br>    @Override<br>    public void add(){</p><pre><code>}</code></pre><p>}</p><p>package com.briup.ch17;<br>public abstract class Comparator<br>{<br>    /<em><br>      返回值=0 o1==o2<br>      返回值&gt;0 o1&gt;o2<br>      返回值&lt;0 o1&lt;o2    </em>/<br>    public abstract int compare(Object o1,Object o2);<br>}<br>//年龄比较器<br>class AgeComparator extends Comparator<br>{<br>    public int compare(Object o1,Object o2){<br>        Student s1=(Student)o1;<br>        Student s2=(Student)o2;<br>       return s1.getAge()-s2.getAge();</p><pre><code>}</code></pre><p>}<br>//姓名比较器<br>class NameComparator extends Comparator<br>{<br>    public int compare(Object o1,Object o2){<br>        Student s1=(Student)o1;<br>        Student s2=(Student)o2;<br>       return s1.getName().length()-s2.getName().length();</p><pre><code>}</code></pre><p>}</p><p>package com.briup.ch17;<br>//抽象类<br>public abstract class AbstractTest<br>{<br>    private int a;<br>    public AbstractTest(){<br>    }<br>    //抽象方法<br>    public abstract void add();<br>    //如果不是抽象方法必须去实现<br>    public void delete(){</p><pre><code>}public static void main(String... args){      //AbstractTest at=new AbstractTest();}</code></pre><p>}<br>/<em>abstract class Aa extends AbstractTest<br>{<br>    /</em>public void add(){</p><pre><code>}public void delete(){}public abstract void query();</code></pre><p>}<br>class Bb extends Aa<br>{<br>   public void query(){<br>   }<br>   public void add(){</p><p>   }<br>}*/</p><p>使用接口和抽象类</p><p>练习目标：建立一个动物的层次结构，以抽象类Animal为根，几个动物类将实现接口Pet。类结构如下：</p><p>Animal–abstract    Pet&lt;<interface>&gt;</interface></p><p>#legs:int        +getName()：String</p><p>#Animal(legs:int)    +setName(name:String)</p><p>+walk()                +play()</p><p>+eat()–abstract    </p><p>Cat            Spider</p><p>-name:String        +Spider()         </p><p>+Cat(name:String)        +eat()</p><p>+Cat()                 </p><p>+getName()：String</p><p>+setName(name:String)</p><p>+play()</p><p>+eat()</p><p>Fish</p><p>-name:String</p><p>+Fish()                 </p><p>+getName()：String</p><p>+setName(name:String)</p><p>+play()</p><p>+walk()</p><p>+eat()</p><p>任务1：创建Animal类，它是所有动物类的抽象超类</p><p>public abstract class Animal{</p><p>public int legs;</p><p>public Animal(int legs){</p><p>this.legs=legs;</p><p>}</p><p>protected void walk(){</p><p>System.out.println(“This animal walks on “ + legs + “ legs.”);</p><p>}</p><p>protected abstract void eat();</p><p>任务2：创建Spider类，继承Animal类</p><p>public class Spider extends Animal{</p><p>public Spider(){</p><p>super(8);</p><p>}</p><p>public void eat(){</p><p>System.out.println(“Spiders catch flies in their webs to eat.”);</p><p>}</p><p>}</p><p>任务3：创建Pet接口</p><p>public interface Pet{</p><p>public abstract String getName();</p><p>void setName(String name);</p><p>public void play();</p><p>}</p><p>任务4：创建Cat类，继承Animal类并实现Pet接口</p><p>public class Cat extends Animal implements Pet{</p><p>private String name;</p><p>public Cat(String name) {</p><p>super(4);</p><p>this.name = name;</p><p>}</p><p>public Cat() {</p><p>this(“”);</p><p>}</p><p>public String getName(){</p><p>return name;</p><p>}</p><p>public void setName(String name){</p><p>this.name=name;</p><p>}</p><p>public void play(){</p><p>System.out.println(name + “ likes to play with string.”);</p><p>}</p><p>public void eat(){</p><p>System.out.println(“Cats like to eat spiders and mice.”);</p><p>}</p><p>} </p><p>任务5：创建Fish类，继承Animal类并实现Pet接口</p><p>public class Fish extends Animal implements Pet{</p><p>private String name;</p><p>public Fish(){</p><p>super(0);</p><p>}</p><p>public String getName(){</p><p>return name;</p><p>}</p><p>public void setName(String name){</p><p>this.name=name;</p><p>}</p><p>public void play(){</p><p>System.out.println(“Fish swim in their tanks all day.”);</p><p>}</p><p>public void walk(){</p><p>super.walk();</p><p>System.out.println(“Fish, of course, can’t walk; they swim.”);</p><p>}</p><p>public void eat(){</p><p>System.out.println(“Fish eat pond scum.”);</p><p>}</p><p>}</p><p>任务6：使用TestAnimals类测试代码</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十五天笔记</title>
      <link href="/2018/10/18/index15/"/>
      <url>/2018/10/18/index15/</url>
      
        <content type="html"><![CDATA[<p>三：多态 （面向接口的编程，统一接口的编程）<br>   概念：同一领域中的不同对象调用相同的方法表现不一样<br>Person p=new Student();<br>静态数据类型：变量申明时候的类型<br>动态数据类型：创建对象时的数据类型<br>对象真正的数据类型是动态数据类型决定的，运行时数据类型</p><p>实现多态必须满足什么条件：<br>    1)子类必须重写父类中的方法<br>    2)父类的引用指向子类的对象</p><p>四：方法的重写<br>   条件：当父类的方法不能够满足子类方法的需求。<br>        就可以对父类的方法进行重写<br>   1)发生在子父类<br>   2)方法名必须相同 &amp;&amp;<br>     参数列表必须相同 &amp;&amp;<br>     返回值类型必须相同<br>  3)可见性(访问修饰符)不能变小<br>  4)异常不能扩大</p><p>五：数据类型转换<br>  1) 先使用instanceof 识别类型<br>  2) 子类型隐式地扩展到父类型（自动转换）<br>  3) 父类型必须显式地缩小到子类型</p><p> 转换规则：被转换的实际对象类型一定是转换以后类型的自身或者子类。</p><p>instanceof:数据类型转换之前进行判断该对象是否是该类的实例</p><p>六:对象与对象的关系<br>is a:继承关系<br>has a:包含关系(组合，聚合)<br>use a:使用关系(参数传递时)</p><p>组合：整体和部分同时存在同时消亡<br>      创建整体对象的时候，将部分对象一起创建。<br>     人和手就是组合关系<br>聚合：整体和部分不是同时存在不是同时消亡<br>     人和电脑就是聚合关系<br>     人和地址也是聚合关系</p><p>组合关系：比如A类中包含B类的一个引用b,当A类的一个对象消亡时，<br>b这个引用所指向的对象也同时消亡。<br>聚合关系：反之b所指向的对象还会有另外的引用指向它。</p><p>现实生活中，人和手，脚是组合关系，因为当人死后<br>             手和脚就不复存在了。<br>         人和电脑就是聚合的关系</p><p>class Hand{}<br>class Computer{}<br>组合:<br>class Person{<br>    private Hand hand;<br>    public Person(){<br>       hand=new Hand();<br>    }<br>}<br>聚合:<br>class Person{<br>    private Computer computer;<br>    public setComputer(){<br>        computer = new Computer();<br>    }<br>}</p><p>组合聚合的区别和联系：<br> 1)整体与部分的关系：组合的关系更强一些。对于组合<br> 来说，如果失去整体，部分将不存在了。<br> 2)代码实现来看：组合在整体的构造器中实例化部分，<br> 这个部分不能被其他实例共享。整体和部分的生命周期<br> 是同步的。而聚合关系的部分，可以在构造器中通过<br> 参数传递的形式进行初始化。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十四天笔记</title>
      <link href="/2018/10/18/index14/"/>
      <url>/2018/10/18/index14/</url>
      
        <content type="html"><![CDATA[<p>八. 创建和初始化对象(new)<br>Person p=new Person();<br>public class Person{<br>    private String name=”briup”;<br>}<br>  1)在栈区开辟空间保存对象的引用<br>  2)在堆区开辟空间保存对象本身的数据<br>  3)堆区的地址赋值给栈区的对象的引用<br>  4)为对象的属性进行默认初始化(系统完成)<br>  5)为对象的属性进行显示初始化，比如人的最大年龄100<br>  6)调用普通代码块{}<br>  7)调用构造器</p><p>九. 构造方法<br>    构造器：根据用户的需求传入数据,<br>            然后根据传入数据进行属性的初始化。<br>       作用：为属性进行初始化<br>    1）方法名和类名相同<br>    2）没有返回值类型<br>    3）构造的重载(根据不同的情况调用不同的构造器进行相应的初始化)<br>        调用本类的构造器:this(参数列表)<br>    4)系统会提供一个无参的构造器，<br> 但是如果本类实现了其他的构造器，系统提供的无参构造器失效。<br>public class Test{<br>  public Test(){}<br>  public void Test(){} //普通的方法<br>}<br>一：继承<br>好处：代码复用，简化编程<br>代码复用用在哪些地方：<br>   1)复用父类的属性<br>   2)复用父类的方法(直接调用父类的方法)<br>   3)重写父类的方法<br>实现：class 子类 extends 父类<br>     单继承<br>关系：子类 is a 父类  或者 子类is a like 父类<br>     class Student extends Person<br>      student is a Person<br>      Person is a Student（error）<br>子类继承父类哪些：<br>    1）构造器不能继承<br>    2）方法和属性全部继承</p><p>继承注意的问题：<br>   1)创建一个子类对象必须先创建一个父类对象<br>   2)子类的构造器会默认调用父类的无参构造器<br>       super();<br>   3)父类的无参构造器失效，<br>   子类构造器就需要显式的调用父类存在的其他构造器<br>       super(参数列表); 必须放在构造器的第一行<br>   4)当一个子类继承了一个父类后，<br>    父类中所有的字段和方法都被子类继承拥有，<br>    子类可以任意的支配使用，<br>    每个子类对象中都拥有了父类中的所有字段。<br>    当构造一个子类的实例对象时，<br>    该对象的实例变量包括了子类本身以及父类中的所有实例变量，<br>    实例方法也包括了子类和父类中的所有实例方法。<br>    子类构造器用来初始化子类中所有的实例变量，<br>    而父类构造器super(实参)用来初始化父类中所有的实例变量。<br>    那么在堆中为子类实例对象分配的内存区域中<br>    包括了子类和父类中所有初始化后的实例变量。<br>   5)在构造器同时出现this和super:不能够。</p><p>二：super代表父类对象<br>    this代表当前对象<br> 1)调用父类的属性(很少用)<br>     super.name=name;<br> 2)调用父类的构造器<br>    super(参数列表);<br> 3）调用父类的方法(子类中包含和父类相同的方法名)<br>    super.方法名(参数列表);</p><p>package com.briup.ch14;<br>public class OverloadTest<br>{<br>    String s;<br>    int a;<br>    //无参构造器，如果没有有参构造器，系统会默认创建,构造器是不能被当成方法调用<br>    public  OverloadTest(){<br>     this(“张三”);<br>    }<br>    public  OverloadTest(String s){<br>        this(s,10);<br>     //this.s=s;</p><pre><code>}public OverloadTest(String s,int a){this.s=s;this.a=a;}public void setS(String s){this.s=s;}public String getS(){   return s;}public void setA(int a){this.a=a;}public int getA(){  return a;}public static void main(String... args){     OverloadTest ot=new OverloadTest();       System.out.println(ot.getS());       System.out.println(ot.getA());     //ot.add(&quot;哈哈&quot;,5,4);     //System.out.println(ot.add(&quot;讲解&quot;,4));     //ot.OverloadTest();}public void add(String a,int b,int c){System.out.println(&quot;第一个:&quot;+a);}private int add(String a,int b){  return b;}</code></pre><p>}</p><p>package com.briup.ch14;<br>public class People<br>{<br>    private String name;<br>    private String gender;<br>    private int age;<br>    public People(){<br>      this(“李四”,”女”,20);<br>      System.out.println(“这是父类构造器”);<br>    }<br>    public People(String name,String gender,int age){<br>      this.name=name;<br>      this.gender=gender;<br>      this.age=age;<br>    }<br>    public void setName(String name){<br>    this.name=name;<br>    }<br>    public String getName(){<br>    return name;<br>    }<br>    public void setGender(String gender){<br>     this.gender=gender;<br>    }<br>    public String getGender(){<br>    return gender;<br>    }<br>    public void setAge(int age){<br>    this.age=age;<br>    }<br>    public int getAge(){<br>     return age;<br>    }<br>    public void display(){<br>    System.out.println(name);<br>    System.out.println(gender);<br>    System.out.println(age);<br>    }<br>}</p><p>package com.briup.ch14;<br>public class Student extends People<br>{<br>        /<em>private String name;<br>    private String gender;<br>    private int age;</em>/<br>    private int score=90;<br>    public Student(){<br>      //this(“王五”,”男”,20,80);<br>      //setName(“赵四”);<br>      System.out.println(“这是子类构造器”);<br>    }<br>    public Student(String name,String gender,int age,int score){<br>      /<em>this.name=name;<br>      this.gender=gender;<br>      this.age=age;</em>/<br>      this.score=score;<br>    }<br>    public void setScore(int score){<br>    this.score=score;<br>    }<br>    public int getScore(){<br>     return score;<br>    }<br>    /<em>public void setName(String name){<br>    this.name=name;<br>    }<br>    public String getName(){<br>    return name;<br>    }<br>    public void setGender(String gender){<br>     this.gender=gender;<br>    }<br>    public String getGender(){<br>    return gender;<br>    }<br>    public void setAge(int age){<br>    this.age=age;<br>    }<br>    public int getAge(){<br>     return age;<br>    }</em>/<br>    public void display(){<br>    /<em>System.out.println(name);<br>    System.out.println(gender);<br>    System.out.println(age);</em>/</p><pre><code>System.out.println(&quot;name=&quot;+getName());System.out.println(&quot;gender=&quot;+getGender());System.out.println(&quot;age=&quot;+getAge());System.out.println(score);}</code></pre><p>}</p><p>package com.briup.ch14;<br>public class Test<br>{<br>    public static void main(String… args){<br>       /<em>People p=new People();<br>       p.display();</em>/<br>       Student s=new Student();<br>       s.display();<br>    }<br>}</p><p>第五章：面向对象编程</p><p>一）基础实验：</p><p>1.完成Person.java,PersonTest.java完成面向对象编程的基本步骤。</p><p>2.完成参数传递的例子.明白参数传递的两种方式</p><p>  ParameterTest.java</p><p>3.完成数据隐藏的例子</p><p>  Person.java PersonTest.java</p><p>4.完成构造器的例子</p><p>  Person.java PersonTest.java</p><p>5.完成Person.java,Student.java,Teacher.java，Test.java继承的例子。</p><p>二）扩展实验：</p><p>\1. 什么是构造器及其作用</p><p>   构造器：根据用户的需求传入数据,</p><p>​            然后根据传入数据进行属性的初始化。</p><p>​       作用：为属性进行初始化</p><p>​    1）方法名和类名相同</p><p>​    2）没有返回值类型</p><p>​    3）构造的重载(根据不同的情况调用不同的构造器进行相应的初始化)</p><p>​        调用本类的构造器:this(参数列表)</p><p>​    4)系统会提供一个无参的构造器，</p><p> 但是如果本类实现了其他的构造器，系统提供的无参构造器失效。</p><p>\2. 方法重载有什么特点？定义几个重载方法和非重载方法？</p><p>​    1.方法的重载必须在本类</p><p>​    2.方法名字必须相同</p><p>​    3.参数列表必须不同</p><p>​        参数的数据类型不同||</p><p>​    参数的顺序不同||</p><p>​    参数的个数不同 </p><p>​    4.返回值可以不同</p><p>​    5.抛出异常可以不同</p><p>​    6.修饰符可以不同</p><p>3.this的作用？</p><p>   this 代表当前对象</p><p>​     this用法:</p><p>​      a)this一般用在实例变量上</p><p>​        用来区分实例变量和局部变量</p><p>​    实例变量和局部变量相同名字的时候</p><p>​     this.name=name; 如果没有this，会执行就近原则，指代的就会是形参</p><p>​      b)this用在调用本类方法(不常用),系统会默认添加上去 this.setName(“”);</p><p>​      c)this调用本类构造器</p><p>\4. 子类继承了父类哪些东西，哪些东西不被继承？继承的关系？</p><p>​    a)子类继承父类的属性和方法，还可以扩展自己的属性和方法</p><p>​    b)子类不能够继承父类构造器</p><p>\5. 编程：完成所有的exercise文件中的编程作业</p><p> package ex.md05;</p><p>public class Test<br>{<br>    public static void main(String[] args)<br>    {<br>        Stack stack = new Stack();<br>        //stack.pop();<br>        for(int i=1; i&lt;=200; i++){<br>            stack.push(i);<br>        }<br>        for(int i=1; i&lt;=100; i++){<br>            System.out.println(“pop:” + stack.pop());<br>        }<br>        for(int i=201; i&lt;=300; i++){<br>            stack.push(i);<br>        }<br>        for(int i=1; i&lt;=200; i++){<br>            System.out.println(“pop:” + stack.pop());<br>        }</p><pre><code>    Queue queue = new Queue();    //queue.out();    for(int i=1; i&lt;=200; i++){        queue.in(i);    }    for(int i=1; i&lt;=100; i++){        System.out.println(&quot;out:&quot; + queue.out());    }    for(int i=201; i&lt;=300; i++){        queue.in(i);    }    for(int i=1; i&lt;=200; i++){        System.out.println(&quot;out:&quot; + queue.out());    }}</code></pre><p>}</p><p>package ex.md05;</p><p>public class Driver {<br>    public static void main(String[] args) {<br>        Track myTrack = new Track();<br>        myTrack.setTitle(“Watching The Wheels”);</p><pre><code>    //Duration myDuration = new Duration(234);    Duration myDuration = new Duration(0, 3, 48);    myTrack.setDuration(myDuration);    System.out.println(&quot;myTrack is: &quot; + myTrack);            System.out.println(&quot;Title = &quot; + myTrack.getTitle());    System.out.println(&quot;Duration = &quot; + myTrack.getDuration().toString());}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十三天笔记</title>
      <link href="/2018/10/18/index13/"/>
      <url>/2018/10/18/index13/</url>
      
        <content type="html"><![CDATA[<p>五. this关键字:当前对象<br>    1)区分实例变量和局部变量<br>    this.name=name;<br>    2)调用本类的构造器<br>       this(参数列表);<br>    3)调用本类的方法<br>       this.方法名()</p><p>六. 数据隐藏<br>  好处：防止外界进行非法修改<br>  如何实现：1)数据的访问修饰符private<br>            2)提供统一的操作(属性的set,get)<br>  数据隐藏就是封装的一个方面，封装的另一个方面隐藏方法。</p><p>七. 方法重载<br>   对于类的方法(包括从父类中继承的方法),<br>   如果有两个方法的方法名相同，但参数不一致，<br>   那么可以说，一个方法是另一个方法的重载方法。<br>   这种现象叫重载。<br>   方法的重载满足的条件：<br>   1)在同一个类中<br>   2)方法名相同<br>   3)参数列表不相同<br>        a)参数个数不相同 ||<br>        b)参数类型不相同 ||<br>        c)参数列表的顺序不相同<br>   4)返回值类型可以不同<br>   5)访问修饰符可以不同</p><pre><code>在一个类中不允许定义两个方法名相同，并且参数签名也完全相同的方法。因为假如存在这样的两个方法，Java虚拟机在运行时就无法决定到底执行哪个方法。参数签名是指参数的类型、个数和顺序。</code></pre><p>package com.briup.ch13;<br>public class Test<br>{<br>  int b;//全局变量或者实例变量<br>  //Student s;<br>   Student s;<br>    public static void main(String… args){<br>        Test t=new Test();<br>        s=new Student();<br>         System.out.println(s+10);<br>        t.add();</p><pre><code>}public void add(){    //s=dao.select();   int a;//局部变量   a=10;   //System.out.println(id);   //System.out.println(b);  // update(s);}/*public void update(Student s){  dao.update(s);}*/</code></pre><p>}</p><p>package com.briup.ch13;<br>public class FengTest<br>{<br>    public static void main(String… args){<br>       ThisTest tt=new ThisTest();<br>       //tt.name=null;<br>       tt.setName(null);<br>       //System.out.println(tt.name);<br>       System.out.println(tt.getName());<br>    }<br>}</p><p>package com.briup.ch13;<br>public class ThisTest<br>{<br>    private String name;<br>    private int age;<br>    public ThisTest(){<br>     //name=”zhangsan”;<br>     // setName(“zhangsan”);<br>    }<br>    public void setName(String name){</p><pre><code>    if(name==null){    this.name=&quot;没有名字&quot;;    }else{    this.name=name;    }}public String getName(){return name;}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十二天笔记</title>
      <link href="/2018/10/18/index12/"/>
      <url>/2018/10/18/index12/</url>
      
        <content type="html"><![CDATA[<p>java第十二天笔记</p><h2 id="一-OOP中的基本概念"><a href="#一-OOP中的基本概念" class="headerlink" title="一. OOP中的基本概念"></a>一. OOP中的基本概念</h2><p>​    Java的编程语言是面向对象的，采用这种语言进行编程称为<br>面向对象编程(Object-Oriented Programming, OOP)， 它允许设<br>计者将面向对象设计实现为一个可运行的系统。Java的编程单位<br>是类，对象最后要通过类进行实例化(即“创建”)。<br>面向对象编程有三个特性：封装，继承，多态的概念<br>封装：对类中的属性和方法的具体实现进行封装（隐藏）<br>      外界不可见<br>继承：继承父类中的属性和方法 extends<br>      class 子类 extends 父类<br>      都是单继承<br>多态：同一个领域中(继承同一个类或者实现同一个接口)的不同对象调用相同的方法表现不同<br>class 鸟 implments Common{<br>   public void fly(){<br>    …..<br>  }<br>}<br>class 飞机 implments Common{<br>    public void fly(){<br>    …..<br>  }<br>}</p><p>二. 类和对象<br>   类是具有相同属性和行为的对象的集合。<br>   对象是类的具体化，对象是唯一的。<br>   面向对象的开发方法把软件系统看成各种对象的集合，<br>   对象就是最小的子系统，一组相关的对象能够组合成<br>   更复杂的子系统。面向对象的开发方法将软件系统看<br>   成各种对象的集合，接近人的自然思维方式。</p><pre><code>对象是对问题领域中事件的抽象。对象具有以下特性：1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。    例如学生，成绩单、教师、课和教室。2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。3) 对象具有属性和行为。   例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。   小张的属性包括姓名、性别、年龄、身高和体重，   行为包括学习、唱歌。   例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。   这部手机的属性包括品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，   打电话call()，收发短信receiveMessage()和发短信sendMessage().4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。   对象的某些行为会改变对象自身的状态，即属性的取值。   例如小张本来体重为40kg，经为减肥后，体重减35kg.    肥胖状态: 40kg          |          | 减肥行为          |                 肥胖状态: 35kg 5) 每个对象都是某个类的实例。小张和小王都属于学生类、中国和美国都属于国家类、中文和英文都属于语言类。同一个类的所有实例都有相同属性，但属性取值不一事实上相同，但是它们的状态不一定相同。例如小张和小王都属于学生类，都有姓名、性别、年龄、身高和体重这些属性，但是他们的属性取值不同。同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。类是一组具有相同属性和行为对象的模板。面向对象编程的主要任务就是定义对象模型中的各个类。   1) 类是一种类型：是引用类型；2) 类是元数据：描述数据的数据，数据在面向对象领域里以对象的形式存在，类是对象共有属性和方法的抽象描述。Java程序是各种对象相互交互作用、而不是类。举例：1) 早上到公司上班，在电梯中碰到总经理我们会说，张总早或王总早，会不会说人早呀！那非得把你抄鱿鱼不可。2) 我们要看电视，是买台电视机，而不是买制作电视机的模具；在java中，类的申明和实现在同一时间，而且必须在一起，前面我们已经做过很多的例子。在C++中，类的申明和实现可以被分开，不知道也没有关系，这只是让我们了解下两者的区别。</code></pre><p>三. 定义方法形式<br>格式： 修饰符s 返回类型 方法名（参数列表）异常抛出类型{方法体}</p><pre><code>参数列表：传入数据返回值类型：传出数据的类型          没有返回值，必须写void修饰符：访问修饰符public,private或者static,final。       没有优先级</code></pre><p>四. 参数传递：实参传递给形参<br>   形参：方法声明时的参数<br>   实参：方法调用时传递的参数<br>1）值传递：传递的是数值<br>          参数是基本数据类型的时候，采用值传递<br>2）地址传递：传递的是地址<br>          参数是引用数据类型的时候，采用地址传递</p><p>package ex.md04;</p><p>public class Teacher<br>{<br>    public int id;<br>    public String name;<br>    public double salary;<br>    public int clRoomId;<br>    public int age;</p><pre><code>public Teacher(){}public Teacher(int id, String name, double salary, int clRoomId, int age){    this.id = id;    this.name = name;    this.salary = salary;    this.clRoomId = clRoomId;    this.age = age;}public void print(){    System.out.println(&quot;---- Teacher ----&quot;);    System.out.println(&quot;id:&quot; + this.id);    System.out.println(&quot;name:&quot; + name);    System.out.println(&quot;salary:&quot; + salary);    System.out.println(&quot;classroom id:&quot; + clRoomId);    System.out.println(&quot;age:&quot; + age);}</code></pre><p>}</p><p>package ex.md04;</p><p>public class Classroom<br>{<br>    public Teacher teacher;                        //保存教师<br>    public Student[] students = new Student[40];//保存学生<br>    public int index = 0;                        //保存学生数量<br>    int i,j;<br>    public Teacher getTeacher(){<br>        //返回教室中的教师<br>        return teacher;<br>    }</p><pre><code>public Student[] getStudents(){    return students;    //返回所有的学生}public void setTeacher(Teacher tea){    //更换教师    this.teacher=tea;}public void addStudent(Student stu){    //增加学生    if (index&lt;40) {        students[index]=stu;    }else {        //复制一下数组         Student[] ss=new Student[index*2];         System.arraycopy(students, 0, ss, 0,students.length);         students=ss;         students[index]=stu;    }    index++;}public boolean removeStudent(int idx){    //删除学生    if (idx&gt;students.length-1) {        return false;    } else {        for (i=0;i&lt;students.length;i++){              if (i==idx){               break;              }            }            if(i&lt;students.length){             if(i &lt;=students.length-2){               for(j=i;j&lt;students.length-1;j++){                students[j]=students[j+1];               }               Arrays.copyOf(students, students.length-1);             /*for (int k = 0; k &lt; students.length; k++) {                System.out.println(students[k].id);            }*/           }            }        return true;    }}public int getStudentNum(){    return index;    //返回教室中学生的数量}public void print(){    //输出当前教室中的教师和学生的信息    teacher.print();    for (int i = 0; i &lt; students.length-1; i++) {        students[i].print();    }}</code></pre><p>}</p><p>package ex.md04;</p><p>public class ClassroomTest<br>{<br>    public static void main(String[] args)<br>    {<br>        //创建Classroom对象<br>        Classroom cr=new Classroom();</p><pre><code>    //创建Teacher对象，并将Teacher分配到Classroom中    Teacher tc=new Teacher(1,&quot;tt&quot;,1000.30,20,30);    cr.setTeacher(tc);    //创建3个Student对象，并将Student分配到Classroom中    Student st1=new Student(0, &quot;tom1&quot;,12);    Student st2=new Student(1, &quot;tom2&quot;,13);    Student st3=new Student(2, &quot;tom3&quot;,14);    cr.addStudent(st1);    cr.addStudent(st2);    cr.addStudent(st3);    //调用Classroom中的其它方法，测试方法的业务逻辑是否准确    //cr.print();   /* boolean b = cr.removeStudent(50);    System.out.println(b);*/    int num = cr.getStudentNum();    System.out.println(num);}</code></pre><p>}</p><p>package ex.md04;</p><p>public class Student<br>{<br>    public int id;<br>    public String name;<br>    public int age;</p><pre><code>public void print(){    System.out.println(&quot;------ Student ------&quot;);    System.out.println(&quot;id:&quot; + id);    System.out.println(&quot;name:&quot; + name);    System.out.println(&quot;age:&quot; + age);}public Student(int sId, String sName, int sAge){    id = sId;    name = sName;    age = sAge;}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十一天笔记</title>
      <link href="/2018/10/18/index11/"/>
      <url>/2018/10/18/index11/</url>
      
        <content type="html"><![CDATA[<p>二维数组（随机点名系统，学生的位置x,y）<br>   存放一维数组的数组<br>   int[][] a = new int[2][3];<br>   a[0].length<br>   a.length</p><p>   int[][]<br>   int[][][]<br>a)管理学生寝室<br>   管理每层楼学生的信息<br>   MultiArray.java<br>b)输出方正矩形：<br>  0 2 2 2 2 2<br>  1 0 2 2 2 2<br>  1 1 0 2 2 2<br>  1 1 1 0 2 2<br>  1 1 1 1 0 2<br>  1 1 1 1 1 0</p><p>c)输出10行杨辉三角<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>…………</p><p>锯齿形数组</p><p>3)System.arraycopy()<br>    数组的长度一旦定义了，就无法修改。<br>    所以需要arraycopy()来重新分配一个新的数组，<br>    然后将其内容拷贝进去。<br>   int[] a = new int[5];<br>   int[] b = new int[5];<br>   a=b与System.arraycopy(a,0,b,0,5)有什么区别？</p><p>   a=b是将数组b的值赋值给a数组<br>　　　System.arraycopy(a,0,b,0,5)是将a数组的值都copy到b数组中。　　　</p><p>   比如说我将a[1]=2;请问b[1]的值是多少？</p><p>如果是a=b则，b[1]=2（b1也随着改变）<br>如果是System.arraycopy(a,0,b,0,5)则，b[1]=数组b[1]的初始值，不会改变</p><p>4)使用数组模拟队,先进先出<br>   1/3的需求分析<br>   1/3的coding<br>   1/3的测试<br> class Queue(){<br>      //入队<br>      void add(int value){}<br>      //出队<br>      int remove(){}<br>      //当前队中元素个数<br>      int size()<br>      //输出类型<br>      void print()<br> }</p><p> class Student{}是以属性为主的类<br> class Queue{}是以方法为主的类</p><p>package com.briup.ch11;<br>import java.util.*;<br>public class Array<br>{<br>    public static void main(String… args){<br>    int[] array=new int[]{10,3,198,98,23};<br>     Arrays.sort(array);<br>     for(int i=0;i&lt;array.length;i++){<br>     System.out.print(array[i]+” “);<br>     }<br>    }<br>}</p><p>package com.briup.ch11;<br>public class ArrayTest<br>{<br>    public static void main(String… args){<br>       //printFang();<br>       printYang();<br>    }<br>    //输出二维数组<br>    public static void out(int[][] array){<br>     for(int i=0;i&lt;array.length;i++){<br>      for(int j=0;j&lt;array[i].length;j++){<br>      System.out.print(array[i][j]+”\t”);<br>      }<br>         System.out.println();<br>     }<br>    }<br>    /<em><br>输出矩阵<br>0 2 2 2 2 2<br>1 0 2 2 2 2<br>1 1 0 2 2 2<br>1 1 1 0 2 2<br>1 1 1 1 0 2<br>1 1 1 1 1 0    </em>/<br>    public static void printFang(){<br>      int[][] array=new int[6][6];<br>      for(int i=0;i&lt;array.length;i++){<br>      for(int j=0;j&lt;array[i].length;j++){<br>         if(i==j) array[i][j]=0;<br>         else if(i&gt;j) array[i][j]=1;<br>         else array[i][j]=2;<br>      }<br>      }<br>      out(array);//调用输出二维数组方法<br>    }<br>    /<em><br>    杨辉三角<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1    </em>/<br>    public static void printYang(){<br>       int n=10;//总行数<br>       int[][] array=new int[n][];<br>       for(int i=0;i&lt;array.length;i++){<br>         array[i]=new int[i+1];//创建列数对象<br>        for(int j=0;j&lt;=i;j++){<br>            if(i==0 || j==0 || i==j)<br>                array[i][j]=1;<br>            else<br>                array[i][j]=array[i-1][j-1]<br>                +array[i-1][j];<br>        }<br>       }<br>      out(array);<br>    }<br>}</p><p>package com.briup.ch11;<br>public class Bubble<br>{<br>    public static void main(String… args){<br>    int[] attr={2,5,-5,98,198,23};<br>    System.out.println(“排序前:”);<br>    for(int i=0;i&lt;attr.length;i++){<br>    System.out.print(attr[i]+” “);<br>    }<br>    System.out.println();<br>    //外层循环次数<br>    for(int i=0;i&lt;attr.length-1;i++){<br>     for(int j=0;j&lt;attr.length-1-i;j++){<br>       if(attr[j]&gt;attr[j+1]){<br>          int temp=attr[j];//临时存放最大值<br>          attr[j]=attr[j+1];<br>          attr[j+1]=temp;<br>       }<br>     }<br>    }<br>System.out.println(“排序后:”);<br>  for(int i=0;i&lt;attr.length;i++){<br>    System.out.print(attr[i]+” “);<br>    }<br>    }<br>}</p><p>package com.briup.ch11;<br>public class CopyArrayTest<br>{<br>    public static void main(String… args){<br>       //int[] array=new int[5];<br>      // array[5]=6;<br>      //array.length=8;//error<br>      int[] array={1,3,46,57,2};<br>      int[] newArray=new int[10];<br>      System.out.println(“扩容前数组长度:”);<br>      System.out.println(array.length);<br>      //扩容<br>      System.arraycopy(array,0,newArray,0,array.length);<br>      array=newArray;//赋值<br>     System.out.println(“扩容后数组长度:”);<br>      System.out.println(array.length);</p><pre><code>}</code></pre><p>}</p><p>package com.briup.ch11;<br>public class Queue<br>{<br>    private int[] array;//队<br>    private int length;//队的总长度<br>    private int size;//队的当前长度<br>   public Queue(){<br>     array=new int[5];<br>     this.length=5;<br>   }<br>   public Queue(int length){<br>   array=new int[length];<br>   this.length=length;<br>   }<br>   //判断数组越界<br>   public void check(){<br>     if(size&gt;=length){//扩容<br>       int[] newArray=new int[10+length];<br>       System.arraycopy(array,0,newArray,0,length);<br>       array=newArray;<br>       length+=10;<br>     }<br>   }<br>    //入队<br>     public void add(int num){<br>         check();<br>     array[size]=num;<br>     size++;<br>     }</p><pre><code>//出队public int remove(){ int num=array[0];//删除的内容 for(int i=0;i&lt;size-1;i++){//代表移动几次    array[i]=array[i+1];//往前移动数据 }array[size-1]=0;//将最后一个数据设置默认值size--; return num;}</code></pre><p>   //队的当前长度<br>   public int getSize(){<br>   return size;<br>   }<br>   //打印队的详细信息<br>   public void print(){<br>   for(int i=0;i&lt;size;i++){<br>   System.out.print(array[i]+” “);<br>   }<br>   }<br>}</p><p>package com.briup.ch11;<br>public class QueueTest<br>{<br>    public static void main(String… args){<br>        Queue queue=new Queue();//初始化对象<br>        queue.add(10);<br>        queue.add(20);<br>        queue.add(30);<br>        queue.add(40);<br>        queue.add(50);<br>        queue.add(60);<br>         System.out.println(queue.getSize());<br>         queue.print();</p><pre><code>}</code></pre><p>}</p><p>package com.briup.ch11;<br>public class Selection<br>{<br>    public static void main(String… args){<br>     int[] attr={2,5,-5,198,98,23};<br>     System.out.println(“排序前:”);<br>     for(int i=0;i&lt;attr.length;i++){<br>     System.out.print(attr[i]+” “);<br>     }<br>   System.out.println();<br>    for(int i=0;i&lt;attr.length-1;i++){<br>        int position=i;<br>     for(int j=i+1;j&lt;attr.length;j++){<br>        if(attr[position]&gt;attr[j]){<br>           position=j;<br>        }<br>     }<br>     int temp=attr[i];<br>     attr[i]=attr[position];<br>     attr[position]=temp;<br>    }<br>   System.out.println(“排序后:”);<br>  for(int i=0;i&lt;attr.length;i++){<br>    System.out.print(attr[i]+” “);<br>    }<br>    }<br>}</p><p>package com.briup.ch11;<br>public class Test<br>{<br>    public static void main(String… args){<br>       System.out.println(add(4,5));<br>       System.out.println(add(4,5,6));<br>    }<br>    public static int add(int… array){<br>        int sum=0;<br>       for(int i=0;i&lt;array.length;i++){<br>           sum+=array[i];<br>       }<br>       return 0;<br>    }<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十天笔记</title>
      <link href="/2018/10/18/index10/"/>
      <url>/2018/10/18/index10/</url>
      
        <content type="html"><![CDATA[<p>5)可变长参数 …  参数的个数可变<br>两个int相加?<br>public int add(int a,int b){}<br>三个int相加?<br>public int add(int a,int b,int c){}<br>四个int相加?<br>public int add(int a,int b,int c,int d){}<br>五个int相加?<br>public int add(int a,int b,int c,int d,int e){}<br>……….<br>上面的方案代码非常冗余。类似的代码重复写。<br>jdk1.5之前的解决方案：通过数组解决的<br> public int add(int[] a){<br> }</p><p>add(new int[]{5,8,9});<br>add(new int[]{5,8});</p><p>缺点:每次都要创建新的数组，<br>    创建数组需要在堆区开辟连续的内存空间。<br>    参数调用之后该变量就没用了，这样会<br>    浪费内存空间。<br>jdk1.5之后的解决方案：通过…解决的<br> public int add(int… a){<br> }<br>调用: add(1,4);<br>      add(1,4,6);<br>      add(7,6,8,89,76);</p><p>注意:1)可变长参数的使用和数组的使用是一样<br>     2)一个方法中只能定义一个可变长参数，<br>       并且要定义最后一个参数。</p><p>一）基础实验：</p><p>\1. for、while、do while循环语句测试例子</p><p>example/chap03/src/LoopTest.java三种循环实训1累加到100</p><p>example/chap03/src/LoopRandom.java产生10个[200,500]间的随机数</p><p>for(int i=0;i&lt;10;i++){</p><p> int a=(int)(Math.random()*(最大数-最小数+1)+最小数)</p><p>}</p><p>\2. break、continue关键字测试例子</p><p> break：中断当前循环</p><p>   continue：结束本次循环，继续下次循环</p><p>二,求任意两个正整数的最大公约数和(GCD)和最小公倍数(LCM)</p><p>辗转相除法的算法为：首先将 m除以 n（m&gt;n）得余数 r，</p><p>再用余数r 去除原来的除数，得新的余数，重复此过程直到</p><p>余数为 0时停止，此时的除数就是m 和 n的最大公约数。 </p><p>求 m和 n的最小公倍数: m和 n的积除以(m和 n 的最大公约数)。</p><p> public class GcdLcm {</p><p> public static void main(String[] args) {</p><p>  // TODO Auto-generated method stub</p><p>  //调用java.util.Scanner可以获得从键盘输入的数字;</p><p>  Scanner sc= new Scanner(System.in);</p><p>  //定义两个整型数字的变量</p><p>  int min;</p><p>  int max;</p><p>  System.out.print(“请输入一个数：”);</p><p>  min= sc.nextInt();//nextInt();方法用来获取输入的Int NUM</p><p>  System.out.print(“请输入另一个数：”);</p><p>  max= sc.nextInt();</p><p>  //调用后面的静态方法；</p><p>  System.out.println(gongyue(min, max));</p><p>  System.out.println(gongbei(min, max));</p><p> }</p><p> // a与b的最大公约数</p><p> 求（319，377）：</p><p>∵ 319÷377=0（余319）</p><p>∴（319，377）=（377，319）；</p><p>∵ 377÷319=1（余58）</p><p>∴（377，319）=（319，58）；</p><p>∵ 319÷58=5（余29）</p><p>∴ （319，58）=（58，29）；</p><p>∵ 58÷29=2（余0）</p><p>∴ （58，29）= 29；</p><p>∴ （319，377）=29。</p><p> public static int gongyue(int min, int max) {</p><p>  while(max%min!=0){</p><p>   /**运用递归调用将求余之后的值作为min</p><p>​    <em> 将之前的min作为max直到求余值为0为止结束循环</em>/</p><p>   int temp=max%min;</p><p>   max=min;</p><p>   min=temp;</p><p>  }</p><p>  return min;</p><p> }</p><p> // a与b的最小公倍数</p><p> public static int gongbei(int min, int max) {</p><p>  //求公倍数就是将两个数相乘除以最大公约数</p><p>  return min* max / gongyue(min, max);</p><p> }</p><p>}</p><p>三,求1000以内的完全数</p><p>若一个自然数，恰好与除去它本身以外的一切因数的和相等，这种数叫做完全数。</p><p>例如，6=1+2＋3</p><p>28=1＋2＋4＋7＋14</p><p>496=1+2+4+8＋16+31+62＋124</p><p>先计算所选取的整数a(a的取值1~1000)的因数，将各因数累加于m，</p><p>若m等于a，则可确认a为完全数</p><p>public class Perfect { </p><p>  public static void main(String[] args) { </p><p>​    System.out.println(“1000以内的所有完数有：”); </p><p>​    for (int i = 2; i &lt; 1000; i++) {// 遍历1000以内的所有整数 </p><p>​      int sum = 0;// 定义和变量 </p><p>​      for (int j = 1; j &lt; i; j++) { </p><p>​        if (i % j == 0) {// 满足是i的因子,就累加 </p><p>​          sum += j; </p><p>​        } </p><p>​      } </p><p>​      if (sum == i) {// 满足因子之和等于i就打印该完数 </p><p>​        System.out.print(i + “ “); </p><p>​      } </p><p>​    } </p><p>  } </p><p>}</p><p>二）基础实验：</p><p>\1. 数组基础（声明、创建、初始化、赋值）测试例子</p><p>example/chap04/src/ArrayTest.java</p><p>example/chap04/src/ArrayTest2.java</p><p>\1. 求一组数的平均值</p><p>example/chap04/src/ArrayAvgTest.java</p><p>\2. 求一组数的最大值</p><p>example/chap04/src/ArrayMaxTest.java</p><p>public static main(String[] args){</p><p>​    int[] is={3,2,5,35,17,28,21,45,7};</p><p>​    int max = is[0];</p><p>​    int min = is[0];</p><p>​    int sum = 0;</p><p>​    double ave = 0.0;</p><p>​    for(int i=0;i&lt;is.length;i++){</p><p>​        if(is[i]&gt;max){</p><p>​            max=is[i];</p><p>​        }</p><p>​        if(is[i]&lt;min){</p><p>​            min=is[i];</p><p>​        }</p><p>​        sum+=is[i];</p><p>​    }</p><p>​    ave = sum*1.0/is.lenght;</p><p>​    System.out.println(“最小是：”+min);</p><p>​    System.out.println(“最大是：”+max);</p><p>​    System.out.println(“平均值是：”+ave);</p><p>}</p><p>\3. 产生100个[1,6]的整数，并统计每个整数出现的频率</p><p>example/chap04/src/Frequency.java</p><p>a=new int[1000];</p><p>b=new int[]{0,0,0,0,0,0}</p><p>for</p><p>if(a[i]==1){</p><p>b[0]++;</p><p>}</p><p>if(a[i]==2){</p><p>b[1]++;</p><p>}</p><p>….</p><p>扩展</p><p>1.写ArrayMultipy.java，使用数组，在数组元素中保存1到10，然后将所有数组元素相乘并输出结果。</p><p>public class ArrayMultipy {</p><p>​    </p><p>public static void main(String[] args) {</p><p>​    int[] a={1,2,3,4,5,6,7,8,9,10};</p><p>​    int sum=1;</p><p>​    for (int i = 0; i &lt; a.length; i++) {</p><p>​        sum=sum*a[i];</p><p>​    }</p><p>​    System.out.println(sum);</p><p>}</p><p>}</p><p>2.按照以下要求完成程序：</p><p>a)创建两个int类型的数组array1和array2，使用{}将array1初始化为8个质数：2，3，5，7，11，13，17和19，显示array1的内容。</p><p>b)赋值array2=array1，修改array2中的偶索引元素，使其等于索引值，显示array1中的内容，看看有什么变化。</p><p>public class ArrayMultipy {</p><p>​    </p><p>public static void main(String[] args) {</p><p>​    int[] array1={2,3,5,7,11,13,17,19};</p><p>​    int[] array2=array1;</p><p>​    for (int i = 0; i &lt; array2.length; i++) {</p><p>​        if(i%2==0){</p><p>​            array2[i]=i;</p><p>​        }</p><p>​        System.out.println(array2[i]);</p><p>​    }</p><p>​    for (int i = 0; i &lt; array1.length; i++) {</p><p>​        </p><p>​        System.out.println(array1[i]);</p><p>​    }</p><p>}</p><p>}</p><p>3、按照以下要求完成程序：</p><p>a)创建一个称作Array2D 的类，在main()方法中声明一个称作twoD的变</p><p>量，类型为int二维数组，第一维长度为4。</p><p>int[][] twoD=new int[4][];</p><p>b)创建一个元素类型为int的数组，该数组应包括4 个元素并被赋值到变量twoD[0]。</p><p>twoD[0]=new int[4];</p><p>c)编写两个嵌套for()循环语句以打印twoD 的全部值，以矩阵的格式输出。</p><p>d)编译并运行程序。是不是发现此时出现了运行错误(空指针异常)，这是因为twoD[1]至twoD[3]未被初始化。</p><p>e)分别创建包括5个、6个和7个元素的int数组，将这些数组的引用分别赋予twoD[1]，twoD[2]和twoD[3]；确认完成上述操作的代码位置是在第3步所描述的嵌套for()循环之前。</p><p>f)编译并运行程序。应该看到一个零值的非矩形布局。</p><p>​      twoD[1]=new int[5];</p><p>​    twoD[2]=new int[6];</p><p>​    twoD[3]=new int[7];</p><p>​    for (int i = 0; i &lt; twoD.length; i++) {</p><p>​        for (int j = 0; j &lt; twoD[i].length; j++) {</p><p>​            System.out.print(twoD[i][j]+” “);</p><p>​        }</p><p>​        System.out.println();</p><p>​    }</p><p>g)赋予twoD数组的每个元素一个明显的非零值(提示：使用Math.random()以获得0~1之间的随机值，通过”*”将其放大100倍)。</p><p>twoD[0]=new int[]{(int) (Math.random()<em>101),(int) (Math.random()</em>101),(int) (Math.random()<em>101),(int) (Math.random()</em>101)};</p><p>h)声明一个类型为int的一维数组oneD，长度为4，将该数组的引用分别赋予数组twoD[0]。对oneD中的元素赋值后，打印oneD和twoD数组。</p><p>i)编译并运行程序。应该看到oneD中的数组元素和twoD中的部分元素是相同的。</p><p>int oneD[]=twoD[0];</p><p>​    for (int k = 0; k &lt; oneD.length; k++) {</p><p>​        System.out.print(oneD[k]+” “);</p><p>​    }</p><p>4.按照以下的要求，完成程序：</p><p>a）选择排序:</p><p>在要排序的一组数中，选出最小的一个数与</p><p>第一个位置的数交换；</p><p>然后在剩下的数当中再找最小的与第二个位置的数交换，</p><p>如此循环到倒数第二个数和最后一个数比较为止。</p><p>Selection.java</p><p>public class Selection {</p><p>​    public static void main(String[] args) {</p><p>​        int attr[] = { 2, 5, -5, 98, 198, 43 };</p><p>​        System.out.println(“排序前:”);</p><p>​        for (int i = 0; i &lt; attr.length; i++) {</p><p>​            System.out.print(attr[i] + “ “);</p><p>​        }</p><p>​        System.out.println();</p><p>​        for (int i = 0; i &lt; attr.length-1; i++) {</p><p>​            int position = i;</p><p>​            for (int j = i + 1; j &lt; attr.length; j++) {</p><p>​                if (attr[position] &gt; attr[j]) {</p><p>​                    position = j;</p><p>​                }</p><p>​            }</p><p>​            int temp = attr[i];</p><p>​            attr[i] = attr[position];</p><p>​            attr[position] = temp;</p><p>​        }</p><p>​        System.out.println(“排序后:”);</p><p>​        for (int i = 0; i &lt; attr.length; i++) {</p><p>​            System.out.print(attr[i] + “ “);</p><p>​        }</p><p>​    }</p><p>}</p><p>b）冒泡排序:</p><p>在要排序的一组数中，对当前还未排好序的</p><p>范围内的全部数，自上而下对相邻的两个数</p><p>依次进行比较和调整，</p><p>让较大的数往下沉，较小的往上冒。</p><p>即：每当两相邻的数比较后发现它们的排序</p><p>与排序要求相反时，就将它们互换。</p><p>Bubble.java</p><p>public class Bubble {</p><p>public static void main(String[] args) {</p><p>​    int attr[]={2,5,-5,98,198,43};</p><p>​    System.out.println(“排序前:”);</p><p>​    for (int i = 0; i &lt; attr.length; i++) {</p><p>​        System.out.print(attr[i]+” “);</p><p>​    }</p><p>​    System.out.println();</p><p>​    </p><p>​    int temp=0;</p><p>​    for(int i=0;i&lt;attr.length-1;i++){  </p><p>​        for(int j=0;j&lt;attr.length-1-i;j++){  </p><p>​        if(attr[j]&gt;attr[j+1]){  </p><p>​            temp=attr[j];  </p><p>​            attr[j]=attr[j+1];  </p><p>​            attr[j+1]=temp;  </p><p>​        }  </p><p>​        }  </p><p>​    }  </p><p>​    System.out.println(“排序后:”);</p><p>​    for (int i = 0; i &lt; attr.length; i++) {</p><p>​        System.out.print(attr[i]+” “);</p><p>​    }</p><p>}</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第九天笔记</title>
      <link href="/2018/10/18/index9/"/>
      <url>/2018/10/18/index9/</url>
      
        <content type="html"><![CDATA[<p>第四章： Array<br>一：什么是数组，什么时候使用数组？<br>数组是用来保存一组数据类型相同的元素的有序集合，<br>      数组中的每个数据称为元素。<br>      有序集合可以按照顺序或者下标取数组中的元素<br>在Java中，数组也是Java对象。数组中的元素可以是任意类型(<br>包括基本类型和引用类),但同一个数组里只能存放类型相同的元素。<br>二：什么时候用数组？<br>  1)保存一堆数据类型相同的数据的时候<br>  2)数据要求有顺序<br>三：数组和链表的区别<br>a)在内存开辟难易程度上？<br>   数组内存分配必须是一块连续的内存空间。<br>   链表内存分配不一定是连续的内存空间。<br>b)在项目中如何选择？<br>    项目重点在数据的增删改，选择链表。不需要数据的大量搬移<br>    项目重点在数据的查询，选择数组，检索效率非常高。<br>四：创建数组大致包括如下步骤：<br>. 声明一个数组类型的引用变量，简称为数组变量；<br>. 用new语句构造数组的实例。new语句为数组分配内存，并且为数组中的每个元素赋予默认值；<br>. 初始化，即为数组的每个元素设置合适的初始值。<br>  a)数组变量的声明；<br>    1) 一个存放同一类型数据的集合<br>       a. 即可以是基本类型，也可以是对象类型；<br>       b. 数组中的每个数据为元素；<br>    2) 数组是一个对象，成员是数组长度和数组中的元素;<br>    3) 申明了一个数组变量并不是创建了一个对象;<br>    4) 申明数组的方式;<br>       int[] IArray 或者 int IArray[] 基本数据类型数组，<br>                    数组中存放的是基本数据类型。<br>       Teacher[] tArray 或者 Teacher tArray[]类数组，<br>                    数组中存放的是Teacher类创建的若干个的对象。<br>    注意：1) 声明数组变量的时侯，不能指定数组的长度，以下声明方式是非法的。<br>             int x[1];<br>             int[2] x;<br>   b)初始化数组<br>    初始化：自变量创建后首次赋值的过程；<br>      创建数组对象；数组对象和其他Java对象一样，也用new语句创建；<br>       int[] iArray = new int[2];<br>       new语句执行以下步骤：<br>       a. 在堆区中为数组分配内存空间，以上代码创建了一个包含2个元素的int数组；<br>          每个元素都是int类型，占4个字节，因此整个数组对象在内存中占用8个字节。<br>       b. 为数组中的每个元素赋予其数据类型的默认值。<br>          byte/short/int/long     0<br>          float            0.0f<br>          double                0.0d<br>          String                null<br>          char                ‘\u0000’<br>          boolean               false<br>       c. 返回数组对象的引用<br>  c)初始化数组对象；<br>       数组中的每个元素都有一个索引，或者称为下标。<br>       数组中的第一个元素的索引为0，第二个元素的索引为1, 依次类推。<br>       通过索引可以访问数组中的元素或者给数组中元素内容赋值。<br>       1) 声明、创建、初始化分开：<br>          int[] iArray;<br>          iArray = new int[2];<br>          iArray[0] = 0;<br>          iArray[1] = 1;<br>       2) 声明、创建的同时并初始化数组；<br>          int[] iArray = {0, 1};<br>          Student sArray[] = new Student[] {<br>                      new Student(“George”, “Male”, 20), new Student()};<br>          Student[] stArray = { new Student(), new Student()} ;</p><p>  注意：a. 非法的数组初始化方式：<br>       int[] x = new int[5]{5,4,3,2,1};//编译出错，不能在[]中指定数组的长度；<br>         int[] x;<br>         x = {5,4,3,2,1}; //{5,4,3,2,1}必须在声明数组变量的语句中使用，不能单独使用</p><p>五. 数组的边界：<br>    1) 一个数组的下标从0开始，数组通过数组的对象引用变量的下标访问数组。<br>       数组中第一个元素的索引为0, 第二元素的索引为1，<br>       依次类推。如果一个数组长度是5，要访问最后一个数组元素可以通过<br>       下标4来访问，如果通过下标5访问，超出了数组的边界，在运行时会抛出<br>       ArrayIndexOutOfBoundsException。</p><pre><code>2) 通过调用数组的length方法可以获得一个数组的元素个数（数组长度）。     所有Java数组都有一个length属性，表示数组的长度. 该属性只能读取，但是不能修改。</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第八天笔记</title>
      <link href="/2018/10/18/index6/"/>
      <url>/2018/10/18/index6/</url>
      
        <content type="html"><![CDATA[<p>f) 逻辑操作符<br>   短路操作符，如果能根据操作左边的布尔表达式<br>   就能推算出整个表达式的布尔值，将不执行操作<br>   符右边的布尔表达式；<br>&amp;&amp;:左边的布尔表达式的值为false, 整个表达式值肯定为false,<br>         此时会忽略执行右边的布尔表达式。<br>||:左边的布尔表达式的值为true, 整个表达式值肯定为true,<br>         此时会忽略执行右边的布尔表达式。<br>if(条件1&amp;&amp;条件2){}<br>   if条件1为假，不会执行条件2<br>   if条件1为真，会执行条件2<br>if(条件1||条件2){}<br>   if条件1为真，不会执行条件2<br>   if条件1为假，会执行条件2 </p><p>g) 条件操作符<br>布尔表达式 ? 表达式1 : 表达式2<br>如果布尔表达式的值为true,就返回表达式1的值,否则返回表达式2的值。<br>int score = 61;<br>String result = score&gt;=60?”及格”:”不及格”;</p><p>h)++,–<br>前++与后++<br>前–与后–<br>int a=10;</p><p>b=++a   =====&gt;a=11,b=11,先计算，后赋值<br>b=a++   =====&gt;a=11,b=10，先赋值，后计算<br>System.out.println(“a:”+a+” b:”+b);</p><p>三.数据类型的转换<br>    1）基本数据类型转换<br>      隐式的数据类型转换：精度小的数据给精度大的数据<br>      强制（显式）的数据类型转换：(type)精度大的数据给精度小的数据<br>       System.out.println((int)(char)(byte)-1);<br>       数据类型在转换的时候注意：<br>              a)如果将精度小的数据转为精度大的数据时。<br>                  如果转之前是有符号数，在前面补符号位<br>                  如果转之前是无符号数，在前面补0<br>              b)如果将精度大的数据转为精度小的数据时。<br>                  从低位窃取位数<br>  2）引用数据类型转换<br>      隐式的数据类型转换：子类转换父类<br>      强制（显式）的数据类型转换：父类转换子类<br>      String str=”hello”;<br>      Object o=str;<br>      String str2=(String)o;</p><p> System.out.println((int)(char)(byte)-1);</p><p>0000 0000 0000 0000 1111 1111 1111 1111<br>1+2+4+8+16+32+64+128+<br>256+512+1024+2048+<br>4096+8192+16384+32768</p><p>int c=a&gt;b?a:b;<br>等价于<br>if(a&gt;b)c=a;<br>else c=b;</p><p>1.语句<br>  a)条件语句:有些代码只有满足特定条件的情况下才会被执行<br>    1)if…else<br>        a. if后面的表达式必须是布尔表达式，而不能为数字类型，例如下面的if(x)是非法的。<br>    b. 假如if语句或else语句的程序代码块中包括多条语句，则必须放在大括号{}内。<br>           若程序代码块只有一条语句则可以不用大括号{}。流程控制语句(如if…else语句)<br>           可作为一条语句看待。<br>        c.只可能执行一个分支，不可能执行多条分支</p><pre><code>2)switch  a. switch后条件的类型必须是byte, short, char或者int;     jdk1.7之后可以使用String类型。  b. 各个case子句的值不同,数据类型必须和switch后条件的数据类型相同；  c. 当switch表达式的值不与任何case子句匹配时，程序执行default子句，     假如没有default子句，则程序直接退出switch语句。     default子句可以位于switch语句中的任何位置。  d. 如果switch表达式与某个case表达式匹配，或者与default情况匹配，     就从这个case子句或default子句开始执行。     假如遇到break，就退出整个switch语句，否则依次执行switch语句中后续的case子句，     不再检查case表达式的值。  e. switch语句的功能也可以用if...else语句来实现。     但switch语句会使程序更简洁，可读性更强。而if...else功能更为强大。</code></pre><p>  b)循环语句<br>  循环语句的作用是反复执行一段代码，直到不满足循环条件为止。<br>  循环语句一般应包括如下四部分内容：<br>     i)初始化部分：用来设置循环的一些初始条件，<br>                    比如循环控制变量的初始值；<br>     ii)循环条件:这是一个布尔表达式，<br>                 每一次循环都要对该表达式求值，<br>         以判断到底继续循环还是终止循环。<br>     iii) 循环体：这是循环操作的主体内容，可以是一条语句，也可以是多条语句；<br>     iv) 迭代部分:用来改变循环控制变量的值，<br>                  从而改变循环条件表达式的值；<br>    1)for<br>       语法：for(初始化部分；循环条件；迭代部分) {<br>                               循环体<br>             }<br>    2)while<br>       语法：[初始化部分]<br>           while(循环条件) {<br>                 循环体,包括迭代部分<br>           }</p><pre><code>当循环条件为true时，就重复执行循环，否则终止循环；                 </code></pre><p>​<br>    3)do..while<br>       和while非常类似，只不过先执行循环体，然后再判断循环条件。<br>        语法：[初始化部分]<br>            do {<br>                循环体,包括迭代部分<br>            } while(循环条件);<br>    4)循环语句中流程跳转<br>        a) break: 终止当前或指定循环；<br>        b) continue: 跳过本次循环，执行下一次循环，<br>                 或执行标号标识的循环体。<br>    c) label: 标号用来标识程序中的语句，标号的名字可以是任意的合法标识符。<br>           continue语句中的标识必须定义在while、do…while和for循环语句前面；<br>           break语句中的标识必须定义在while、do…while和for循环语句或switch语句前面；</p><p><br></p><br><p></p><p>package com.briup.ch07;<br>  public class BitTest<br>  {<br>      public static void main(String… args){<br>            out(11);<br>            int a=bitSet(11,3);<br>            out(a);<br>            int b=bitZero(10,2);<br>            out(b);<br>      }<br>      //输出二进制<br>      public static void out(int num){<br>      System.out.println(num+”的二进制是:”);<br>      for(int i=31;i&gt;=0;i–){<br>        System.out.print(num&gt;&gt;i &amp;1);<br>      }<br>      System.out.println();<br>      }<br>      //置1<br>      public static int bitSet(int num,int position){<br>         return num|(1&lt;&lt;(position-1));<br>      }<br>      //置0<br>      public static int bitZero(int num,int position){<br>         return num&amp;(~(1&lt;&lt;(position-1)));<br>      }<br>  }</p><p>一：写Test.java，要求如下：</p><p>1)传入一个int数，要求清除该数的低8位，高24位不变，将结果以十进制形式输出</p><p>public class Test1{</p><p>public static void main(){</p><p>int a=100;</p><p>System.out.println(a&amp;(-1&lt;&lt;8));</p><p>   }</p><p>}</p><p>2)传入一个int数，要求将该数的低16位置1，高16位不变，将结果以十进制形式输出</p><p>-1</p><p>11111111 11111111 11111111 11111111</p><p>-1&gt;&gt;&gt;16</p><p>00000000 00000000 11111111 11111111</p><p>00000000 00100000 00000000 00001010</p><p>00000000 00000000 11111111 11111111</p><p>public class Test2{</p><p>public static void main(){</p><p>int a=100;</p><p>System.out.println(a|(-1&gt;&gt;&gt;16));</p><p>}</p><p>}</p><p>一，请按照下列输出</p><p>*</p><p>**</p><hr><hr><hr><hr><hr><p>int n=7;</p><p>for(int i=0;i&lt;n;i++){</p><p>for(int j=0;j&lt;=i;j++){</p><p>System.out.print(“*”);</p><p>}</p><p>System.out.println();</p><p>}</p><p>​      *     </p><p>​     **</p><p>​    ***</p><hr><hr><hr><hr><p>int n=7;</p><p>for(int i=0;i&lt;n;i++){</p><p>for(int k=n-i-1;k&gt;0;k–){</p><p>System.out.println(“ “);</p><p>}</p><p>for(int j=0;j&lt;=i;j++){</p><p>System.out.print(“*”);</p><p>}</p><p>System.out.println();</p><p>}</p><p>​    *</p><hr><hr><hr><p>for(int i=0;i&lt;n;i++){</p><p>for(int k=n-i-1;k&gt;0;k–){</p><p>System.out.println(“ “);</p><p>}</p><p>for(int j=0;j&lt;=2*i;j++){</p><p>System.out.print(“*”);</p><p>}</p><p>System.out.println();</p><p>}</p><p>二：写LoopTest.java，分别使用while/do/for循环实现1x2x…x10。</p><p>public class LoopTest{</p><p>public static void main(String[] args){</p><p>int sum=1;</p><p>String str=””;</p><p>for(int i=1;i&lt;=10;i++){</p><p>sum=sum*2;</p><p>if(i&lt;10){</p><p>str=str+i+”*”;</p><p>}else{</p><p>str=str+i;</p><p>}</p><p>}</p><p>System.out.println(str+”=”+sum);</p><p>}</p><p>}</p><p>三：创建一个阶乘应用程序Factor.java</p><p>功能：一个数X 的阶乘（通常记作X!）等于X<em>(X-1)</em>(X-2)<em>…..</em>1。例如4!等于4×3×2×1=24。</p><p>public class Factor {</p><p>​    public static void main(String[] args) {</p><p>​        Scanner sc = new Scanner(System.in);</p><p>​        System.out.println(“输入一个数字”);</p><p>​        int n = sc.nextInt();</p><p>​        System.out.println(“结果是：”+f(n));</p><p>​    }</p><p>​    public static int f(int n){</p><p>​        int sum = 1;</p><p>​        for(int i = 1;i &lt;= n;++i){</p><p>​            sum *= i; </p><p>​        }</p><p>​        return sum;</p><p>​    }</p><p>}</p><p>五：打印出四种形式的九九乘法表</p><p>提示：</p><p>1、System.out.println()的功能为输出+换行</p><p>​      System.out.print()的功能为输出</p><p>2、在适当的位置可以使用’\t’进行对齐操作</p><p>形式1：</p><p>1*1= 1</p><p>1<em>2= 2  2</em>2= 4</p><p>1<em>3= 3  2</em>3= 6  3*3= 9</p><p>1<em>4= 4  2</em>4= 8  3<em>4=12  4</em>4=16</p><p>1<em>5= 5  2</em>5=10  3<em>5=15  4</em>5=20  5*5=25</p><p>1<em>6= 6  2</em>6=12  3<em>6=18  4</em>6=24  5<em>6=30  6</em>6=36</p><p>1<em>7= 7  2</em>7=14  3<em>7=21  4</em>7=28  5<em>7=35  6</em>7=42  7*7=49</p><p>1<em>8= 8  2</em>8=16  3<em>8=24  4</em>8=32  5<em>8=40  6</em>8=48  7<em>8=56  8</em>8=64</p><p>1<em>9= 9  2</em>9=18  3<em>9=27  4</em>9=36  5<em>9=45  6</em>9=54  7<em>9=63  8</em>9=72  9*9=81</p><p>​      for (int i = 1; i &lt;= num; i++) {//形式1</p><p>​     for (int j = 1; j &lt;= i; j++) {</p><p>​     System.out.print(j + “<em>“ + i + “=” + j</em>i + “\t”); </p><p>​        } </p><p>​          System.out.println();</p><p>​          }</p><p>​    </p><p>形式2：</p><p>1<em>9= 9  2</em>9=18  3<em>9=27  4</em>9=36  5<em>9=45  6</em>9=54  7<em>9=63  8</em>9=72  9*9=81</p><p>1<em>8= 8  2</em>8=16  3<em>8=24  4</em>8=32  5<em>8=40  6</em>8=48  7<em>8=56  8</em>8=64</p><p>1<em>7= 7  2</em>7=14  3<em>7=21  4</em>7=28  5<em>7=35  6</em>7=42  7*7=49</p><p>1<em>6= 6  2</em>6=12  3<em>6=18  4</em>6=24  5<em>6=30  6</em>6=36</p><p>1<em>5= 5  2</em>5=10  3<em>5=15  4</em>5=20  5*5=25</p><p>1<em>4= 4  2</em>4= 8  3<em>4=12  4</em>4=16</p><p>1<em>3= 3  2</em>3= 6  3*3= 9</p><p>1<em>2= 2  2</em>2= 4</p><p>1*1= 1</p><p>  for (int i = 9; i &gt;= 1; i–) {//形式2</p><p>​     for (int j = 1; j &lt;= i; j++) {</p><p>​    System.out.print(j + “<em>“ + i + “=” + j </em> i + “\t”);</p><p>​        }</p><p>​    System.out.println();</p><p>​        }</p><p>形式3：</p><p>​                                                                1*1= 1</p><p>​                                                        1<em>2= 2  2</em>2= 4</p><p>​                                                1<em>3= 3  2</em>3= 6  3*3= 9</p><p>​                                        1<em>4= 4  2</em>4= 8  3<em>4=12  4</em>4=16</p><p>​                                1<em>5= 5  2</em>5=10  3<em>5=15  4</em>5=20  5*5=25</p><p>​                        1<em>6= 6  2</em>6=12  3<em>6=18  4</em>6=24  5<em>6=30  6</em>6=36</p><p>​                1<em>7= 7  2</em>7=14  3<em>7=21  4</em>7=28  5<em>7=35  6</em>7=42  7*7=49</p><p>​        1<em>8= 8  2</em>8=16  3<em>8=24  4</em>8=32  5<em>8=40  6</em>8=48  7<em>8=56  8</em>8=64</p><p>1<em>9= 9  2</em>9=18  3<em>9=27  4</em>9=36  5<em>9=45  6</em>9=54  7<em>9=63  8</em>9=72  9*9=81</p><p>for (int i = 1; i &lt;= num; i++) {//形式3</p><p>   for (int k = 1; k &lt;=num-i; k++) {//或者int k=9-i;k&gt;0;k–</p><p>​    System.out.print(“\t”);</p><p>​        }</p><p>​    for (int j = 1; j &lt;= i; j++) {</p><p>​      int a=j*i;</p><p>​       if (a&gt;9) {</p><p>​      System.out.print(j + “<em>“ + i + “=” + j </em> i + “\t”);</p><p>​       }else {</p><p>​        System.out.print(j + “<em>“ + i + “= “ + j </em> i + “\t”);</p><p>​        }</p><p>​                </p><p>​        }</p><p>​      System.out.println();</p><p>​        }</p><p>形式4：</p><p>1<em>9= 9  2</em>9=18  3<em>9=27  4</em>9=36  5<em>9=45  6</em>9=54  7<em>9=63  8</em>9=72  9*9=81</p><p>​        1<em>8= 8  2</em>8=16  3<em>8=24  4</em>8=32  5<em>8=40  6</em>8=48  7<em>8=56  8</em>8=64</p><p>​                1<em>7= 7  2</em>7=14  3<em>7=21  4</em>7=28  5<em>7=35  6</em>7=42  7*7=49</p><p>​                        1<em>6= 6  2</em>6=12  3<em>6=18  4</em>6=24  5<em>6=30  6</em>6=36</p><p>​                                1<em>5= 5  2</em>5=10  3<em>5=15  4</em>5=20  5*5=25</p><p>​                                        1<em>4= 4  2</em>4= 8  3<em>4=12  4</em>4=16</p><p>​                                                1<em>3= 3  2</em>3= 6  3*3= 9</p><p>​                                                        1<em>2= 2  2</em>2= 4</p><p>​                                                                1*1= 1</p><p> for (int i = 9; i &gt;= 1; i–) {//形式4</p><p>​    for (int k = 1; k &lt;=num-i; k++) {</p><p>​        System.out.print(“\t”);</p><p>​        }</p><p>​    for (int j = 1; j &lt;= i; j++) {</p><p>​        int a=j*i;</p><p>​        if (a&gt;9) {</p><p>​        System.out.print(j + “<em>“ + i + “=” + j </em> i + “\t”);</p><p>​        }else {</p><p>​        System.out.print(j + “<em>“ + i + “= “ + j </em> i + “\t”);</p><p>​        }</p><p>​                </p><p>​        }</p><p>​            System.out.println();</p><p>​        }    </p><p>六：1,题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</p><p>程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。</p><p>public class Digit{</p><p>public static void main(String[] args){</p><p>int i=0;  //保存百位上的数</p><p>int j=0;  //保存十位上的数</p><p>int k=0;  //保存个位上的数</p><p>int t=0;  //保存数字个数 </p><p>for(i=1;i&lt;=4;i++)｛</p><p>   for(j=1;j&lt;=4;j++)｛</p><p>   for(k=1;k&lt;=4;k++){</p><p>​    if(i!=j &amp;&amp; j!=k &amp;&amp; i!=k){</p><p>​         t+=1;</p><p>​        System.out.println(i<em>100+j</em>10+k);</p><p>​    } </p><p>​     }  </p><p>   }</p><p> }</p><p>System.out.println (t);</p><p>}</p><p>}</p><p>七,判断101-200之间有多少个素数，并输出所有素数。</p><p>只能被1和它本身整除的自然数为素数(质数)</p><p>public class Prime {</p><p>​    public static final void main(String[] args) {</p><p>​        // 记录素数个数</p><p>​        // 素数概念:除了1和它本身以外不再有其他的除数整除</p><p>​        int num = 0;</p><p>​        for (int i = 101; i &lt; 201; i++) {</p><p>​            for (int k = 2; k &lt; i; k++) {</p><p>​                int remainder = i % k;</p><p>​                if (k == i - 1) {</p><p>​                    ++num;</p><p>​                    System.out.println(“素数：” + i);</p><p>​                } else if (remainder == 0) {// 余数等于0说明有其他的除数整数,说明不是素数数</p><p>​                    break;</p><p>​                }</p><p>​            }</p><p>​        }</p><p>​        System.out.println(num + “ 个”);</p><p>​    }</p><p>}</p><p>八,打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位</p><p>数字立方和等于该数本身。例如：153是一个“水仙花数”，因为</p><p>153=1的三次方＋5的三次方＋3的三次方。</p><p>Math.pow(a,3);</p><p>a<em>a</em>a</p><p>public class Flower {</p><p>​    public static void main(String[] agrs) {</p><p>​        for (int i = 100; i &lt; 1000; i++) {</p><p>​            int a = i / 100;</p><p>​            int b = i / 10 % 10;</p><p>​            int c = i % 10;</p><p>​            if (Math.pow(a, 3) + Math.pow(b, 3) + Math.pow(c, 3) == i)</p><p>​                System.out.println(“水仙花数 : “ +i);</p><p>​        }</p><p>​    }</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第六天笔记</title>
      <link href="/2018/10/18/index5/"/>
      <url>/2018/10/18/index5/</url>
      
        <content type="html"><![CDATA[<p>第二章（续）<br>一.基本数据类型变量和引用数据类型变量：<br>   1)使用基本数据类型定义的变量叫做基本数据类型变量<br>    int a=10;<br>       保存是数据本身的数值(二进制)<br>   2）使用引用数据类型定义的变量叫做引用数据类型变量<br>    Teacher t=new Teacher();<br>       保存是堆区开辟的地址<br>   new关键字：<br>     a)在栈区开辟空间保存对象的引用<br>     b)在堆区开辟空间保存对象本身<br>     c)堆区的地址赋值给栈区的对象的引用<br>二：运行时数据区<br>一个完整的Java程序运行过程会涉及以下内存区域<br>方法区/代码区：存放类的信息<br>堆区：用来存放动态产生的数据，比如new出来的对象。<br>     注意创建出来的对象只包含属于各自的成员变量，<br>     并不包括成员方法。因为同一个类的对象拥有各自<br>     的成员变量，存储在各自的堆中，但是他们共享该<br>     类的方法，并不是每创建一个对象就把成员方法复制一次。<br>栈区：保存局部变量的值，包括：<br>     1.用来保存基本数据类型的值；<br>     2.保存类的实例，即堆区对象的引用(指针)。<br>       也可以用来保存加载方法时的帧<br>常量池：JVM为每个已加载的类型维护一个常量池，<br>        常量池就是这个类型用到的常量的一个有序集合。<br>    常量池存在于堆中。<br>PC寄存器：指向下一条需要执行的指令，将该数据传递给CPU</p><p>第三章： Expressions and Flow Control<br>一：局部变量和实例变量<br>定义变量是指设定变量的数据类型和变量的名字，<br>Java语言要求变量遵循先定义，再初始化，然后使用的规则。<br>作用域：指它的存在范围，只有在这个范围内，程序代码才能访问它。<br>变量的生命周期是指从一个变量被创建并分配内存空间开始，<br>            到这个变量被销毁并清除其所占用内存空间的过程<br>局部变量(参数变量也可以看成是局部变量)：<br>   1)位置：定义在方法中或者在方法中的{}<br>   2)使用：先赋值后使用<br>   3)作用域：定义的方法中或者定义的{}中<br>   4)生命周期：从变量的定义到方法调用结束<br>实例变量：<br>   1)位置：定义方法外，类里面<br>   2)使用：系统会进行默认初始化<br>   3)作用域：作用于整个类<br>   4)生命周期：从对象创建的时候到gc回收内存结束<br>局部变量的例子：<br>public void method1() {<br>    int a = 0;   //局部变量，作用域为整个method01方法；<br>     { int b = 0; //局部变量，作用域为所处的代码块；<br>         b = a;<br>     }<br>     b = 20;   //编译出错，b不能被访问；<br>}<br>实例变量的例子：<br>class Test {<br>          private int n1=0;<br>          private int n2=0;</p><pre><code>public int add() {   int result = n2 + n2;   return result; }</code></pre><p>}</p><p>二：操作符:操作符能与相应类型的数据组成表达式，来完成相应的运算。<br>a)数学运算操作符<br>   +数据类型值相加或字符串连接;<br>System.out.println(1+2+”a”);          //输出3a<br>System.out.println(1+2.0+”a”);        //输出3.0a<br>System.out.println(1+2.0+”a”+true);   //输出3.0atrue<br>System.out.println(“a”+1+2);          //输出a12<br>System.out.println(1+”a”+2);          //输出1a2<br>  /整除, 如操作数均为整数，运算结果为商的整数部分<br>int a1=12/5;      //a1变量的取值为2<br>int a2=13/5;      //a2变量的取值为2<br>int a3=-12/5;     //a3变量的取值为-2<br>int a4=-13/5;     //a4变量的取值为-2<br>int a5=1/5;       //a5变量的取值为0<br>double a6=-12/5;   //a6变量的取值为-2.0<br>double a7=-12/5.0; //a7变量的取值为-2.4<br>   %取模操作符, 如操作数均为整数，运算结果为商的整数部分<br>int a1=1%5;      //a1变量的取值为1<br>int a2=13%5;     //a2变量的取值为3<br>double a3=1%5;    //a3变量的取值为1.0<br>double a4=12%5.1;  //a4变量的取值为1.8000000000000007</p><p>b) 赋值操作符：<br>      = :int x=0,i=1,j=1;<br>      <em>=:这里的”</em>=”由操作符”<em>“和”=”复合而成，它等价于 a=a</em>b;<br>         这种复合操作符能使程序变得更加简洁。<br>      /=:a/=b 等价于 a=a/b;<br>      %=:a%=b 等价于 a=a%b;<br>         …<br> 注意：+=和+的区别<br>    如:short a=0;<br>       int b=123456;<br>       a+=b;和a=a+b的区别<br>         +=系统会进行隐式的数据类型转换，向=左边的数据类型进行转换。<br>         a+b会向数据类型高的类型转换</p><p>c) 比较操作符</p><blockquote><p> 大于<br>= 大于等于<br>   &lt;  小于<br>   &lt;= 小于等于<br>以上操作符只适用于整数类型和浮点数类型；<br> int a=1,b=1;<br> double d=1.0;<br> boolean result1 = a&gt;b;  //result1的值为false;<br> boolean result2 = a&lt;b;  //result2的值为false;<br> boolean result3 = a&gt;=d; //result3的值为true;<br> boolean result4 = a&lt;=b; //result4的值为true;              </p></blockquote><p>instanceof: 判断一个引用类型所引用的对象是否是一个类的实例。<br>            该操作符左边是一个对象，右边是一个类名或接口名。形式如下：<br>  如：String str=”hello”<br>     System.out.println(str instanceof String);<br>     System.out.println(str instanceof Object);<br>     System.out.println(str instanceof Student); //false<br>  java.lang.Object是所有类的父类，<br>      每一个类都会默认继承Object<br>  子类是一个父类 是is a的关系</p><p>d)相等操作符<br>== 等于<br>!= 不等于<br>既可以是基本类型，也可以是引用类型：<br>基本数据类型比较是真正的数值<br>引用类型比较的是地址，如果要比较引用类型真正的数据使用equals<br>如：int a=1,b=1;<br>System.out.println(a==b);  //输出true;<br>如：String s1=”hello”;<br>   String  s2=”hello”;<br>   String s3=new String(“hello”);<br>   String s4=new String(“hello”);<br>   System.out.println(s1==s2); //true<br>   System.out.println(s3==s4); //false<br>   System.out.println(s1==s3); //false<br>    System.out.println(s3.equals(s4)); //true<br>e) 移位操作符，针对二进制操作  </p><blockquote><blockquote><p>算术右移位运算，也称做带符号右移位运算。最高为补符号位。</p><blockquote><p>逻辑右移位运算，也称为不带符号右移位运算。<br>&lt;&lt; 左移位运算，也称为不带符号左移位运算。</p></blockquote></blockquote></blockquote><p>f) 位运算操作符<br>&amp; :与运算，运算规则为：1&amp;1-&gt;1, 1&amp;0-&gt;0, 0&amp;1-&gt;0, 0&amp;0-&gt;0;<br>|:或运算，运算规则为：1|1-&gt;1, 1|0-&gt;1, 0|1-&gt;1, 0|0-&gt;0;<br>^:异或运算，运算规则为：1^1-&gt;0, 1^0-&gt;1, 0^1-&gt;1, 0^0-&gt;0;<br>            两个值相同为0,不同为1；<br>~ : 取反运算, ~1-&gt;0, ~0-&gt;1;</p><p>例如：8&gt;&gt;2====&gt;8/2^2=2<br>8:0000…00001000<br>  0000………10 ====&gt;2<br>8&gt;&gt;&gt;3=====&gt;8/2^3=1<br>8:0000…00001000<br>  00000000.000001=====&gt;1<br>8&lt;&lt;2======&gt;8*2^2=32<br>8:0000…00001000<br>  000000000100000======&gt;32<br>1&amp;1=1 1&amp;0=0 0&amp;0=0<br>1|1=1 1|0=1 0|0=0<br>1^1=0 1^0=1 0^0=0<br>~1=0<br>~0=1<br>8&amp;2=0  8|2=10  8^2=10<br>~8=<br>~2=</p><p>1010<br>10===&gt;第三位置1===&gt;14<br>10===&gt;第二位清0===&gt;8<br>10===&gt;第一位置反===&gt;11<br>10===&gt;输出相应的二进制</p><p>package com.briup.ch06;<br>    public class Operators<br>    {</p><pre><code>public static void main(String... args){ //只声明不初始化，则为false   Student stu1=null;    System.out.println(stu1 instanceof Student);    //初始化后相同类型或子类转父类可行则为true    Student stu=new Student();    System.out.println(stu instanceof Student);    System.out.println(stu instanceof People);    //父类转子类不行为false    People p=new People();       System.out.println(p instanceof Student);      //不一样的类型，则报类型转换异常       Teacher p1=new Teacher();       System.out.println(p1 instanceof Student);    </code></pre><p>}<br>    }</p><p>package com.briup.ch06;<br>    public class Variable<br>{<br>    int a;<br>        public static void main(String… args){<br>               Variable vb=new Variable();<br>                vb.display();<br>    }<br>    public  void display(){</p><pre><code>   System.out.println(a);  // System.out.println(b);}public static void add(int b){System.out.println(b);}</code></pre><p>}</p><p>package com.briup.ch06;<br>public class Teacher extends People<br>{<br>    public void displays(){</p><pre><code>}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第五天笔记</title>
      <link href="/2018/10/18/index4/"/>
      <url>/2018/10/18/index4/</url>
      
        <content type="html"><![CDATA[<p>一：方法的定义和方法的调用<br>   方法的定义：修饰符  方法的返回值 方法名(参数列表){<br>            方法体<br>        }<br>      如果没有方法的返回值就写成:void<br>      参数列表：参数类型 参数名<br>   方法的调用：方法名(参数值)<br>二：javac -d . First.java<br>  -d指定生成的class文件存放的路径<br>     连同包一起编译。<br>java com.briup.ch01.First<br>   java运行class文件，先类加载。<br>   将class文件加载内存中。<br>   在CLASSPATH配置的路径下找class文件。<br>CLASSPATH与-d后面指定的路径是一样</p><p>第二天：<br>目标： 1. 标识符、关键字和类型介绍；</p><pre><code>2. 如何构建类?</code></pre><p>第二章： Identifiers, Keywords and Types<br>目标：1. 注释作用：使部分内容只为程序员可见，<br>         不为编译器所编译、虚拟机所执行；增加程序的可读性<br>     位置：类声明前后、方法声明前后、属性声明前后、方法体中。<br>          几乎可以在一个源文件任意位置，但不能在一个关键字字<br>      符中插入注释。<br>     类型：1) 单行注释：//text——从”//“到本行结束的所有字符均作为注释而被编译器忽略<br>           2) 多行注释：/<em>text</em>/——从”/<em>“到”</em>/“间的所有字符会被编译器忽略<br>           3) 文档注释：/<strong> text */——从”/</strong>“到”<em>/“间的所有字符会被编译器忽略。<br>       当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的<br>       成员方法的声明)之前时，会作为JavaDoc文档的内容；<br>                  示例：1) //package declaration<br>                          package ch01;                        //允许；<br>                       2) package /</em>package declaration<em>/ch01;            //允许；<br>                       3) class /</em>class declaration<em>/ FirstJavaProgram {        //允许；<br>                          …}<br>                       4) System.out./</em>out content to console<em>/println(“Hello Java”);     //允许；<br>                       5) System.out.print/</em>out content to console*/ln(“Hello Java”);     //不允许；</p><pre><code>           javadoc -author -version -d doc *.java2. 分号、块和空格1) 每个语句短语以;结束 ;    2) 代码段以{}结束;    3) 空白处（空格、tab键、新行和回车(几个语句短语连接在一起））是无关紧要的。3. 标识符:类、方法和变量的名字   1) java标识符以字母、_和$开头，不能以数字开头，后跟字母、数字、“_”和“$”的组合;   2) 大小写敏感   3) 没有长度限制。   4) 不能使用java的关键字   举例：  合法标识符       非法标识符            try                    try#            GROUP_7                7GROUP            openDoor               open-door            boolean1               boolean</code></pre><ol start="4"><li><p>关键字<br>Java语言的关键字是程序代码中的特殊字符。包括：</p><pre><code>. 类和接口的声明——class, extends, implements, interface. 包引入和包声明——import, package. 数据类型——boolean, byte, char, double, float, int, long, short. 某些数据类型的可选值——false, true, null. 流程控制——break, case, continue, default, do, else, for, if, return, switch, while. 异常处理——catch, finally, throw, throws, try. 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile. 操作符——instanceof. 创建对象——new. 引用——this, super. 方法返回类型——void Java语言的保留字是指预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，这有别于C++； . 程序中标识符不能以关键字命名；</code></pre><ol start="5"><li><p>基本类型：程序的基本功能是处理数据,程序用变量来表示数据；</p><pre><code>    程序中必须先定义变量才能使用；定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：            数据类型  变量名；    Java语言把数据类型分为基本类型和引用类型。</code></pre><p>  基本数据类型</p><pre><code>数值类型     整数类型:byte,short,int,long 浮点数类型:float,double布尔类型：boolean字符类型：char</code></pre><p>  引用数据类型</p><pre><code>类类型:比如String        接口类型        数组类型</code></pre></li></ol><p>接下来，我们主要关注基本数据类型，关注各种基本数据类型<br>有什么样的取值范围？占用多少内存空间？     </p><ol start="6"><li><p>boolean类型</p><pre><code>位置            boolean类型变量取值   Java源程序             只能是true或falseclass文件              用int或byte表示boolean虚拟机中           用整数0来表示false, 有任意一个非零整数表示true强调，在Java源程序中不允许把整数或null赋给boolean类型的变量，</code></pre><p>这是有别于其它语言(如c语言)的地方. 例：</p><pre><code>boolean isMarried = 0;          //编译出错，提示类型不匹配boolean isMarried = null;       //编译出错，提示类型不匹配</code></pre></li><li><p>文本数据类型——char和String</p><p>  1) 字符编码:Java语言对文本字符<br>采用Unicode字符编码。<br>由于计算机内存只能存取二进制数据，<br>因此必须为各个字符进行编码。<br>所谓字符编码，是指用一串二进制数据来表示特定的字符。<br>常见的字符编码包括：<br>a. ASCII字符编码</p><pre><code>ASCII--</code></pre><p>Amecian Standard Code for Information Interchange(<br>美国信息交换标准代码).<br>主用于表达现代英语<br>和其他西欧语言中的字符。<br>它是现今最通用的单字节编码系统，<br>它只用一个字节的7位，<br>一共表示128个字符。</p><pre><code>b. ISO-8859-1字符编码,又称为Latin-1, 是国际标准化组织(ISO)为西欧语言中的字符制定的编码，</code></pre><p>用一个字节(8位)来为字符编码，与ASCII字符编码兼容。所谓兼容，是指对于相同的字符，它的ASCII字符编码<br>和ISO-8859-1字符编码相同。</p><pre><code>c. GB2312字符编码   它包括对简体中文字符的编码，</code></pre><p>  一共收录了7445个字符(6763个汉字+682个其他字符. 它与ASCII字符编码兼容。</p><pre><code>d. GBK字符编码    对GB2312字符编码的扩展，</code></pre><p>   收录了21886个字符(21003个字符+其它字符), 它与GB2312字符编码兼容。</p><pre><code> e. Unicode字符编码：        由国际Unicode协会编制，收录了全世界所有语言文字中的字符，是一种跨平台的字符编码。        UCS(Universal Character Set)是指采用Unicode字符编码的通用字符集。        Unicode具有两种编码方案：        . 用2个字节(16位)编码，被称为UCS-2, Java语言采用;        . 用4个字节(32位)编码，被称为UCS-4; f. UTF字符编码     有些操作系统不完全支持16位或32位的Unicode字符编码，UTF(UCS Transformation Format)字符编码能够把     Unicode字符编码转换为操作系统支持的编码，常见的UTF字符编码包括UTF-8, UTF-7和UTF-16.</code></pre><p> 2) char的几种可能取值<br>Java语言采用UCS-2字符编码，字符占2个字节。</p><pre><code>字符a的二进制数据形式为 0000 0000 0110 0001     十六进制数据形式为 0x0061       十进制数据形式为 97以下4种赋值方式是等价的：char c = &apos;a&apos;;char c = &apos;\u0061&apos;;      //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 0x0061;        //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 97;            //设定&quot;a&quot;的十进制数据的Unicode字符编码</code></pre><p> 3) 转义字符</p><pre><code>Java编程人员在给字符变量赋值时，通常直接从键盘输入特定的字符，</code></pre><p>而不会使用Unicode字符编码，因为很难记住各种字符的Unicode<br>字符编码值。对于有些特殊字符，比如单引号，如不知道它的<br>Unicode字符编码，直接从键盘输入编译错误：<br>   char c = ‘’’;           //编码出错</p><pre><code>为了解决这个问题，可采用转义字符来表示单引号和其他特殊字符： char c = &apos;\&apos;&apos;;char c = &apos;\\&apos;;转义字符以反斜杠开头，常用转义字符：\n           换行符，将光标定位到下一行的开头；\t           垂直制表符，将光标移到下一个制表符的位置；\r           回车，将光标定位到当前行的开头，不会移到下一行；\\           反斜杠字符\&apos;           单引号字符</code></pre><ol start="8"><li><p>整数类型<br> byte, short, int和long都是整数类型，并且都是有符号整数。<br>与有符号整数对应的是无符号整数，两者的区别在于<br> 把二进制数转换为十进制整数的方式不一样。<br>. 有符号整数把二进制数的首位作为符号数，<br>当首位是0时，对应十进制的正整数，<br>当首位是1时，对应十进制的负整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是-128 - 127。<br>. 无符号整数把二进制数的所有位转换为正整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是0 - 255。</p><pre><code>在Java语言中，为了区分不同进制的数据，八进制数以“0”开头，十六制以“0x”开头。举例： 一个字节的二进制数        八进制数         十六进制数        有符号十进制数       无符号十进制数0000 0000                 0000             0x00              0                    01111 1111                 0377             0xFF              -1                   2550111 1111                 0177             0x7F              127                  1271000 0000                 0200             0x80              -128                 128</code></pre><p>  如果一个整数值在某种整数类型的取值范围内，就可以把它直接赋给这种类型的变量，否则必须进行强制类型的转换。</p><pre><code>byte = 13;如129不在byte类型的取值范围(-128-127)范围内，则必须进行强制类型的转换。byte b = (byte)129;    //变量b的取值为-127.如果一个整数后面加上后缀——大写&quot;L&quot;或小写&quot;l&quot;, 就表示它是一个long类型整数。以下两种赋值是等价的：long var = 100L;         //整数100后面加上大写的后缀&quot;L&quot;，表示long型整数；long var = 100l;         //整数100后面加上大写的后缀&quot;l&quot;，表示long型整数；Java语言允许把八进制数(以&quot;0&quot;开头), 十六进制数(以&quot;0x&quot;开头)和十进制数赋给整数类型变量，例如：int a1 = 012;                 //012为八进制数，变量a1的十进制取值为10int a2 = 0x12;                //0x12为十六进制数，变量a2的十进制取值为18int a3 = 12;                  //12为十进制数，变量a3的十进制取值为12int a4 = 0xF1;                //0xF1为十六制数，变量a4的十进制取值为241byte b = (byte)0xF1           //0xF1为十六制数，变量b的十进制取值为-15</code></pre><p>注意：<br>数据类型的转换：<br>1)强制类型转换:精度高向精度低的转换<br>byte b = (byte)129;<br>2)隐式类型转换:精度低向精度高的转换<br>byte&lt;short&lt;int&lt;long&lt;float&lt;double</p></li></ol></li><li><p>浮点类型</p><p> 浮点类型表示有小数部分的数字。Java中有两种浮点类型：</p><p> . float: 占4个字节，共32位，称为单精度浮点数;<br> . double: 占8个字节，共64位，称为双精度浮点数；</p><p>  float和double类型都遵循IEEE754标准，该标准分别为32位和64位浮点数规定了二进制数据表示形式。</p><p>  float=1(数字符号)+8(指数，底数为2)+23(尾数)<br>  double=1(数字符号)+11(指数，底数为2)+52(尾数)</p><p>  在默认情况下，小数及采用十进制科学计数法表示的数字都是double类型，<br>可以把它直接赋值给double类型变量。</p><pre><code>double d1 = 1000.1;double d2 = 1.0001E+3;            //采用十进制科学计数法表示的数字，d2实际取值为1000.1double d3 = 0.0011;double d4 = 0.11E-2;              //采用十进制科学计数法表示的数字，d4实际取值为0.0011如果把double类型的数据直接赋给float类型变量，有可能会造成精度的丢失，因此必须进行强制类型的转换，否则会导致编译错误，例如：float f1 = 1.0                    //编译错误，必须进行强制类型转换；float f2 = 1;                     //合法，把整数1赋值给f2，f2的取值1.0;float f3 = (float)1.0;            //合法，f3的取值为1.0;float f4 = (float)1.5E+55;        //合法, 1.5E+55超出了float类型的取值范围，                                    f4的取值为正无穷大System.out.println(f3);           //打印1.0;System.out.println(f4);           //打印Infinity</code></pre></li></ol></li></ol><p>​<br>                    Float.NaN                         非数字<br>                    Float.POSITIVE_INFINITY           无穷大<br>                    Float.NEGATIVE_INFINITY           负无穷大</p><pre><code>            float f1 = (float)(0.0/0.0);      //f1的取值为Float.NaN            float f2 = (float)(1.0/0.0);      //f2的取值为Float.POSITIVE_INFINITY            float f3 = (float)(-1.0/0.0);     //f3的取值为Float.NEGATIVE_INFINITY            System.out.println(f1);           //打印NaN;            System.out.println(f2);           //打印Infinity            System.out.println(f3);           //打印-Infinity            Java语言之所以提供以上特殊数字， 是为了提高Java程序的健壮性，并且简化编程。当数字运算出错时，可以用浮            点数取值范围内的特殊数字来表示所产生的结果。否则，如果Java程序在进行数学运算遇到错误时就抛出异常，会影            响程序的健壮性，而且程序中必须提供捕获数学运算异常的代码块，增加了编程工作量。 10. 变量的申明和赋值          程序的基本功能是处理数据          程序用变量来表示数据；          程序中必须先定义变量才能使用；          定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：          数据类型  变量名；          Java语言要求变量遵循先定义，再初始化，然后使用的规则。变量的初始化是指自从变量定义以后，首次给它赋初始          值的过程。例：          int a;          //定义变量a          a = 1;          //初始化变量a          a++;            //使用变量a          int b=a;        //定义变量b, 初始化变量b, 使用变量a;          b++;            //使用变量b  11. 推荐命名规则          1) 类名以大写字母开头；          2) 接口名以大写字母开头；          3) 方法名以小写字母开头；          4) 变量名以小写字母开头；          5) 常量名全部大写，多个单词以&quot;_&quot;连接； 12. 理解对象          明白什么是面向对象编程          面向对象的开发方法把软件系统看成各种对象的集合，  对象就是最小的子系统，一组相关的对象能够组合成更复杂的          子系统。面向对象的开发方法将软件系统看成各种对象的集合，  接近人的自然思维方式。          对象是对问题领域中事件的抽象。对象具有以下特性：          1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。     例如学生，成绩单、教师、课和教室。          2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。          3) 对象具有属性和行为。             例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。     小张的属性包括姓名、性别、年龄、身高和体重，行为包括学习、唱歌。             例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。这部手机的属性包括    品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，打电话call()，收发     短信receiveMessage()和发短信sendMessage().          4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。     对象的某些行为会改变对象自身的状态，即属性的取值。             例如小张本来体重为40kg，经为减肥后，体重减到45kg.              肥胖状态: 40kg                    |                    | 减肥行为                    |                                         肥胖状态: 35kg           5) 每个对象都是某个类的实例。小张和小王都属于学生类、     中国和美国都属于国家类、中文和英文都属于语言类。             类是具有相同属性和行为的对象的集合。             同一个类的所有实例都有相同属性，但属性取值不一事实上相同，     但是它们的状态不一定相同。例如小张和小王都属             于学生类，都有姓名、性别、年龄、身高和体重这些属性，     但是他们的属性取值不同。             同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。      13. 创建类          类是一组具有相同属性和行为对象的模板。  面向对象编程的主要任务就是定义对象模型中的各个类。          package sample;          public class Teacher {              /**attributes of a teacher*/              private String name;              private int age;              private double salary;               /** Creates a new instance of Teacher */              public Teacher(String name, int age, double salary) {                  this.salary = salary;                  this.age = age;                  this.name = name;              }              /**operations on properties */              /** get the name of this teacher */              public String getName() { return name; }              /**get the salary of this teacher */              public double getSalary() { return salary; }              /**get the age of teacher teacher */              public int getAge() { return age; }               ……          }          代码解析：           1) package sample;             包声明语句，将Java类放到特定的包中，便于类的组织、权限访问和区分名字相同的类。          2) public class Teacher {...}             类的声明语句，类名为Teacher,     public修饰符意味着这个类可以被公开访问；             声明类的格式：             class 类名 {                 类内容             }          3) private String name;       类的属性(也称为成员变量)的声明语句；   Teacher类有一个name属性，字符串类型，   private修饰符意味着这个属性不能被公开访问。          4) public String getName() { return name; }        方法的声明语句和方法体        方法名为getName，不带参数，String表明返回类型为String。public表明这个方法可以被公开访问。getName后紧跟的大括号为方法体，代表getName的具体实现。             声明方法的格式：              返回值类型 方法名 (参数列表) {                 方法体             }             返回值类型是方法的返回数据的类型, 如果返回值类型为void, 表示没有返回值。             方法名是任意合法的标识符;             参数列表可包含零个或多个参数，参数之间以逗号&quot;,&quot;分开。             方法体每个语句用&quot;;&quot;结束；             方法体中使用return语句返回数据或结束本方法的执行；          注：不介绍构造方法。在面向对象章节会提到。      14. 创建实例          public static void main(String[] args) {                  Teacher gzhu = new Teacher(&quot;George Zhu&quot;, 30, 10000);                  System.out.println(&quot;Teacher: &quot; + gzhu.getName());                  System.out.println(&quot;\tAge: &quot; + gzhu.getAge());                  System.out.println(&quot;\tSalary: &quot; + gzhu.getSalary());          }       main()方法是Java应用程序的入口点，   每个Java应用程序都是从main()方法开始运行的。   作为程序入口的main()方法必须同时符合以下几个条件：          . 用public static修饰；          . 返回类型为void;          . 方法名为main;          . 参数类型为String[];          包含main方法的类又叫主程序类。          类创建好之后，通过new关键字创建具体对象。它有以下作用：          . 为对象分配内存空间，将对象的实例变量自动初始化为其变量类型的默认值；          . 如实例变量显示初始化，将初始化值赋给实例变量；          . 调用构造方法；          . 返回对象的引用；          注：结合实例，并画内存分配图讲解。      15. 基本类型和引用类型的区别               1) 基本类型代表简单的数据类型，比如整数和字符。             引用类型代表复杂数据类型，引用类型所引用的     实例包括操纵这种数据类型的行为。             通过&quot;.&quot;运算符，就能访问引用变量所引用的实例的方法.          2) 基本类型Java虚拟机会为其分配数据类型实际占用的内存空间；             引用类型仅是一个指向堆区中某个实例的指针。             例：public class Counter {                    int count = 13;                 }                 Counter counter = new Counter();                 counter引用变量-------------&gt; Counter实例                                                count变量(占4个字节,值为13)        counter引用变量的取值为Counter实例的内存地址。        counter引用变量本身也占一定的内存空间，到底占用多少内存空间取决于Java虚拟机的实现，这对Java程序是透明的。         注：counter引用变量到底位于Java虚拟机的运行时数据区的哪个区？     取决于counter变量的作用域，     如果是局部变量，则位于Java栈区；             如果是静态成员变量，则位于方法区；             如果是实例成员变量，则位于堆区；</code></pre><p>​<br>    面向对象编程的步骤：<br>      1）从需求中寻找名词性短语，构建class,有相应的属性和行为<br>      2）产生对象<br>      3）访问属性，方法(.)</p><p> 第二章（续）<br>一.基本数据类型变量和引用数据类型变量：<br>   1)使用基本数据类型定义的变量叫做基本数据类型变量<br>    int a=10;<br>       保存是数据本身的数值(二进制)<br>   2）使用引用数据类型定义的变量叫做引用数据类型变量<br>    Teacher t=new Teacher();<br>       保存是堆区开辟的地址<br>   new关键字：<br>     a)在栈区开辟空间保存对象的引用<br>     b)在堆区开辟空间保存对象本身<br>     c)堆区的地址赋值给栈区的对象的引用<br>二：运行时数据区<br>一个完整的Java程序运行过程会涉及以下内存区域<br>方法区/代码区：存放类的信息<br>堆区：用来存放动态产生的数据，比如new出来的对象。<br>     注意创建出来的对象只包含属于各自的成员变量，<br>     并不包括成员方法。因为同一个类的对象拥有各自<br>     的成员变量，存储在各自的堆中，但是他们共享该<br>     类的方法，并不是每创建一个对象就把成员方法复制一次。<br>栈区：保存局部变量的值，包括：<br>     1.用来保存基本数据类型的值；<br>     2.保存类的实例，即堆区对象的引用(指针)。<br>       也可以用来保存加载方法时的帧<br>常量池：JVM为每个已加载的类型维护一个常量池，<br>        常量池就是这个类型用到的常量的一个有序集合。<br>    常量池存在于堆中。<br>PC寄存器：指向下一条需要执行的指令，将该数据传递给CPU</p><p>package com.briup.ch05;<br>public class Student<br>{<br>    //声明变量<br>    int age;<br>    String name;<br>    int classId;<br>    //无参构造器<br>    public Student(){</p><pre><code>}//有参构造器public Student(int age,String name,int classId){    this.age=age;    this.name=name;    this.classId=classId;}//赋值或修改值public void setClassId(int classId){this.classId=classId;}public void setName(String name){this.name=name;}</code></pre><p>   //单一取值<br>   public String getName(){<br>   return name;<br>   }<br>public void display(){<br>System.out.println(name+” “+age+” “+classId);<br>}<br>}</p><p>package com.briup.ch05;<br>    public class VariableTest<br>    {<br>        public static void main(String… args){<br>        int a;<br>        a=20;<br>        int b=a;<br>        int c=b++;<br>        System.out.println(b);</p><pre><code>    }}</code></pre><p>package com.briup.ch05;<br>//import com.briup.ch04.Student;<br>    public class StudentTest<br>    {<br>        public static void main(String… args){<br>            //如果你所用的其他类和当前类在同一包下，不需要导包，但是如果不在同一包下，必须指定<br>           Student stu=new Student();<br>           stu.setName(“李四”);<br>           stu.display();<br>           Student stu1=new Student(18,”张三”,2);//初始化数据<br>               stu1.setClassId(1);<br>              // String name=stu1.getName();<br>               System.out.println(stu1.getName());<br>           stu1.display();<br>           Student stu2=stu1;<br>           stu2.setClassId(2);<br>           stu2.display();<br>        }<br>    }</p><p>package com.md02;</p><p>public class Teacher<br>{<br>    public String name;        //姓名<br>    public int age;            //年龄<br>    public double salary;    //薪水</p><pre><code>//用于年龄增加的方法public void increaseAge(){    age++;}    </code></pre><p>}</p><p>package com.md02;</p><p>public class TeacherTest<br>{<br>        public static void main(String[] args)<br>    {<br>        //创建对象<br>        Teacher t = new Teacher();</p><pre><code>    //为对象的属性赋值    t.name = &quot;George&quot;;    t.age = 30;    t.salary = 10000;    //输出对象的属性    System.out.println(&quot;name=&quot; + t.name);    System.out.println(&quot;age=&quot; + t.age);    System.out.println(&quot;salary=&quot; + t.salary);    //调用使年龄增加的方法并输出增加后的年龄    t.increaseAge();    System.out.println(&quot;new age=&quot; + t.age);}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第四天笔记</title>
      <link href="/2018/10/18/index3/"/>
      <url>/2018/10/18/index3/</url>
      
        <content type="html"><![CDATA[<p>目标： 1. 标识符、关键字和类型介绍；</p><pre><code>2. 如何构建类?</code></pre><p>第二章： Identifiers, Keywords and Types<br>目标：1. 注释作用：使部分内容只为程序员可见，<br>         不为编译器所编译、虚拟机所执行；增加程序的可读性<br>     位置：类声明前后、方法声明前后、属性声明前后、方法体中。<br>          几乎可以在一个源文件任意位置，但不能在一个关键字字<br>      符中插入注释。<br>     类型：1) 单行注释：//text——从”//“到本行结束的所有字符均作为注释而被编译器忽略<br>           2) 多行注释：/<em>text</em>/——从”/<em>“到”</em>/“间的所有字符会被编译器忽略<br>           3) 文档注释：/<strong> text */——从”/</strong>“到”<em>/“间的所有字符会被编译器忽略。<br>       当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的<br>       成员方法的声明)之前时，会作为JavaDoc文档的内容；<br>                  示例：1) //package declaration<br>                          package ch01;                        //允许；<br>                       2) package /</em>package declaration<em>/ch01;            //允许；<br>                       3) class /</em>class declaration<em>/ FirstJavaProgram {        //允许；<br>                          …}<br>                       4) System.out./</em>out content to console<em>/println(“Hello Java”);     //允许；<br>                       5) System.out.print/</em>out content to console*/ln(“Hello Java”);     //不允许；</p><pre><code>           javadoc -author -version -d doc *.java2. 分号、块和空格1) 每个语句短语以;结束 ;    2) 代码段以{}结束;    3) 空白处（空格、tab键、新行和回车(几个语句短语连接在一起））是无关紧要的。3. 标识符:类、方法和变量的名字   1) java标识符以字母、_和$开头，不能以数字开头，后跟字母、数字、“_”和“$”的组合;   2) 大小写敏感   3) 没有长度限制。   4) 不能使用java的关键字   举例：  合法标识符       非法标识符            try                    try#            GROUP_7                7GROUP            openDoor               open-door            boolean1               boolean</code></pre><ol start="4"><li><p>关键字<br>Java语言的关键字是程序代码中的特殊字符。包括：</p><pre><code>. 类和接口的声明——class, extends, implements, interface. 包引入和包声明——import, package. 数据类型——boolean, byte, char, double, float, int, long, short. 某些数据类型的可选值——false, true, null. 流程控制——break, case, continue, default, do, else, for, if, return, switch, while. 异常处理——catch, finally, throw, throws, try. 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile. 操作符——instanceof. 创建对象——new. 引用——this, super. 方法返回类型——void Java语言的保留字是指预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，这有别于C++； . 程序中标识符不能以关键字命名；</code></pre><ol start="5"><li><p>基本类型：程序的基本功能是处理数据,程序用变量来表示数据；</p><pre><code>    程序中必须先定义变量才能使用；定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：            数据类型  变量名；    Java语言把数据类型分为基本类型和引用类型。</code></pre><p>  基本数据类型</p><pre><code>数值类型     整数类型:byte,short,int,long 浮点数类型:float,double布尔类型：boolean字符类型：char</code></pre><p>  引用数据类型</p><pre><code>类类型:比如String        接口类型        数组类型</code></pre></li></ol><p>接下来，我们主要关注基本数据类型，关注各种基本数据类型<br>有什么样的取值范围？占用多少内存空间？     </p><ol start="6"><li><p>boolean类型</p><pre><code>位置            boolean类型变量取值   Java源程序             只能是true或falseclass文件              用int或byte表示boolean虚拟机中           用整数0来表示false, 有任意一个非零整数表示true强调，在Java源程序中不允许把整数或null赋给boolean类型的变量，</code></pre><p>这是有别于其它语言(如c语言)的地方. 例：</p><pre><code>boolean isMarried = 0;          //编译出错，提示类型不匹配boolean isMarried = null;       //编译出错，提示类型不匹配</code></pre></li><li><p>文本数据类型——char和String</p><p>  1) 字符编码:Java语言对文本字符<br>采用Unicode字符编码。<br>由于计算机内存只能存取二进制数据，<br>因此必须为各个字符进行编码。<br>所谓字符编码，是指用一串二进制数据来表示特定的字符。<br>常见的字符编码包括：<br>a. ASCII字符编码</p><pre><code>ASCII--</code></pre><p>Amecian Standard Code for Information Interchange(<br>美国信息交换标准代码).<br>主用于表达现代英语<br>和其他西欧语言中的字符。<br>它是现今最通用的单字节编码系统，<br>它只用一个字节的7位，<br>一共表示128个字符。</p><pre><code>b. ISO-8859-1字符编码,又称为Latin-1, 是国际标准化组织(ISO)为西欧语言中的字符制定的编码，</code></pre><p>用一个字节(8位)来为字符编码，与ASCII字符编码兼容。所谓兼容，是指对于相同的字符，它的ASCII字符编码<br>和ISO-8859-1字符编码相同。</p><pre><code>c. GB2312字符编码   它包括对简体中文字符的编码，</code></pre><p>  一共收录了7445个字符(6763个汉字+682个其他字符. 它与ASCII字符编码兼容。</p><pre><code>d. GBK字符编码    对GB2312字符编码的扩展，</code></pre><p>   收录了21886个字符(21003个字符+其它字符), 它与GB2312字符编码兼容。</p><pre><code> e. Unicode字符编码：        由国际Unicode协会编制，收录了全世界所有语言文字中的字符，是一种跨平台的字符编码。        UCS(Universal Character Set)是指采用Unicode字符编码的通用字符集。        Unicode具有两种编码方案：        . 用2个字节(16位)编码，被称为UCS-2, Java语言采用;        . 用4个字节(32位)编码，被称为UCS-4; f. UTF字符编码     有些操作系统不完全支持16位或32位的Unicode字符编码，UTF(UCS Transformation Format)字符编码能够把     Unicode字符编码转换为操作系统支持的编码，常见的UTF字符编码包括UTF-8, UTF-7和UTF-16.</code></pre><p> 2) char的几种可能取值<br>Java语言采用UCS-2字符编码，字符占2个字节。</p><pre><code>字符a的二进制数据形式为 0000 0000 0110 0001     十六进制数据形式为 0x0061       十进制数据形式为 97以下4种赋值方式是等价的：char c = &apos;a&apos;;char c = &apos;\u0061&apos;;      //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 0x0061;        //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 97;            //设定&quot;a&quot;的十进制数据的Unicode字符编码</code></pre><p> 3) 转义字符</p><pre><code>Java编程人员在给字符变量赋值时，通常直接从键盘输入特定的字符，</code></pre><p>而不会使用Unicode字符编码，因为很难记住各种字符的Unicode<br>字符编码值。对于有些特殊字符，比如单引号，如不知道它的<br>Unicode字符编码，直接从键盘输入编译错误：<br>   char c = ‘’’;           //编码出错</p><pre><code>为了解决这个问题，可采用转义字符来表示单引号和其他特殊字符： char c = &apos;\&apos;&apos;;char c = &apos;\\&apos;;转义字符以反斜杠开头，常用转义字符：\n           换行符，将光标定位到下一行的开头；\t           垂直制表符，将光标移到下一个制表符的位置；\r           回车，将光标定位到当前行的开头，不会移到下一行；\\           反斜杠字符\&apos;           单引号字符</code></pre><ol start="8"><li><p>整数类型<br> byte, short, int和long都是整数类型，并且都是有符号整数。<br>与有符号整数对应的是无符号整数，两者的区别在于<br> 把二进制数转换为十进制整数的方式不一样。<br>. 有符号整数把二进制数的首位作为符号数，<br>当首位是0时，对应十进制的正整数，<br>当首位是1时，对应十进制的负整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是-128 - 127。<br>. 无符号整数把二进制数的所有位转换为正整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是0 - 255。</p><pre><code>在Java语言中，为了区分不同进制的数据，八进制数以“0”开头，十六制以“0x”开头。举例： 一个字节的二进制数        八进制数         十六进制数        有符号十进制数       无符号十进制数0000 0000                 0000             0x00              0                    01111 1111                 0377             0xFF              -1                   2550111 1111                 0177             0x7F              127                  1271000 0000                 0200             0x80              -128                 128</code></pre><p>  如果一个整数值在某种整数类型的取值范围内，就可以把它直接赋给这种类型的变量，否则必须进行强制类型的转换。</p><pre><code>byte = 13;如129不在byte类型的取值范围(-128-127)范围内，则必须进行强制类型的转换。byte b = (byte)129;    //变量b的取值为-127.如果一个整数后面加上后缀——大写&quot;L&quot;或小写&quot;l&quot;, 就表示它是一个long类型整数。以下两种赋值是等价的：long var = 100L;         //整数100后面加上大写的后缀&quot;L&quot;，表示long型整数；long var = 100l;         //整数100后面加上大写的后缀&quot;l&quot;，表示long型整数；Java语言允许把八进制数(以&quot;0&quot;开头), 十六进制数(以&quot;0x&quot;开头)和十进制数赋给整数类型变量，例如：int a1 = 012;                 //012为八进制数，变量a1的十进制取值为10int a2 = 0x12;                //0x12为十六进制数，变量a2的十进制取值为18int a3 = 12;                  //12为十进制数，变量a3的十进制取值为12int a4 = 0xF1;                //0xF1为十六制数，变量a4的十进制取值为241byte b = (byte)0xF1           //0xF1为十六制数，变量b的十进制取值为-15</code></pre><p>注意：<br>数据类型的转换：<br>1)强制类型转换:精度高向精度低的转换<br>byte b = (byte)129;<br>2)隐式类型转换:精度低向精度高的转换<br>byte&lt;short&lt;int&lt;long&lt;float&lt;double</p></li></ol></li><li><p>浮点类型</p><p> 浮点类型表示有小数部分的数字。Java中有两种浮点类型：</p><p> . float: 占4个字节，共32位，称为单精度浮点数;<br> . double: 占8个字节，共64位，称为双精度浮点数；</p><p>  float和double类型都遵循IEEE754标准，该标准分别为32位和64位浮点数规定了二进制数据表示形式。</p><p>  float=1(数字符号)+8(指数，底数为2)+23(尾数)<br>  double=1(数字符号)+11(指数，底数为2)+52(尾数)</p><p>  在默认情况下，小数及采用十进制科学计数法表示的数字都是double类型，<br>可以把它直接赋值给double类型变量。</p><pre><code>double d1 = 1000.1;double d2 = 1.0001E+3;            //采用十进制科学计数法表示的数字，d2实际取值为1000.1double d3 = 0.0011;double d4 = 0.11E-2;              //采用十进制科学计数法表示的数字，d4实际取值为0.0011如果把double类型的数据直接赋给float类型变量，有可能会造成精度的丢失，因此必须进行强制类型的转换，否则会导致编译错误，例如：float f1 = 1.0                    //编译错误，必须进行强制类型转换；float f2 = 1;                     //合法，把整数1赋值给f2，f2的取值1.0;float f3 = (float)1.0;            //合法，f3的取值为1.0;float f4 = (float)1.5E+55;        //合法, 1.5E+55超出了float类型的取值范围，                                    f4的取值为正无穷大System.out.println(f3);           //打印1.0;System.out.println(f4);           //打印Infinity</code></pre></li></ol></li></ol><p>​<br>                    Float.NaN                         非数字<br>                    Float.POSITIVE_INFINITY           无穷大<br>                    Float.NEGATIVE_INFINITY           负无穷大</p><pre><code>            float f1 = (float)(0.0/0.0);      //f1的取值为Float.NaN            float f2 = (float)(1.0/0.0);      //f2的取值为Float.POSITIVE_INFINITY            float f3 = (float)(-1.0/0.0);     //f3的取值为Float.NEGATIVE_INFINITY            System.out.println(f1);           //打印NaN;            System.out.println(f2);           //打印Infinity            System.out.println(f3);           //打印-Infinity            Java语言之所以提供以上特殊数字， 是为了提高Java程序的健壮性，并且简化编程。当数字运算出错时，可以用浮            点数取值范围内的特殊数字来表示所产生的结果。否则，如果Java程序在进行数学运算遇到错误时就抛出异常，会影            响程序的健壮性，而且程序中必须提供捕获数学运算异常的代码块，增加了编程工作量。 10. 变量的申明和赋值          程序的基本功能是处理数据          程序用变量来表示数据；          程序中必须先定义变量才能使用；          定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：          数据类型  变量名；          Java语言要求变量遵循先定义，再初始化，然后使用的规则。变量的初始化是指自从变量定义以后，首次给它赋初始          值的过程。例：          int a;          //定义变量a          a = 1;          //初始化变量a          a++;            //使用变量a          int b=a;        //定义变量b, 初始化变量b, 使用变量a;          b++;            //使用变量b  11. 推荐命名规则          1) 类名以大写字母开头；          2) 接口名以大写字母开头；          3) 方法名以小写字母开头；          4) 变量名以小写字母开头；          5) 常量名全部大写，多个单词以&quot;_&quot;连接； 12. 理解对象          明白什么是面向对象编程          面向对象的开发方法把软件系统看成各种对象的集合，  对象就是最小的子系统，一组相关的对象能够组合成更复杂的          子系统。面向对象的开发方法将软件系统看成各种对象的集合，  接近人的自然思维方式。          对象是对问题领域中事件的抽象。对象具有以下特性：          1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。     例如学生，成绩单、教师、课和教室。          2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。          3) 对象具有属性和行为。             例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。     小张的属性包括姓名、性别、年龄、身高和体重，行为包括学习、唱歌。             例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。这部手机的属性包括    品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，打电话call()，收发     短信receiveMessage()和发短信sendMessage().          4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。     对象的某些行为会改变对象自身的状态，即属性的取值。             例如小张本来体重为40kg，经为减肥后，体重减到45kg.              肥胖状态: 40kg                    |                    | 减肥行为                    |                                         肥胖状态: 35kg           5) 每个对象都是某个类的实例。小张和小王都属于学生类、     中国和美国都属于国家类、中文和英文都属于语言类。             类是具有相同属性和行为的对象的集合。             同一个类的所有实例都有相同属性，但属性取值不一事实上相同，     但是它们的状态不一定相同。例如小张和小王都属             于学生类，都有姓名、性别、年龄、身高和体重这些属性，     但是他们的属性取值不同。             同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。      13. 创建类          类是一组具有相同属性和行为对象的模板。  面向对象编程的主要任务就是定义对象模型中的各个类。          package sample;          public class Teacher {              /**attributes of a teacher*/              private String name;              private int age;              private double salary;               /** Creates a new instance of Teacher */              public Teacher(String name, int age, double salary) {                  this.salary = salary;                  this.age = age;                  this.name = name;              }              /**operations on properties */              /** get the name of this teacher */              public String getName() { return name; }              /**get the salary of this teacher */              public double getSalary() { return salary; }              /**get the age of teacher teacher */              public int getAge() { return age; }               ……          }          代码解析：           1) package sample;             包声明语句，将Java类放到特定的包中，便于类的组织、权限访问和区分名字相同的类。          2) public class Teacher {...}             类的声明语句，类名为Teacher,     public修饰符意味着这个类可以被公开访问；             声明类的格式：             class 类名 {                 类内容             }          3) private String name;       类的属性(也称为成员变量)的声明语句；   Teacher类有一个name属性，字符串类型，   private修饰符意味着这个属性不能被公开访问。          4) public String getName() { return name; }        方法的声明语句和方法体        方法名为getName，不带参数，String表明返回类型为String。public表明这个方法可以被公开访问。getName后紧跟的大括号为方法体，代表getName的具体实现。             声明方法的格式：              返回值类型 方法名 (参数列表) {                 方法体             }             返回值类型是方法的返回数据的类型, 如果返回值类型为void, 表示没有返回值。             方法名是任意合法的标识符;             参数列表可包含零个或多个参数，参数之间以逗号&quot;,&quot;分开。             方法体每个语句用&quot;;&quot;结束；             方法体中使用return语句返回数据或结束本方法的执行；          注：不介绍构造方法。在面向对象章节会提到。      14. 创建实例          public static void main(String[] args) {                  Teacher gzhu = new Teacher(&quot;George Zhu&quot;, 30, 10000);                  System.out.println(&quot;Teacher: &quot; + gzhu.getName());                  System.out.println(&quot;\tAge: &quot; + gzhu.getAge());                  System.out.println(&quot;\tSalary: &quot; + gzhu.getSalary());          }       main()方法是Java应用程序的入口点，   每个Java应用程序都是从main()方法开始运行的。   作为程序入口的main()方法必须同时符合以下几个条件：          . 用public static修饰；          . 返回类型为void;          . 方法名为main;          . 参数类型为String[];          包含main方法的类又叫主程序类。          类创建好之后，通过new关键字创建具体对象。它有以下作用：          . 为对象分配内存空间，将对象的实例变量自动初始化为其变量类型的默认值；          . 如实例变量显示初始化，将初始化值赋给实例变量；          . 调用构造方法；          . 返回对象的引用；          注：结合实例，并画内存分配图讲解。      15. 基本类型和引用类型的区别               1) 基本类型代表简单的数据类型，比如整数和字符。             引用类型代表复杂数据类型，引用类型所引用的     实例包括操纵这种数据类型的行为。             通过&quot;.&quot;运算符，就能访问引用变量所引用的实例的方法.          2) 基本类型Java虚拟机会为其分配数据类型实际占用的内存空间；             引用类型仅是一个指向堆区中某个实例的指针。             例：public class Counter {                    int count = 13;                 }                 Counter counter = new Counter();                 counter引用变量-------------&gt; Counter实例                                                count变量(占4个字节,值为13)        counter引用变量的取值为Counter实例的内存地址。        counter引用变量本身也占一定的内存空间，到底占用多少内存空间取决于Java虚拟机的实现，这对Java程序是透明的。         注：counter引用变量到底位于Java虚拟机的运行时数据区的哪个区？     取决于counter变量的作用域，     如果是局部变量，则位于Java栈区；             如果是静态成员变量，则位于方法区；             如果是实例成员变量，则位于堆区；</code></pre><p>​<br>    面向对象编程的步骤：<br>      1）从需求中寻找名词性短语，构建class,有相应的属性和行为<br>      2）产生对象<br>      3）访问属性，方法(.)             </p><p>第二章：标识符、关键字、类型</p><p>1） 基础实验：</p><p>\1. 单行、多行注释例子</p><p>符中插入注释。</p><p>​     类型：1) 单行注释：//text——从”//“到本行结束的所有字符均作为注释而被编译器忽略</p><p>​           2) 多行注释：/<em>text</em>/——从”/<em>“到”</em>/“间的所有字符会被编译器忽略</p><p>​           3) 文档注释：/<strong> text */——从”/</strong>“到”*/“间的所有字符会被编译器忽略。</p><p>\2. 写一java程序添加文档注释，通过javadoc产生API文档（包含作者、版本等信息）</p><p>\3. 数据类型测试例子</p><p>\4. 类、对象测试例子</p><p>二）扩展实验：</p><p>\1. 找零问题：有2元，买东西花了1.1元，问找零多少?</p><p>System.out.println(2.00-1.10);    </p><p>​    注意：在需要精确答案的地方，要避免使用float或double；对于货币计算，要使用int、long或BigDecimal</p><p>\2. 长整除问题：int(-2^32~2^31-1) -2147483648~2147483647</p><p>​    long micros_per_day = 24 <em> 60 </em> 60 <em> 1000 </em> 1000;</p><p>​    long millis_per_day = 24 <em> 60 </em> 60 * 1000;</p><p>​    System.out.println(micros_per_day / millis_per_day);</p><p>输出结果。    </p><p>注意：当你操作很大的数字时，一定要提防溢出；较大整数运算可使用BigInteger</p><p>\3. 初级问题</p><p>​    System.out.println(12345 + 5432l)输出结果。</p><p>​    注意：做题要细心；在long类型字面常量中，一定要用大写的L</p><p>三）作业：</p><p>\1. java中注释的分类?</p><p>单行、多行注释</p><p>\2. java中标示符的命名规则?</p><p> 1) java标识符以字母、<em>和$开头，不能以数字开头，后跟字母、数字、“</em>”和“$”的组合;</p><p>​       2) 大小写敏感</p><p>​       3) 没有长度限制。</p><p>​       4) 不能使用java的关键字</p><p>​       举例：  合法标识符       非法标识符</p><p>​                try                    try#</p><p>​                GROUP_7                7GROUP</p><p>​                openDoor               open-door</p><p>​                boolean1               boolean</p><p>\3. java中有哪些常用的基本数据类型</p><p>数值类型</p><p>​                   整数类型:byte,short,int,long</p><p>​               浮点数类型:float,double</p><p>​              布尔类型：boolean</p><p>​              字符类型：char</p><p>​           引用数据类型</p><p>​               类类型:比如String</p><p>​                       接口类型</p><p>​                       数组类型</p><p>4.基本数据类型和引用类型的区别</p><p>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。</p><p>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三天笔记</title>
      <link href="/2018/10/18/index2/"/>
      <url>/2018/10/18/index2/</url>
      
        <content type="html"><![CDATA[<p>一：方法的定义和方法的调用<br>   方法的定义：修饰符  方法的返回值 方法名(参数列表){<br>            方法体<br>        }<br>      如果没有方法的返回值就写成:void<br>      参数列表：参数类型 参数名<br>   方法的调用：方法名(参数值)<br>二：javac -d . First.java<br>  -d指定生成的class文件存放的路径<br>     连同包一起编译。<br>java com.briup.ch01.First<br>   java运行class文件，先类加载。<br>   将class文件加载内存中。<br>   在CLASSPATH配置的路径下找class文件。<br>CLASSPATH与-d后面指定的路径是一样</p><p>第二天：<br>目标： 1. 标识符、关键字和类型介绍；</p><pre><code>2. 如何构建类?</code></pre><p>第二章： Identifiers, Keywords and Types<br>目标：1. 注释作用：使部分内容只为程序员可见，<br>         不为编译器所编译、虚拟机所执行；增加程序的可读性<br>     位置：类声明前后、方法声明前后、属性声明前后、方法体中。<br>          几乎可以在一个源文件任意位置，但不能在一个关键字字<br>      符中插入注释。<br>     类型：1) 单行注释：//text——从”//“到本行结束的所有字符均作为注释而被编译器忽略<br>           2) 多行注释：/<em>text</em>/——从”/<em>“到”</em>/“间的所有字符会被编译器忽略<br>           3) 文档注释：/<strong> text */——从”/</strong>“到”<em>/“间的所有字符会被编译器忽略。<br>       当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的<br>       成员方法的声明)之前时，会作为JavaDoc文档的内容；<br>                  示例：1) //package declaration<br>                          package ch01;                        //允许；<br>                       2) package /</em>package declaration<em>/ch01;            //允许；<br>                       3) class /</em>class declaration<em>/ FirstJavaProgram {        //允许；<br>                          …}<br>                       4) System.out./</em>out content to console<em>/println(“Hello Java”);     //允许；<br>                       5) System.out.print/</em>out content to console*/ln(“Hello Java”);     //不允许；</p><pre><code>           javadoc -author -version -d doc *.java2. 分号、块和空格1) 每个语句短语以;结束 ;    2) 代码段以{}结束;    3) 空白处（空格、tab键、新行和回车(几个语句短语连接在一起））是无关紧要的。3. 标识符:类、方法和变量的名字   1) java标识符以字母、_和$开头，不能以数字开头，后跟字母、数字、“_”和“$”的组合;   2) 大小写敏感   3) 没有长度限制。   4) 不能使用java的关键字   举例：  合法标识符       非法标识符            try                    try#            GROUP_7                7GROUP            openDoor               open-door            boolean1               boolean</code></pre><ol start="4"><li>关键字<br>Java语言的关键字是程序代码中的特殊字符。包括：<pre><code>. 类和接口的声明——class, extends, implements, interface. 包引入和包声明——import, package. 数据类型——boolean, byte, char, double, float, int, long, short. 某些数据类型的可选值——false, true, null. 流程控制——break, case, continue, default, do, else, for, if, return, switch, while. 异常处理——catch, finally, throw, throws, try. 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile. 操作符——instanceof. 创建对象——new. 引用——this, super. 方法返回类型——void Java语言的保留字是指预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，这有别于C++； . 程序中标识符不能以关键字命名；</code></pre></li></ol><p>​     </p><p>/<em>这是某包</em>/<br>package com.briup.ch03;<br>import java.util.<em>;<br>/</em></p><ul><li>好这是一个测试类<br><em>First 创建者：pgc</em>/<br>public class First{<br>public static void main(String… args){<br>System.out.println(“hello:”+new Date());<br>display();<br>int c=add(1,2);<br>System.out.println(c);<br>First f=new First();<br>f.delete();<br>}<br>public static int add(int a,int b){<br>return a+b;<br>}<br>/<em></em>哈哈<br><em>/<br>public static void display(){<br>int a;/</em>gg*/<br>System.out.println(“display”);<br>}<br>public void delete(){<br>System.out.println(“delete”);<br>}<br>}</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/18/hello-world/"/>
      <url>/2018/10/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二天笔记</title>
      <link href="/2018/10/17/index1/"/>
      <url>/2018/10/17/index1/</url>
      
        <content type="html"><![CDATA[<p>第一章  corejava的入门<br>一：什么是语言<br>语言=os+数据结构+算法+思想<br>os:操作系统<br>数据结构：队，栈，二叉树，链表<br>算法:做游戏开发时非常重要<br>面试题：int a&gt;0,b&gt;0只使用一条输出语句输出a,b的最大值<br>       System.out.println((|a+b|+|a-b|)/2);<br>二：安装jdk<br>1)根据不同的操作系统下载不同的jdk<br>   Java有三个版本：<br>      Java SE:开发桌面应用程序，比如QQ<br>      Java EE:开发企业级应用程序<br>      Java ME:开发移动应用<br>2)安装jdk<br>   如果是windows,直接双击<br>   如果是unix,在shell中运行<br>        a)拷贝到家目录<br>      b)sudo chmod 777 /opt<br>      c)cp jdk_6u32_liunx_i586.bin /opt<br>      d)cd /opt<br>      e)sudo ./jdk_6u32_liunx_i586.bin<br>   如果是unix的.tar.gz文件：<br>       a)将tar.gz拷贝到家目录并解压<br>       b)sudo chmod 777 /opt<br>       c)sudo mv jdk1.7.0_04 /opt<br>3)配置环境变量<br>         在.bashrc中配置环境变量，打开该文件，追加内容<br>     vi ~/.bashrc<br>        //添加以下内容<br>        CLASSPATH=.<br>       JAVA_HOME=/opt/jdk1.6.0_32<br>      PATH=$PATH:$JAVA_HOME/bin<br>      export CLASSPATH JAVA_HOME PATH<br>   CLASSPATH指定类加载的路径<br>   JAVA_HOME指定JDK的安装目录<br>三：JDK：java Development kit<br>  Sun公司在推出Java语言的同时，也推出了Java的一系列开发工具，<br>  如JDK——  Java Development Kit(Java开发工具包)。<br> 可以从网上免费下载。通常以JDK的版本来定义Java的版本。<br> 时间      版本           在Java标准函数库中的类(class)的数量</p><p>1996     JDK1.0(Java1.0)        250        重点applet<br>1997    JDK1.1(Java1.1)     500        比较适于开发图形界面<br>1998    JDK1.2(Java2)       2300    可达到平台原始速度，<br>            可用于书写正规企业级应用程序或移动应用程序<br>2000    JDK1.3(Java2)<br>2002    JDK1.4(Java2)                计算能力大幅度提升<br>2004    JDK1.5(Java5.0)代号Tiger老虎3500  对语言本身作重大改变，                    更稳定、更安全、更高效<br>2006    JDK1.6(Java6.0)代号Mustang野马<br>2011    JDK1.7(Java7.0)代号Dolphin海豚<br>2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。<br>补充：JDK主要包括内容：<br>a)Java虚拟机：负责解析和执行Java程序.<br>              Java虚拟机可运行在各种平台上<br>b)JDK类库：提供最基础的Java类及各种实用类。<br>            这些类放在$JAVA_HOME/jre/lib/rt.java<br>          java.lang, java.io, java.util,<br>          javax.swing,java.sql包中的类都位于JDK类库中。<br>c)开发工具:这些开发工具都是可执行程序.<br>            主要包括：位于$JAVA_HOME/bin<br>             javac.exe    编译工具；<br>　　　　     java.exe     运行工具；<br>             javadoc.exe  生成JavaDoc文档的工具<br>             jar.exe      打包工具等。</p><p>四： 理解Java语言特征；<br>Java语言包括语法规则和语法规则的实现。<br>Sun公司对Java语言有自己的一份参考实现：JDK。<br>a. 编程语言：语言本质即规则: 字符集、词法规则、句法规则(条件语句、循环语句等);桌面应用程序  ：拥有图形化用户接口的软件；服务器应用程序：通过浏览器访问运行；<br>b. 开发环境：开发程序，不管是桌面应用还是服务器应用，均需要JDK的支持。<br>c. 应用环境：面向应用程序，而不是开发系统程序或者硬件编程，比如说驱动就是系统程序，系统程序一般用c语言<br>d. 部署环境：服务器应用程序需部署运行在服务器应用程序上，服务器本身也是一个Java程序,用Java语言编写的服务器应用程序部署运行时也需要Java语言的支持，将java代码打成一个包，部署到服务器这个过程叫做部署环境</p><p>五. 为什么发明Java?<br>为什么发明了java，换而言之，java有哪些优点呢？<br>a. 提供一个解释环境》JVM<br>1) 加速开发: Java当初目的是开发适用于智能化电子消费设备上的软件，它是基于C++语言，但做了简化，能加速软件的开发过程<br>2) 一次编译到处运行: 跨平台<br>3) 多线程：多线程编程的简单性是Java成为流行的服务器端开发语言的主要原因之一<br>4) 支持动态更新: 软件代码文件的替换即更新，<br>                 类与类之间有调用，如果其中某<br>         一个改变不会影响其他程序。<br>         并且也不需要都编译打包。只需要做<br>         软件代码文件的替换操作。</p><p>b. 提供一个比较容易的方式编程<br>    1) 更健壮：没有指针、没有内存管理；<br>        在开发者层面上没有指针，但是在底层还是有指针。<br>        Java引入了引用的概念。<br>        C:malloc()手动分配内存，free()手动释放内存<br>        C++:new手动分配内存，delete()手动释放内存<br>           手动释放内存对内存回收比较好。但是也有<br>            释放错误(释放一个已经释放的内存，<br>                    释放一个没有开辟的内存)<br>        Java开发程序员不需要关心什么时候释放内存。<br>        由GC垃圾回收器来管理内存的回收。<br>    2) 纯粹的面向对象的编程：在Java中认为一切均是对象，<br>      对象有属性以及改变属性值的方法。通过Java编程围绕<br>      着构建对象的模板、实例化对象、调用对象的方法和属性等来进行。<br>c. 那么如何实现上面这些呢？<br>虚拟机JVM提供一个解释环境，让java代码可以运行。<br>垃圾回收机制让程序员无需在代码中进行内存管理。<br>代码安全校验保证java代码的安全性。</p><p>六. 理解Java虚拟机的特征；<br>  Jvm是什么？简称java 虚拟机（java virtual machine），<br>是用软件来模拟一个虚拟的环境。我们用java编写的源程<br>序经过编译以后生成字节码文件，Jvm 提供了一个解释运<br>行 java字节码文件的环境，只要在不同操作系统上安装了<br>jvm后，就能对同一个java程序进行解释运行，这就java的<br>跨平台，一次编译，到处运行。</p><p>七. 描述垃圾收集的概念；<br>什么叫垃圾回收：<br>1)垃圾：无用对象所占据的内存空间；<br>2)垃圾回收：将无用对象所占据内存空间进行回收的过程；<br>3)为什么要垃圾回收？<br> 对象创建，需要占用内存空间，在一个程序运行过程<br> 中要创建无数个对象，如果对象永久占用内存，那么内存<br> 很快会消费光，倒致后续对象无法创建或者出现内存不足<br> 的错误。因此必须采取一定措施及时回收那些无用对象的<br> 内存，这样保证内存可以被重复利用。</p><p>C++等程序由程序员显示进行内存释放，这样有可能：<br>  c:malloc()   free()<br>  c++:new   delete<br>1) 忘记内存释放，倒致无端的内存占用；<br>2) 释放核心类库占用内存，倒致系统崩溃；</p><p>Java中垃圾回收处理：<br>1) 由JVM虚拟机通过一个系统级别的垃圾回收器线程自动完成，<br>不会忘记也不会释放错，系统更加稳定；</p><p>Java中垃圾回收处理特点：<br>1) 由虚拟机通过垃圾回收器线程自动完成；<br>   是优先级别比较低的线程。没有办法去<br>   控制该线程运行。<br>   进程：是资源分配的最小单位<br>   线程：是程序运行的最小单位<br>2)GC什么情况下工作:<br>   a)内存空闲时<br>   b)内存严重不足时<br>3)只有当对象不再被使用，它的内存才有可能被回收；<br>如果虚拟机认为系统不需要额外的内存，即便对象不再使用内存<br>4) 程序无法显式迫使垃圾回收器立即执行垃圾回收，<br>  可以通过java.lang.System.gc()/java.lang.Runtime.gc()<br>  建议虚拟机回收对象；<br>5)java.lang.System.gc()或者java.lang.Runtime.gc()<br>  都只是来通知系统应该处理垃圾</p><p>java中垃圾回收处理的算法：<br>  1）标记清扫法：清扫所有的带有标记的垃圾。<br>                 不会整理内存。<br>         不会进行数据的搬移，效率快<br>  2）内存搬移法：将非垃圾的内存搬移到另外一块区域。<br>                  会整理内存<br>          会进行数据的搬移，效率慢<br>八. 阐述Java平台代码安全实现策略；<br> Java虚拟机为Java程序提供运行时环境，<br> 其中一项重要的任务就是管理类，<br> 管理类的加载、连接和初始化；<br>1) 加载：查找并加载类的二进制文件(class文件),将其置于内存中。<br>2) 连接：<br>a. 验证：确保被加载类的正确性(有正确的内部结构，并且与其他类协调一致)；<br>为什么要验证：Java虚拟机不知道某个特定的.class文件<br>到底是由正常的Java编译器生成的，还是黑客特制的。<br>类的验证能提高程序的健壮性，确保程序被安全地执行。</p><p>类验证内容：</p><ol><li>代码和jvm规范一致：语法和版本是否兼容</li><li>代码不能破坏系统的完整性</li><li>没有堆栈的上溢和下溢</li><li>参数类型是正确的</li><li>类型转换的正确的</li></ol><p>b. 准备：为类的静态变量分配内存，并将其初始化为默认值；<br>c. 解析：把类中的符号引用转换为直接引用(一个指向所调用方法在方法区内的内存位置的指针)；<br>3) 初始化：给类的静态变量赋予正确的初始值；<br>即时编译器（JIT compiler，just-in-time compiler）<br>是一个把Java的字节码（包括需要被解释的指令的程序）<br>转换成可以直接发送给处理器的指令的程序。<br>8020规则:有80%的常用功能只用有20%的常用代码是经常使用的，<br>Inter公司。这个是个专业的人区完成的，完成之后会安装<br>在JVM中，我们使用就可以了。</p><p>九. 定义类、包和应用程序；</p><p>1) Java的工作方式：</p><p>源代码: 编写Java源代码文件<br>编译器: 用编译器编译源代码。编译器会检查错误，如果有错就要改正才能产生正确的输出。<br>输出: 编译器会产生字节码。任何支持Java的装置都能够把它转译成可执行的内容。编译后的字节码与平台无关。<br>Java虚拟机: 可以读取与执行字节码。加载指定类，开始执行它的main方法，然后一直运行到main的所有程序代码结束为止。</p><p> 2) Java的程序结构：<br>a. 源文件：包含Java代码(按java语法规则编写的内容)的文件;<br> 特征：1)以java作为后缀；<br>       2)可以包含多个类/接口；<br>b.包的声明语句(可有可无，如有只能有一行，且位于最前面);<br>  包的命名规则:公司域名的倒写.组.功能<br>   package的作用:<br>          1)使用文件来进行层次管理的class<br>          2)在同一个包中不能出现相同的类名，避免命名冲突。<br>          3)一旦起了包名，类名就发生改变.<br>            包名.类名&gt;权限类名<br>c.import语句(可有可无, 可有多行，紧跟着包的声明语句);<br>d.public class类的声明<br>  1）类：Java代码组织的单位, Java代码都是以一个个类形式组织的。<br> 用Java语言编写程序其实就是编写一个个类；一个类里的语<br> 句内容用大括号括起来，一个类里带有零至多个方法。<br>  2）一个Java文件中只能有一个public class，可以有多个class<br>  3）public class修饰的类名必须和文件名一样<br>  4）类的内容语句，用大括号括起来：属性和方法<br>e.public static void main(String[] args)<br>  1)方法：类似于其它语言里的函数或过程。<br>          方法里带有零至多行语句。<br>  2)方法的结构：<br>     修饰符 返回值类型 方法名字(参数列表){<br>        方法体(业务逻辑代码)<br>     }<br>  3)方法体，用大括号括起来<br>  4)main方法:Java虚拟机执行Java程序时，首先执行调用的方法。<br>main方法又叫程序的入口方法或起点方法。不管你的程序有多大，<br>不管你的程序有多少个类，一定都会有一个main()方法来作为程序的起点。</p><p>f.System.out.println():Java中输出语句<br>  System是java.lang.System类<br>  out是System中的内部类<br>  println()是方法<br>g.Java的三大顶级元素:<br>   package<br>   import<br>   class</p><p>3) 剖析类：<br>public class FirstJavaProgram{<br>     public static void main(String[] args) {<br>            System.out.println(“Hello Java, I am your fans!”);<br>     }<br> }</p><pre><code>    public:                公开给其它类存取；class:                类声明的关键字；FirstJavaProgram:        类的名称；void:                 方法的返回值；main:                方法的名称；String[]:            数组类型；args:                参数名称；System.out.println:        打印到标准输出上(默认为命令行)&quot;Hello Java, I am your fans!&quot;:    要输出的字符串内容；;                每一行语句必须用分号结尾；</code></pre><p>十. 编码、编译以及运用Java应用程序；<br>1)编写：vi 类名.java<br>      用记事本打开 类名.java<br>2)编译：<br>   javac -d . src/类名.java<br>  -d:指定编译后的class文件存放的路径。<br>   编译时连同packge一起编译<br>3)运行：<br>   java  包名.类名</p><p>jar -cvf ch01.jar com  将com打包成ch01.jar<br>jar -xvf ch01.jar  </p><p>import java.util.Scanner;</p><p>public class add {<br>  public static void main(String[] args) {<br>Scanner sc=new Scanner(System.in);<br>double a=sc.nextDouble();<br>double b=sc.nextDouble();<br>  double c=add(a,b);<br>    System.out.print(c);<br>  }<br>public static  double add(double a,double b){<br>return a+b;</p><p>}<br>}</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
