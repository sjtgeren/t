<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java第二十九天笔记</title>
      <link href="/2018/10/30/index29/"/>
      <url>/2018/10/30/index29/</url>
      
        <content type="html"><![CDATA[<p>一:线程互斥<br>   并发访问的线程加上同步锁之后就称为线程互斥。<br>   谁抢到了对象锁的线程就先执行。<br>   没有抢到对象锁的线程就等待对象锁。<br>   加同步锁，加在共享对象上。<br>   每一个对象都有唯一的一把锁。<br>   lock对象锁—-&gt;执行代码——&gt;unlock对象锁</p><p>synchronized(共享区){临界区}<br>共享区：多线程同时操作同一个对象<br>临界区：多线程对共享区进行操作的代码区<br>synchronized可以放在方法上，就是一个同步方法。</p><p>将所有影响的方法都定义成线程安全的方法就变成了线程安全的类。<br>线程安全的类—效率低</p><p>二:线程的通信—&gt;线程同步(操作的也是同一个对象)<br>线程互斥谁先抢到对象锁就谁先执行(如抛绣球)。<br>线程同步会控制线程执行的先后顺序。<br>        线程同步线程会有依赖关系。<br>一个boy存钱，一个girl取钱。必须先存钱后取钱。就是线程同步。<br>重复(存钱—-&gt;取钱)<br>存钱之后通知可以取钱。<br>取钱之后通知可以存钱。<br>并且是先存后取<br>   男:标志位flag = false;存钱 flag=true;<br>   女:标志位flag = true;取钱 flag=false;<br>模拟生成者和消费者—针对产品<br> 生成者:从1到100累加的和作为产品。<br> 消费者:打印该产品。<br>线程通信的步骤：<br>1)找到共有对象。<br>2)wait(),notify(),notifyAll()—Object类中的方法。<br>    需要对同一个资源等待，唤醒才有效。<br>    是针对对象进行等待和通知。这些方法一定要放在<br>    synchronized关键字中，用来保护共有资源。<br> 生产者生成产品之后通知消费者–notify<br> 消费者等待生产者生产产品—wait<br>3)保证wait()执行在notifyAll()方法的前面.使用标志变量。<br> notifyAll()之前先判断有没有线程在等待。<br> 如果有就通知，没有就小睡一下只有有等待线程出现。</p><p>sleep():不会释放对象锁。<br>wait()：让当前线程进入等待状态，会释放对象锁。<br>notify()：通知等待中的某个线程进入到就绪状态。会释放对象锁。<br>notifyAll():通知等待中的所有线程进入到就绪状态。会释放对象锁。<br>可以通过公交车和人和师傅来说明</p><p>三：线程的死锁<br> 多个线程同时操作多个对象很容易产生死锁。<br> 解决方式：给多个对象加对象锁的时候。<br>           将加锁的顺序保持一致，就可以避免死锁。<br>四：Thread类中其他方法<br>yield():当前线程让出CPU，给比自己优先级别还高的线程。<br>    如果当前没有比自己优先级还高的线程就没有效果。<br>setPrioirity(int)设置线程的优先级.整数越大优先级越高。<br>         取值范围在1到10.<br>         但是设置优先级高就不一定会先执行，<br>         还是会看CPU的调度。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十八天笔记</title>
      <link href="/2018/10/29/index28/"/>
      <url>/2018/10/29/index28/</url>
      
        <content type="html"><![CDATA[<p>五：线程的状态<br> a)新建状态：线程对象已经创建，还没有在其上调用start()方法。</p><p> b)就绪状态： 线程已经准备好了，等待CPU的调度，<br>              当线程有资格运行，但调度程序还没有把它选定<br>              为运行线程时线程所处的状态。当start()方法调用时，<br>          线程首先进入就绪状态。在线程运行之后或者从阻塞、<br>          等待或睡眠状态回来后，也返回到就绪状态。</p><p> c)运行状态：线程调度程序从可运行池中选择一个线程作为<br>             当前线程时线程所处的状态。这也是线程进入<br>         运行状态的唯一一种方式。CPU正在执行的线程。</p><p> d)等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。<br>                       实际上这个三状态组合为一种，<br>               其共同点是：线程仍旧是活的，<br>               但是当前没有条件运行。换句话说，<br>               它是可运行的，但是如果某件事件<br>               出现，他可能返回到就绪状态。</p><p> e)死亡状态：当线程的run()方法完成时就认为它死去。<br>          这个线程对象也许是活的，但是，它已经不<br>      是一个单独执行的线程。线程一旦死亡，就<br>      不能复生。 如果在一个死去的线程上调用<br>      start()方法，会抛出java.lang.IllegalThreadStateException异常。</p><p>六：中断线程<br>   模拟龟兔赛跑(乌龟和兔子同时跑，相互没有影响)<br>     每一步跑1-10m的随机数<br>     总共跑100m,第一种方式两个动物都跑到终点。发扬比赛规则。<br>  1)使用标志变量中断线程。就好像开车一样。<br>  2)使用stop().已经过时了,虽然它确实停止了一个正在运行的线程，<br>    然而，这种方法是不安全也是不受提倡的<br>Thread类中的方法：<br>  join():等待线程的执行结束。<br>       在哪个线程中调用就谁等待。<br>       谁调用该方法就等待谁。<br>interrupt():中断阻塞中的线程。<br>            不能中断正在执行的线程。<br>isInterrupted():判断是否被中断<br>static interrupted():清空中断信息</p><p>七：线程的并发访问：多线程同时操作同一个对象。<br>很多ATM—–》每台ATM都会同时在进行工作。就相当于多线程。<br>  卡–&gt;主卡，副卡(同一个账号)</p><p>加同步锁，加在共享对象上。<br>每一个对象都有唯一的一把锁。<br>lock对象锁—-&gt;执行代码——&gt;unlock对象锁<br>多个线程只能是谁抢到了对象锁，谁就可以执行。<br>并发访问的线程加上同步锁之后就称为线程的互斥。</p><p>synchronized(共享区){临界区}<br>共享区：多线程同时操作同一个对象<br>临界区：多线程对共享区进行操作的代码区<br>该对象就是的类就是线程安全的类—效率低。<br>将所有影响的方法都定义成线程安全的方法就变成了线程安全的类。</p><p>synchronized可以放在方法上，就是一个同步方法。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十七天笔记</title>
      <link href="/2018/10/29/index27%20/"/>
      <url>/2018/10/29/index27%20/</url>
      
        <content type="html"><![CDATA[<p>线程<br>一：线程<br>线程是程序执行的最小单位。<br>进程是系统进程资源分配和系统调度的最小单位。是动态的。<br>程序是静态的。<br>线程和进程的目的：多任务—&gt;效率高<br>同时性<br> 在同一个时间点只能执行一个进程或线程<br> 在同一个时间段可以执行多个进程或线程<br>进程数据不共享，每个进程都有自己的独立内存空间。<br>线程数据共享<br>一个程序可以启动多个进程<br>一个进程可以启动多个线程<br>线程必须通过进程启动，不能独立存在的。</p><p>.class运行在JVM上，.class就是一个一个的线程。<br>JVM就是一个进程。</p><p>二：线程的三要素<br>CPU： 运行线程，所有线程共享CPU。<br>      只有线程抢占CPU成功才会执行。<br>代码：线程运行过程中执行的代码块。<br>      线程启动之后会执行public void run()的方法。<br>数据：变量<br>      1)局部变量是多线程不共享<br>      2)extends  Thread之后静态变量是共享<br>                          实例变量不共享<br>      3)implements Runnable之后静态变量是共享的<br>                          实例变量也共享</p><p>三：使用线程<br>第一种方式：class MyThread extends Thread{<br>        public void run(){<br>        }<br>    }<br>创建线程：Thread t1=new MyThread();<br>启动线程： t1.start();<br>使用方法：getName(),sleep();</p><p>第二种方式：class MyThread implements Runnable{<br>        public void run(){<br>        }<br>      }<br>创建线程：MyThread m=new MyThread();<br>    Thread t1 = new Thread(t1);<br>启动线程： t1.start();<br>使用方法：Thread.currentThread().getName()<br>         Thread.sleep();<br>Thread类中的方法：<br>getName():获取当前线程的名字<br>static sleep(long):强制当前正在执行的线程休眠(暂停执行),以“减慢线程”。<br>static currentThread():获取当前正在执行的线程。</p><p>注意：***<br>线程的运行时抢占式，所以线程的执行结果是不可预知的。</p><p>四：为什么要有两种方式<br>   java单继承<br>class Test extends Student implements Runnable{<br>} </p><p>五：线程的状态<br> a)新建状态：线程对象已经创建，还没有在其上调用start()方法。</p><p> b)就绪状态： 线程已经准备好了，等待CPU的调度，<br>              当线程有资格运行，但调度程序还没有把它选定<br>              为运行线程时线程所处的状态。当start()方法调用时，<br>          线程首先进入就绪状态。在线程运行之后或者从阻塞、<br>          等待或睡眠状态回来后，也返回到就绪状态。</p><p> c)运行状态：线程调度程序从可运行池中选择一个线程作为<br>             当前线程时线程所处的状态。这也是线程进入<br>         运行状态的唯一一种方式。CPU正在执行的线程。</p><p> d)等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。<br>                       实际上这个三状态组合为一种，<br>               其共同点是：线程仍旧是活的，<br>               但是当前没有条件运行。换句话说，<br>               它是可运行的，但是如果某件事件<br>               出现，他可能返回到就绪状态。</p><p> e)死亡状态：当线程的run()方法完成时就认为它死去。<br>          这个线程对象也许是活的，但是，它已经不<br>      是一个单独执行的线程。线程一旦死亡，就<br>      不能复生。 如果在一个死去的线程上调用<br>      start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十六天笔记</title>
      <link href="/2018/10/26/index26/"/>
      <url>/2018/10/26/index26/</url>
      
        <content type="html"><![CDATA[<p>异常<br>一：异常<br> 异常是改变程序正常执行流程的意外情况。<br> 异常的条件都是应用级别的异常。系统级别<br> 的异常程序员无法处理。<br>异常：是一个对象,Exception<br>class Exception{<br>    发生问题的主体(Object)<br>    对问题本身的有效描述(String)<br>}</p><p>二：异常的结构<br>try{<br>   //可能出现异常的代码<br>    …<br>    int k= 10/0;<br>    …<br>    …<br>}catch(ExceptionType1 e){<br>….//针对ExceptionType1类型的异常处理<br>}catch(ExceptionType2 e){<br>…//针对ExceptionType2类型的异常处理<br>}<br>…..<br>}finally{<br>     //不管是否碰到异常，都要执行该代码，<br>     //收尾工作(关闭数据库，释放资源….)<br>}<br>…<br>catch中异常类型小异常放在上面<br>             大异常放在下面</p><p>异常：是对象，java.lang.Exception<br>抛出异常：在try中业务逻辑代码出现异常情况，<br>          系统会自动产生异常对象，将该异<br>      常对象抛出给java运行时环境。<br>          这个过程称之为抛出异常。<br>捕获异常：java运行时环境接受到异常对象，<br>         会根据异常对象寻找相应的catch块。<br>     这个过程称之为捕获异常。<br>         如果找不到相应的catch块，<br>     将异常对象交给java运行<br>     时环境，JAVA运行时环境会直接中<br>     断应用程序，并且会打印异常栈的信息。<br>    异常栈的信息会知道在哪行代码出现了什么样的异常。<br>处理异常：异常处理的代码</p><p>三：异常的原理<br>当发生异常的时候，系统将自动抛出异常对象<br>寻找异常处理代码，如果没有找到，将上抛到<br>方法的调用处，依次类推，直到抛给虚拟机程序终止。<br>异常栈可以找到异常真正发生的原因。<br>main(){<br>      a();<br>}<br>a(){<br>      b(); ///处理异常<br>}<br>b(){<br>    c();<br>}<br>c(){<br>   ///Exception<br>}<br>c()—-&gt;b()—-&gt;a()—-&gt;main()—&gt;JVM<br>在c()中发生异常，且所有方法都没有异常处理，所有方法的栈区是否被锁定？(会)<br>有多少方法牵扯进来了，就会有多少方法的栈区被锁定了<br>方法的嵌套调用是非常危险的，栈区被锁定，会等待着内存的释放<br>方法的递归调用也是很非常危险的，你不一定知道调用的次数<br>建议：不要有过分复杂的方法嵌套调用，<br>      不要使用调用次数可能过多的递归算法</p><p>getMessage():返回该异常的详细描述字符串<br>printStackTrack():将该异常的跟踪栈信息输出到标准错误输出</p><p>四：异常分类<br>Exception<br>   uncheck异常(RuntimeException异常)：<br>          包含RuntimeException及子类<br>              在编译期的不需要捕获的异常<br>              不可修复的异常，如连接数据库发生异常<br>          不需要继续向下执行。<br>   check异常：在编译期的必须捕获的异常<br>              可以修复的异常，如输入错误金额，用户名输入错误。处理之后可以继续向下执行。<br>              Exception的子类除了RuntimeException。<br>          如Class.forName(“”)<br>五：异常处理的方式<br>  1)try—catch:自己处理异常<br>  2)throws:自己不处理异常，抛出调用者处理异常。<br> 原则：如果自己能够处理的异常，<br>       就不要抛出调用者处理异常。</p><p>六：自定义异常<br>  1)在项目中建议不抛出系统异常，<br>    因为异常的类名通常应该包含该异常的有用信息。<br>    应该选择合适的异常类，从而可以明确的描述该异常情况，<br>    就应该选择自定义异常。<br>  2)可以把uncheck异常转化为check异常<br>    可以把check异常转化为uncheck异常<br>自定义check异常:<br>class MyException extends Exception<br>自定义uncheck异常:<br>class MyException extends RuntimeException</p><p>throws 异常类型:方法申明的时候抛出异常<br>throw 异常对象:方法体中抛出异常</p><p>七：断言jdk1.4之后<br>开发过程中，在需要的时候提供判断功能.<br>用if判断效率很低，用断言可以提高效率<br>在AssertTest.java加上断言assert b==0:”my assert”;<br>默认情况下，断言是关闭的，所以在运行的时候打开断言输入vm参数-ea<br>断言是在1.4版本之后增加的，如果对1.4版本之前的系统进行重写。<br>需要确认assert是否被用作标识符</p><p>八：异常和系统效率<br>异常处理会影响系统效率，建议只在适当的时候做必要处理</p><p>1.返回值是多少？<br>public int test(){<br>    try{<br>        //int k = 10/0;<br>        int k = 10/1;<br>        return 1;<br>    }catch(Exception e){<br>        return -1;<br>    }finally{<br>        return 0;<br>    }<br>}<br>注意：返回值不能finally块。<br>2.下面的语句哪些是对的？<br>a.try{}<br>b.try{}catch(){}<br>c.try{}finally{}<br>d.try{}catch(){}finally{}<br>e.catch(){}<br>f.finally{}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十五天笔记</title>
      <link href="/2018/10/26/index25/"/>
      <url>/2018/10/26/index25/</url>
      
        <content type="html"><![CDATA[<p>二. 反射 ：自描述或者自定义<br>  平时我们照镜子的时候，在镜子后面会有自己的影子，<br>其实java中的反射也是类似的，一个类或者对象通过反<br>射可以获得自身的对象，该对象是一个java.lang.Class<br>的对象(就像一个镜像文件)。一个对象或者类获得自身<br>的Class对象的过程称为反射。<br>java.lang.Class：是类镜像，镜像对象<br>Class类镜像的作用可以获取该类和该对象的所有属性，方法<br>和构造器，以及属性方法和构造器修饰符，修改私有属性的值。<br>调用方法和调用构造器等等。<br>Class—-实例化—–&gt;class—–实例化—–&gt;对象<br>对象——抽象化—–&gt;class——抽象化—–&gt;Class<br>抽象：具有相同属性和行为抽象出来<br>public class Class{<br>    Field[] fileds;<br>        Method[] methods;<br>        Constructor[]  cons;<br>}<br>反射API：<br>    java.lang.Class<br>    java.lang.reflect.Field<br>    java.lang.reflect.Method<br>    java.lang.reflect.Array<br>    java.lang.reflect.Constructor<br>class Person{}<br>Person创建100个对象，创建多少个Person的Class类型对象？<br>class Person{}<br>   1个，类加载的时候创建Person的Class类型对象。</p><p>通过反射操作的步骤：<br>1）获取类镜像(Class对象),三种方式<br>   a)Class.forName(String className)<br>   b)数据类型.class<br>   c)对象.getClass()<br>2)通过类镜像实例化对象(不通过new方式创建对象)<br>   Object obj=类镜像对象.newInstance()。<br>      默认会调用class类的无参构造器。<br>3)通过实例化对象操作属性，方法，构造器<br>   a)获取所有的属性(属性名和修饰符和数据类型)。<br>   b)获取所有的方法(方法名和修饰符和返回值和参数列表)<br>   c)获取所有构造器(名字和修饰符和参数列表)<br>   d)修饰属性的值<br>   e)调用方法:invoke()<br>   f)调用指定构造器创建的对象</p><p>什么时候反射：<br>  1)在运行的时候才知道类名<br>  2)在运行的时候才知道属性名<br>  3)在运行的时候才知道方法名<br>反射：<br>    1) 确定一个对象的class<br>    2) 可以获得一个类的修饰符、字段、方法、构造器和父类。<br>    3) 获得接口声明的常量和方法。<br>    4) 创建Class的实例，直到运行时才获得。<br>    5) 运行前即使字段名字不知道，可以到程序运行时获得和修改这些字段的值。<br>    6) 运行前即使对象的方法名不知道，可以到程序运行时触发调用该方法。<br>    7) 运行前创建了一个大小和元素都未知的新数组，<br>       可以到运行时修改数组的元素。</p><p>反射的用途：<br>  1)修改私有属性的值<br>  2)调用任何对象的任何方法<br>  3)不通过new方式创建对象</p><p>反射用途的注意：<br>  1)反射可以让我们利用这个Class对象来获取和<br>修改私有的变量和方法，不通过共有的方法去<br>获得（原来我们例子都是通过一个public的方<br>法来设置和获取私有的变量），可以破坏数据<br>的封装性。<br>  2)反射机制通过在运行时探查字段和方法，<br>从而可以帮助写出通用性很好的程序，<br>这项能力对系统编程来说特别有用，<br>但它并不适合于应用编程。而且，反射是<br>脆弱的——编译不能帮助你发现编译错误，<br>任何错误在运行时被发现并且都会导致异常。<br>导致代码不安全。<br>异常<br>一：异常<br> 异常是改变程序正常执行流程的意外情况。<br> 异常的条件都是应用级别的异常。系统级别<br> 的异常程序员无法处理。<br>异常：是一个对象,Exception<br>class Exception{<br>    发生问题的主体(Object)<br>    对问题本身的有效描述(String)<br>}</p><p>二：异常的结构<br>try{<br>   //可能出现异常的代码<br>    …<br>    int k= 10/0;<br>    …<br>    …<br>}catch(ExceptionType1 e){<br>….//针对ExceptionType1类型的异常处理<br>}catch(ExceptionType2 e){<br>…//针对ExceptionType2类型的异常处理<br>}<br>…..<br>}finally{<br>     //不管是否碰到异常，都要执行该代码，<br>     //收尾工作(关闭数据库，释放资源….)<br>}<br>…<br>catch中异常类型小异常放在上面<br>             大异常放在下面</p><p>异常：是对象，java.lang.Exception<br>抛出异常：在try中业务逻辑代码出现异常情况，<br>          系统会自动产生异常对象，将该异<br>      常对象抛出给java运行时环境。<br>          这个过程称之为抛出异常。<br>捕获异常：java运行时环境接受到异常对象，<br>         会根据异常对象寻找相应的catch块。<br>     这个过程称之为捕获异常。<br>         如果找不到相应的catch块，<br>     将异常对象交给java运行<br>     时环境，JAVA运行时环境会直接中<br>     断应用程序，并且会打印异常栈的信息。<br>    异常栈的信息会知道在哪行代码出现了什么样的异常。<br>处理异常：异常处理的代码</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十三天笔记</title>
      <link href="/2018/10/22/index23/"/>
      <url>/2018/10/22/index23/</url>
      
        <content type="html"><![CDATA[<p>Map保存键值对的数据。key是唯一的。<br>如保存是否打开音效，是否打开振动，当前分数，历史最高分，关数。。。</p><p>一：Map类中的方法：HashMap,Hashtable<br>put(Object key,Object value):添加数据到map集合中<br>Set keySet():将map中所有的key取出来放在set集合中<br>Object get(Object key):从map集合中获取数据。<br>Set entrySet():将map中的key和对应的value重新创建成新的对象(Map.Entry)放在set集合中。<br>      Map.Entry:getKey()<br>      Map.Entry:getValue()<br>Set values():将map中所有的value取出来放在collection集合中<br>interface Map{<br>    static interface Entry{</p><pre><code>}</code></pre><p>}<br>collections工具类<br>Arrays给数组提供的工具类<br>二:String,StringBuffer,StringBuilder<br>String:不可变长的字符串<br>StringBuffer:可变长字符串,线程安全<br>StringBuilder:可变长字符串,线程不安全</p><p>String s=”hello”+”world”;</p><p>三:泛型 Generics，很重要的新特性—参数化类型<br>1：why?jdk1.5前后没有泛型和有泛型分别解决下面的问题<br>    1.集合中使用:<br>      jdk1.5之前：1)添加对象都为Object，<br>                    不会进行数据类型的检查。<br>                  2)操作时需要对其进行强制类型转换。<br>           很容易引发ClassCastException异常<br>      jdk1.5之后：使用泛型<br>    a)检查数据类型,将错误尽量控制到编译器<br>    使用泛型的主要是用于集合在add添加数据时，编译器对数据类型的检测。如果不满足泛型中定义的数据类型就添加不成功。<br>    b)另外在操作集合中的数据时不需要进行强制类型转换。<br>      取数据的类型是放进去的类型，减少发生 ClassCastException异常。</p><p>2：泛型实现的机制：类型擦除<br>ArrayList<integer> ArrayList<string> —&gt;ArrayList<br>泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，编译器编译带来类型说明的集合时会去除掉”类型”信息，使程序运行效果不受影响，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样，由于编译生成的字节码会去掉泛型的类型信息，只要跳过编译器，就可以往某个泛型集合中加入其他类型的数据，例如：用反射得到集合，再调用add方法即可。</string></integer></p><p>3：what?  List<e><br> 弱类型:List list，放任意类型<br> 强类型:List<string> list，放指定类型<br>在Java SE 1.5之后,推出泛型。也称之为参数化类型.也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java语言引入泛型的好处是安全简单。<br>  在Java SE 1.5之前，没有泛型的情况的下<br>  通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实<br>际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类<br>型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率<br>   泛型把指定类型的工作推迟到客户端代码声明并实例化类或方法的时候进行。在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。一些强类型编程语言支援泛型，<br>其主要目的是加强类型安全及减少类转换的次数。</string></e></p><p>当集合没有使用泛型的时候，集合中可以添加任何类型的数据。<br>当集合使用泛型的时候，集合中只能添加该泛型及泛型的子类。<br>   List<string>  list = new ArrayList<string>();<br>          list.add(“hello”);<br>      list.add(1);   //error</string></string></p><p>4：术语：ArrayList<e>类定义和ArrayList<integer>类引用中的术语：<br>1)整个称ArrayList<e>为泛型类<br>2)E称为类型变量或类型参数,满足标识符命名规则,一般写大写字母。E,K,V,T</e></integer></e></p><p>3)整个ArrayList<integer>称参数化类型<br>4)Integer称为类型参数的实例或实际类型参数<br>5)&lt;&gt;念typeof<br>6)ArrayList称原始类型</integer></p><p>5：参数化类型与原始类型的兼容性<br> a）参数化类型可以引用一个原始类型：编译器警告<br>List<string> list = new ArrayList(); 这个时候只能添加String类型<br> b）原始类型可以引用一个参数化类型：编译器警告(新的程序可不可以兼容旧的程序)<br>List list = new ArrayList<integer>(); 这个时候可以添加任何对象<br> c）jdk1.7的菱形语法(钻石语法),代码更加简单。<br>List<integer> list = new ArrayList&lt;&gt;();<br> d)参数化类型不考虑类型参数的继承问题(泛型是不存在子父类的)<br>泛型中子父类不能指向的<br>List<object> list = new ArrayList<integer>();  //error<br>泛型中不同类型也是不能指向的<br>List<string> list = new ArrayList<integer>(); //error<br>泛型中不能使用基本数据类型，只能使用引用类型<br>List<int> list = new ArrayList<int>();  //error<br>e)在创建数组实例时，数组的元素不能使用参数化的类型<br>    List<integer>[] listList = new List<integer>[10]; ///error<br>    但是可以使用这样的格式T[].<br>自定义泛型类，泛型方法，泛型接口<br>    1）自定义泛型类,泛型参数必须满足命名规则，但是一般建议大写字母E,T,K,V<br>        a)带有一个泛型参数的泛型：GenericsList.java<br>    eg:  public class 类名&lt;泛型参数列表&gt;{<br>              //类体<br>    }</integer></integer></int></int></integer></string></integer></object></integer></integer></string></p><pre><code>    b)带有多个泛型参数的泛型：GenericsMap.java    eg:  public class 类名&lt;泛型参数列表&gt;{          //类体    }  c)属性为数组或者集合的泛型类  d)泛型类继承泛型类2）自定义泛型接口    public interface 接口名&lt;泛型参数列表&gt;{          //类体}3）自定义泛型方法：   a)泛型方法在泛型类中，它的定义和普通方法是一样的。     public void print(T t){    System.out.println(t);     }   b)泛型方法在普通类中,该方法需要在返回值类型前加上泛型&lt;泛型参数&gt;     eg:     public &lt;T&gt;void print(T t){    System.out.println(&quot;hello&quot;);}</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三天笔记</title>
      <link href="/2018/10/19/index22/"/>
      <url>/2018/10/19/index22/</url>
      
        <content type="html"><![CDATA[<p>一:集合<br>  1)java版的数据结构(对数据进行增删改查的操作)<br>  2)集合框架是别人做好的东西，直接使用就好了。<br>  3)集合只能够保存对象.<br>    基本数据类型的包装类：重要性，<br>    因为集合中只能添加对象，不能添加基本数据类型<br>  4)数组也可以对数据进行增删改查的操作。<br>         但是需要自己封装方法。<br>     集合可以简化代码。</p><p>二：集合框架的组成，所在的包java.util包中。<br>  1)接口：定义需要实现的抽象方法。<br>  2)实现类：将接口中的方法实现，如ArrayList,Hashtable等<br>  3)算法：存放和操作数据的算法。如哈希算法，红黑树算法…</p><p>三:集合的层次结构<br>a)：保存单值<br>Collection:定义保存单值的规范<br>   ——Set:定义保存不可重复无序单值的规范<br>     ———HashSet:哈希算法保存数据，检索效率最高的<br>     ———SortedSet：定义在Set基础上进行排序的规范<br>        ———TreeSet：实现排序规则<br>   ——List:定义保存可重复有序单值的规范<br>      ——LinkedList：使用链表实现List接口<br>      ——Vector：使用数组实现List接口，线程安全的<br>      ——ArrayList：使用数组实现List接口，线程不安全</p><p>b)保存键值对（key—value）<br>Map：定义保存键值对的规范（key不能重复，value可重复）<br>    ————HashMap:是线程不安全,效率高,HashMap允许null key和null value，<br>    ————HashTable:是线程安全,Hashtable不允许null key和null value，<br>    ——SortedMap:定义在Map的基础上进行排序的规范(根据key排序)<br>        ————TreeMap：对map进行排序</p><p>四：增强for循环<br>   a)之前的for循环<br>    for(初始化变量;循环条件;变量的控制){<br>       循环体<br>    }<br>   b)增强for循环：方便遍历集合和数组<br>     for(type element : array){<br>      循环体<br>     }<br>  type:数组或集合中数据的数据类型<br>  element:临时变量<br>  array:数组或集合的引用<br>注意：增强for遍历的集合必须是实现Iterable接口。<br>      不能明确指出数据的下标（位置）</p><p>五：set添加元素的时候，如何判断两个对象是否相等？<br>1）先比较hashCode的值，如果hashCode的值不相等，<br>不会比较equals方法，直接返回两个对象不相等。<br>2）先比较hashCode的值，如果hashCode的值相等，<br>再比较equals方法，如果equals比较两个对象不相等，<br>返回这两个对象不相等。</p><p>六：如何判断元素应该添加在set集合的那个地方？(hashCode的作用)<br>   1)使用哈希算法可以提高检索的效率。<br>     哈希算法底层有一张哈希表。哈希表相对于数组。<br>     哈希表的长度根据算法自己的计算出来的。<br>   2)底层使用哈希算法决定对象所存放的位置<br>     所放的位置=通过对象的hashCode%哈希表的长度<br>一个对象默认hashCode值是由对象的地址根据一定算法计算而得出来的。<br>set中添加元素判断对象是否相同需要重写hashCode方法和equals方法<br>如何重写hashCode方法：在java.lang.Object中<br>重写hashCode方法建议：每个不同的对象放在不同的位置<br>                       将所有会影响判断对象是否相同的<br>               属性的hashCode值相加。<br> public int hashCode(){<br>    //return 1;<br>    return 所有的属性的hashCode值相加;<br> }</p><p>七：TreeSet,TreeMap排序：<br>1）自然排序：将需要排序的类实现java.lang.Comparable<br>public class Student implements Comparable{<br>    public int compareTo(Object obj){<br>        ..排序规则<br>    }<br>}<br>2）覆盖排序：创建TreeSet,TreeMap对象指定排序规则。<br>        当该类无法指定自然排序，就只能使用覆盖排序。<br>        如final String类不能用自然排序，只能用覆盖排序。<br>interface java.util.Comparator{<br>    public int compare(Object o1,Object o2){<br>        ..排序规则<br>    }<br>}<br><strong>**</strong>覆盖排序的优先级高于默认排序<br>Set set = new TreeSet();<br>set.add(“b”);<br>set.add(“a”);<br>set.add(“d”);<br>set.add(“c”);<br>***该代码有没有问题？如果没有问题输出什么内容？<br>如果有问题如何修改？</p><p>jdk1.5的新特性：<br>一：自动装箱和自动拆箱</p><p>1）装箱和拆箱<br>装箱：把基本数据类型转化为类类型<br>拆箱：把类类型转化为基本数据类型<br>java的数据类型分为基本数据类型和引用数据类型。java是面向对象的语言，所以Java就希望<br>并且要求java中操作的都是对象。所以所有的基本数据类型都对应一个包装类。<br>基本数据类型：byte,short,int,long,float,double,boolean,char<br>引用数据类型：类类型，接口类型，数组类型<br>包装类：Byte,Short,Integer,Long,Float,Double,Boolean,Character<br>2)如何进行装箱和拆箱<br>数值类：Byte,Short,Integer,Long,Float,Double<br>                     继承了java.lang.Number<br>                 *Value()从包装类中得到基本数据类型<br>                  也就是拆箱。<br>    其他类：Boolean,Character<br>                          booleanValue()<br>              charValue()<br>      装箱通过new或者是valueOf()方法<br>3)自动装箱和自动拆箱<br>自动装箱：基本数据类型自动转化为类类型<br>自动拆箱：类类型自动转化为基本数据类型<br>4)为什么要增加自动装箱和自动拆箱?<br>    基本数据类型和类类型转换比较方便，不需要<br>    程序员手动转换。对集合的操作更加简单。另外包装类是没有办法进行算术运算的，<br>    所以需要将包装类型转为基本数据类型。<br>             jdk5之前 ——–&gt;add(new Integer(5));<br>             jdk5之后 ——–&gt;add(5)<br>5)缺点<br>      自动装箱：<br>         a:自动装箱不一定调用new方法，也可能调用<br>     valueOf(String s)方法。<br>     b:valueOf()先到缓存池中找该基本数据类型对应<br>     的包装类，如果有，就直接返回该包装类，<br>     如果没有，就调用new方法创建一个新的。<br>     缓存池有一定的大小，1个字节（-128到127）<br>     并不是所有的基本数据类型都有缓存池<br>        byte,boolean:全部缓存<br>        int,short,long:缓存-128到127<br>    float,double:没有缓存<br>    char:缓存Unicode&lt;127</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十一天笔记</title>
      <link href="/2018/10/18/index21/"/>
      <url>/2018/10/18/index21/</url>
      
        <content type="html"><![CDATA[<p>一:集合<br>  1)java版的数据结构(对数据进行增删改查的操作)<br>  2)集合框架是别人做好的东西，直接使用就好了。<br>  3)集合只能够保存对象.<br>    基本数据类型的包装类：重要性，<br>    因为集合中只能添加对象，不能添加基本数据类型<br>  4)数组也可以对数据进行增删改查的操作。<br>         但是需要自己封装方法。<br>     集合可以简化代码。</p><p>二：集合框架的组成，所在的包java.util包中。<br>  1)接口：定义需要实现的抽象方法。<br>  2)实现类：将接口中的方法实现，如ArrayList,Hashtable等<br>  3)算法：存放和操作数据的算法。如哈希算法，红黑树算法…</p><p>三:集合的层次结构<br>a)：保存单值<br>Collection:定义保存单值的规范<br>   ——Set:定义保存不可重复无序单值的规范<br>     ———HashSet:哈希算法保存数据，检索效率最高的<br>     ———SortedSet：定义在Set基础上进行排序的规范<br>        ———TreeSet：实现排序规则<br>   ——List:定义保存可重复有序单值的规范<br>      ——LinkedList：使用链表实现List接口<br>      ——Vector：使用数组实现List接口，线程安全的<br>      ——ArrayList：使用数组实现List接口，线程不安全</p><p>b)保存键值对（key—value）<br>Map：定义保存键值对的规范（key不能重复，value可重复）<br>    ————HashMap:是线程不安全,效率高,HashMap允许null key和null value，<br>    ————HashTable:是线程安全,Hashtable不允许null key和null value，<br>    ——SortedMap:定义在Map的基础上进行排序的规范(根据key排序)<br>        ————TreeMap：对map进行排序</p><p>四：增强for循环<br>   a)之前的for循环<br>    for(初始化变量;循环条件;变量的控制){<br>       循环体<br>    }<br>   b)增强for循环：方便遍历集合和数组<br>     for(type element : array){<br>      循环体<br>     }<br>  type:数组或集合中数据的数据类型<br>  element:临时变量<br>  array:数组或集合的引用<br>注意：增强for遍历的集合必须是实现Iterable接口。<br>      不能明确指出数据的下标（位置）</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二十天笔记</title>
      <link href="/2018/10/18/index20/"/>
      <url>/2018/10/18/index20/</url>
      
        <content type="html"><![CDATA[<p>开发一个数据结构：保存数据和操作数据。<br>任务：可以存放任意类型任意个数的可重复的有序数据。<br>数据结构底层：可以采用数组和链表来实现。<br>调用者：不关心底层是怎么做。对数据进行增删改查的操作。<br>         对于操作者不需要关心底层采用什么实现的，<br>     只需要采用统一的接口完成相同的事情。—-》定义规范。<br>定义标准(规范)：可以采用接口和抽象类。<br>标准一:提供数据增删改查的规范<br>对数据进行增删改查：通用的操作—》定义标准<br>34 57 455 45    80<br>public interface List{<br>    public void add(int index,Object o);<br>    //在最后增加对象<br>    public void add(Object o);<br>        public Object remove(int index);<br>    public Object get(int index);<br>    public int size();<br>    public void set(int index,Object o);<br>    public Iterator iterator();<br>}<br>标准二：<br>遍历元素:迭代器<br>public interface Iterator{<br>    //判断是否有下一个数据<br>    boolean hasNext();<br>    //取下一个数据<br>    Object next();<br>    //删除迭代器中最后一个数据<br>    void remove();<br>}<br>实现三：实现List(数组和链表)<br>//数组<br>class ArrayList implements List{<br>}<br>//链表<br>class LinkedList implements List{<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十九天笔记</title>
      <link href="/2018/10/18/index19/"/>
      <url>/2018/10/18/index19/</url>
      
        <content type="html"><![CDATA[<p>六. 内部类<br>顶层类和内部类的区别：<br>  1)位置:内部类是定义一个类的里面或者一个方法中,或者一个表达式中。<br>     顶层类是定义在package下<br>  2)修饰符：顶层类只能处于public和默认访问级别，<br>            成员内部类可以处于public, protected, private和默认这4种访问级别；<br>作用：<br>  1)可以避免命名冲突。<br>  2)定义类的范围从package变成了类。<br>   在一个类的内部定义的类称为内部类。<br>  3)进行再一次的封装<br>  4)分担外围类的功能</p><p>内部类的分类：<br>    变量按照作用域可分为：<br>      1) 成员变量: 实例变量、静态变量；<br>      2) 局部变量；<br>     同样，内部类按照作用域可分为；<br>      1) 成员内部类: 实例内部类、静态内部类；<br>      2) 局部内部类；<br>      3) 匿名内部类</p><p>a) 静态内部类:用static修饰,相当于静态方法。放在方法外，类里面的。<br>静态内部类具有以下特点：<br>1)静态内部类可以直接访问外部类的静态资源。<br>  如果静态内部类中的变量名字和外围类的变量名字<br>  相同，需要指定访问时的谁的名字。<br>2)静态内部类如果访问外部类的实例成员，<br>  就必须通过外部类的实例去访问。<br>3)静态内部类的实例不会自动持有外部类<br>  的特定实例的引用，<br>  在创建静态内部类的实例时，<br>  不必创建外部类的实例。<br>4)在静态内部类中可以定义静态成员和实例成员。<br>5)外围类可以通过完整的类名直接访<br>  问静态内部类的静态成员。<br>6)外围类可以通过内部类对象<br>调用静态内部类对象的非静态成员。<br>7)在静态内部类中和外围类中创建静态内部类的对象.<br>  静态内部类类名 m=new 静态内部类类名();<br>  在其他类中创建静态内部类的对象:<br>    外围类.静态内部类类名 m=<br>      new 外围类.静态内部类类名();</p><p>b)实例内部类：没有static修饰符。相当于成员变量。放在方法外，类里面的。<br>特点：<br>1)在内部类中,可以直接访问外部类的所有资源(属性和方法)。<br>2)成员内部类不能定义静态的资源，<br>  只能定义非静态的资源。<br>3)外围类不能直接访问成员内部类的资源.<br>   先创建成员内部类的对象，<br>   在通过调用非静态资源(对象.资源)<br>4)在成员内部类中和外围类中创建成员内部类的对象<br>  成员内部类中:类名 m=new 成员内部类类名();<br>  外围类中:类名 m=this.new 成员内部类类名();<br>  在其他类中创建成员内部类的对象:<br>  外围类.成员内部类类名 m=new 外围类().new 成员内部类类名();<br>5)在创建实例内部类的实例时,外部类的实例必须已经存在。<br>6)在成员内部类中调用外围类中同名资源:<br>              外围类.this.资源<br>7)如果实例内部类B与外部类A包含同名的成员，那么在类B中，this.v表示类B的成员， A.this.v表示类A的成员<br>8)实例内部类的实例自动持有外部类的实例的引用。<br>9)外部类实例与内部类实例之间是一对多的关系，<br>  一个内部类实例只会引用一个外部类实例，<br>  而一个外部类实例对应零个或多个内部类实例。</p><p>c) 局部内部类:在一个方法中定义的内部类，它的可见范围是当前方法。和局部变量一样。<br>特点：<br>1)局部内部类只能在当前方法中使用。<br>2)局部内部类和实例内部类一样，不能包含静态成员。<br>3)在局部内部类中定义的内部类也不能被public、protected和private这些访问控制修饰符以及static修饰;<br>4)可以访问外部类的所有成员</p><p>d)匿名内部类：在一个方法中定义的内部类，它的可见范围是当前方法。和局部变量一样<br>特点：<br>1)没有类名，使用接口或者抽象类代替类名<br>2)访问外围类的一切资源(方法和属性)<br>3)访问该方法final修饰的局部变量<br>4)放在方法中或者作为参数。</p><p>几种内部类的区别：</p><ol><li><p>创建<br>a. 声明的位置:<br>静态内部类：类的内部，方法的外部，用static关键字修饰；<br>实例内部类：类的内部，方法的外部，不用static关键字修饰；<br>局部内部类：方法的内部；<br>匿名内部类：既可以在类的内部，方法的外部，也可以在方法的内部；</p><p>b. 实例化方式:<br>静态内部类：new Outer.Inner();          //在外部类外创建；</p><pre><code>new Inner();                //在外部类内内部类外创建</code></pre><p>实例内部类：new Outer().new Inner();      //在外部类外创建；</p><pre><code>this.new Inner();             //在外部类内内部类外创建 </code></pre><p>局部内部类：new Inner();                  //只能在方法内部创建<br>匿名内部类：new 类名() {};            </p></li></ol><ol start="2"><li>访问<br>a. 外部类访问内部类：<br> 静态内部类：通过完整的类名直接访问静态内部类的静态成员;<br> 实例内部类：通过内部类的实例去访问内部类的成员;<br> 局部内部类：不能访问；<br> 匿名内部类：不能访问；<br>b. 内部类访问外部类：<br> 静态内部类：直接访问外部类的静态成员；<br> 实例内部类：可以直接访问外部类的所有成员;<pre><code>如果实例内部类B与外部类A包含同名的成员，那么在类B中， this.v表示类B的成员，       A.this.v表示类A的成员。</code></pre> 局部内部类：可以直接访问外部类的所有成员, <pre><code>访问所在方法中的final类型的参数和变量；</code></pre> 匿名内部类：可以直接访问外部类的所有成员, <pre><code>访问所在方法中的final类型的参数和变量；</code></pre>为什么要使用内部类？<br>1)分担外围的复杂的功能<br>2)进行再一次的封装<br>3)定义只使用一次的类<br>4)避免命名冲突<br>//成员内部类，静态内部类<br>StaticInnerTest.class<br>StaticInnerTest$MaxMin.class<br>//局部内部类<br>LocalInnerTest.class<br>LocalInnerTest$1MaxMin.class<br>//匿名内部类<br>AnonymousInnerTest.class<br>AnonymousInnerTest$1.class</li></ol><p>内部类的使用：监听事件<br>          工厂模式,在内部类只有在该外围类有意义，<br>          出了该外围类就没有意义了， 就可以将该<br>          类定义成内部类。<br>工厂模式：生产对象<br>public class KFC{<br>    public static 套餐 get套餐(钱,几号套餐){<br>        if(钱够){<br>           if(几号套餐存在){<br>            return new 套餐();<br>            }<br>        }<br>    }<br>        private class 套餐{<br>        private int id;<br>        类型，价格，饮料…..<br>    }<br>}</p><p>套餐 a = KFC.get套餐();</p><p>/////////////////////////////////////</p><p>开发一个数据结构：保存数据和操作数据。<br>任务：可以存放任意类型任意个数的可重复的有序数据。<br>数据结构底层：可以采用数组和链表来实现。<br>调用者：不关心底层是怎么做。对数据进行增删改查的操作。<br>         对于操作者不需要关心底层采用什么实现的，<br>     只需要采用统一的接口完成相同的事情。—-》定义规范。<br>定义标准(规范)：可以采用接口和抽象类。<br>标准一:提供数据增删改查的规范<br>对数据进行增删改查：通用的操作—》定义标准<br>34 57 455 45    80<br>public interface List{<br>    public void add(int index,Object o);<br>    //在最后增加对象<br>    public void add(Object o);<br>        public Object remove(int index);<br>    public Object get(int index);<br>    public int size();<br>    public void set(int index,Object o);<br>    public Iterator iterator();<br>}</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十七天笔记</title>
      <link href="/2018/10/18/index17/"/>
      <url>/2018/10/18/index17/</url>
      
        <content type="html"><![CDATA[<p>三：抽象类 abstract class===&gt;有得有失<br> a)抽象方法<br>  作用：定义了一个规范<br>  如果一个方法没有实现就必须定义成抽象方法。<br>  抽象方法用来描述系统具有什么功能，<br>  但不提供具体的实现<br> b)抽象类<br>  1)如果一个类中有抽象方法就必须定义成抽象类。<br>    抽象类中不一定有抽象方法。<br>  2)抽象类中也可以包含非抽象方法<br>  3)抽象类中也可以定义实例变量<br>  4)抽象类中也可以定义构造器，<br>    但是没有抽象构造方法，也没有抽象静态方法；<br>  5)抽象类可以包含多个抽象方法。<br>  6)抽象类的作用是提供给其他的子类来进行继承的。<br>  7)继承抽象类必须实现抽象类中的所有抽象方法。<br>    或者将子类也定义成抽象类。<br>  8)抽象类不能被实例化，构造器给创建子类对象用的。<br>  9)抽象类及抽象方法不能被final修饰符修饰<br>c)作用：当不知道方法的具体实现的时候就可以定义<br>   成抽象方法。让子类去实现该方法，完成自己的实现。</p><p>练习：定义比较器Comparator。比较器比较两个对象谁大谁小。<br>      但是真正用什么比较，是由调用者决定的。<br>      所以就需要定义一个比较的规则，即抽象方法。<br>  比较一个Team团队中最大或者最小人。<br>  根据年龄的大小来查找。<br>  根据名字的长度来查找。<br>  public void testComparator(){<br>List<products> products=new ArrayList<products>();<br>products.add(new Products(“费罗列”,100,30));<br>products.add(new Products(“love”,1000,100));<br>products.add(new Products(“德芙”,10000000,10));<br>products.add(new Products(“自行车”,10000,899));<br>products.add(new Products(“行李箱”,8000,569));<br>products.add(new Products(“泳衣”,100,180));<br>//定义比较器 按价格降序<br>Comparator<products> byPrice=new Comparator<products>() {<br>@Override<br>public int compare(Products o1, Products o2) {<br>return  o1.getPrice()&lt;o1.getPrice()?-1:o1.getPrice()&gt;o2.getPrice()?1:0;<br>}<br>};</products></products></products></products></p><p>//定义比较器 按销量降序<br>Comparator<products> byNum=new Comparator<products>() {<br>@Override<br>public int compare(Products o1, Products o2) {<br>return  o1.getNum()&lt;o2.getNum()?-1:o1.getNum()&gt;o2.getNum()?1:0;<br>}<br>};<br>一. 接口<br>1.接口使用的目的：<br>   a)定义规范的<br>   b)解决多重继承问题；例如Fish类继承Animal类，<br>                表明Fish是一种动物，但鱼同样也是一种食物，<br>        如何表示这种关系呢？ 由于Java语言不支持一<br>        个类有多个直接的父类，因此无法用继承关系来<br>        描述鱼既是一种食物，又是一种动物，为了解决<br>        这一问题，Java语言引入接口类型，简称接口。<br>        一个类只能有一个直接的父类，但是可以实现多<br>        个接口。采用这种方式，Java语言对多继承提供<br>        了有力的支持。<br>2.面试题：<br> C,C++是多继承，但Java是单继承？是不是<br> 说Java语言在继承的层面上是不是退步了？<br>  多继承不好的地方：造成代码的浪费<br>            引发继承的多义性<br>   Java使用接口完成多继承的功能。<br>   使用接口可以一个项目多个功能同时开发。<br>3.接口的内容:<br>   a)接口是抽象类的另外一种形式<br>     接口是抽象类的抽象，<br>     抽象类可存在有方法体的方法，<br>     接口中的方法全部为抽象方法；<br>   b)接口中的所有方法均是抽象方法，<br>     默认都是public abstract类型的；<br>   c)接口中的成员变量默认都是public static final类型，<br>     必须被显式初始化；<br>   d)接口中只能包含public static final类型成员变量<br>     和public abstract类型的成员方法；<br>   e)接口中没有构造方法，不能被实例化。<br>   f)接口可以继承多个接口<br>   g)一个类只能继承一个直接的父类，但能实现多个接口。<br>   h)接口告诉程序员做什么事情，不管怎么做。<br>    定义规范，描述该接口有哪些功能。</products></products></p><p>   抽象类和接口比较：</p><pre><code>1. 相同点：   a. 都不能被实例化；   b. 都能包含抽象方法；2. 不同点；   a. 抽象类中可以为部分方法提供默认的实现，   从而避免子类中重复实现它们，提高代码的可   重用性，而接口中只能包含抽象方法；   b. 一个类只能继承一个直接的父类，这个父   类有可能是抽象类；但一个类可以实现多个接口   ，这是接口的优势所在。</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十五天笔记</title>
      <link href="/2018/10/18/index16/"/>
      <url>/2018/10/18/index16/</url>
      
        <content type="html"><![CDATA[<p>一:Static<br>  1)修饰变量(只能修饰实例变量)—–&gt;静态变量<br> 比如:每次闯关游戏的总分数，应该是第一次闯关<br> 的分数+第二次闯关的分数+第三次闯关方法….<br> 这个时候就需要使用static去保存了。<br>     a)所有类实例共享<br>     b)使用静态变量<br>      类名.变量名<br>     c)静态变量是属于这个类<br>       非静态变量是属于对象<br>     d)代码加载到内存静态变量就存在<br>     e)static变量和实例变量的区别：<br>          i)static变量对于每个类而言在内存中只有一个，能被类的所有实例所共享；<br>                实例变量对于每个类的每个实例都有一份，它们之间互不影响；<br>         ii)Java虚拟机在加载类的过程中为static变量分配内存，<br>                 实例变量在加载完类后创建对象时分配内存；<br>         iii)static变量存在方法区，实例变量存在堆区；<br>         v)static变量可以直接通过类名访问，<br>       实例变量通过引用类型变量访问；<br>   2)修饰方法====&gt;静态方法<br>     a)调用时使用<br>        类名.方法名();<br>     b)静态方法不能使用非静态的变量<br>       静态方法在类加载的时候就存在了<br>       非静态变量在对象创建的时候才存在的<br>       非静态方法可以访问静态变量<br>     c)静态方法不能被非静态方法重写<br>       静态方法不能被静态方法重写<br>     d)静态方法用来表示某个类所特有的功能，<br>       这种功能的实现不依赖于类的具体实例，也不依赖于它的子类.<br>       既然如此，当前类必须为静态方法提供实现。<br>       静态方法属于类<br>     e)不能使用this关键字和super关键字；</p><p>   3)静态初始化块—-在类加载时只执行一次<br>     对静态变量进行初始化，当Java虚似机加载类时，就会执行该代码块；<br>      被static所修饰的成员变量和成员方法表明归某个类所有，它不依赖<br>      于类的特定实例，被类的所有实例共享。只要这个类被加载，<br>      Java虚拟机就能根据类名在运行时数据区的方法区内定位到它们。<br>      static{}<br>   4)普通初始化—-每创建一个对象都会被调用的<br>     对非静态变量进行初始化，<br>      {}<br>整个运行的过程中，某一个类只能够有一个对象</p><p>   5)静态导入<br>import java.lang.Math;<br>     使用：Math.random()</p><p>import static java.lang.Math.*;<br>    使用：random()</p><p>二：final<br>  1)修饰变量—-&gt;常量<br>      变量必须初始化，变量的值不允许修改。<br>       final变量都必须显示初始化，<br>         a) 修饰静态变量，只能在定义变量时进行初始化；<br>         b) 修饰实例变量，可以在定义变量时进行初始化，<br>         或者在构造方法中进行初始化；<br>  2)修饰方法<br>      该方法不能够被重写<br>      final 加密(){} 不允许被重写<br>      final 解密(){} 不允许被重写<br>  3)修饰类<br>      该类不能够被继承<br>         String类就是final修饰的类</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十五天笔记</title>
      <link href="/2018/10/18/index15/"/>
      <url>/2018/10/18/index15/</url>
      
        <content type="html"><![CDATA[<p>三：多态 （面向接口的编程，统一接口的编程）<br>   概念：同一领域中的不同对象调用相同的方法表现不一样<br>Person p=new Student();<br>静态数据类型：变量申明时候的类型<br>动态数据类型：创建对象时的数据类型<br>对象真正的数据类型是动态数据类型决定的，运行时数据类型</p><p>实现多态必须满足什么条件：<br>    1)子类必须重写父类中的方法<br>    2)父类的引用指向子类的对象</p><p>四：方法的重写<br>   条件：当父类的方法不能够满足子类方法的需求。<br>        就可以对父类的方法进行重写<br>   1)发生在子父类<br>   2)方法名必须相同 &amp;&amp;<br>     参数列表必须相同 &amp;&amp;<br>     返回值类型必须相同<br>  3)可见性(访问修饰符)不能变小<br>  4)异常不能扩大</p><p>五：数据类型转换<br>  1) 先使用instanceof 识别类型<br>  2) 子类型隐式地扩展到父类型（自动转换）<br>  3) 父类型必须显式地缩小到子类型</p><p> 转换规则：被转换的实际对象类型一定是转换以后类型的自身或者子类。</p><p>instanceof:数据类型转换之前进行判断该对象是否是该类的实例</p><p>六:对象与对象的关系<br>is a:继承关系<br>has a:包含关系(组合，聚合)<br>use a:使用关系(参数传递时)</p><p>组合：整体和部分同时存在同时消亡<br>      创建整体对象的时候，将部分对象一起创建。<br>     人和手就是组合关系<br>聚合：整体和部分不是同时存在不是同时消亡<br>     人和电脑就是聚合关系<br>     人和地址也是聚合关系</p><p>组合关系：比如A类中包含B类的一个引用b,当A类的一个对象消亡时，<br>b这个引用所指向的对象也同时消亡。<br>聚合关系：反之b所指向的对象还会有另外的引用指向它。</p><p>现实生活中，人和手，脚是组合关系，因为当人死后<br>             手和脚就不复存在了。<br>         人和电脑就是聚合的关系</p><p>class Hand{}<br>class Computer{}<br>组合:<br>class Person{<br>    private Hand hand;<br>    public Person(){<br>       hand=new Hand();<br>    }<br>}<br>聚合:<br>class Person{<br>    private Computer computer;<br>    public setComputer(){<br>        computer = new Computer();<br>    }<br>}</p><p>组合聚合的区别和联系：<br> 1)整体与部分的关系：组合的关系更强一些。对于组合<br> 来说，如果失去整体，部分将不存在了。<br> 2)代码实现来看：组合在整体的构造器中实例化部分，<br> 这个部分不能被其他实例共享。整体和部分的生命周期<br> 是同步的。而聚合关系的部分，可以在构造器中通过<br> 参数传递的形式进行初始化。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十四天笔记</title>
      <link href="/2018/10/18/index14/"/>
      <url>/2018/10/18/index14/</url>
      
        <content type="html"><![CDATA[<p>八. 创建和初始化对象(new)<br>Person p=new Person();<br>public class Person{<br>    private String name=”briup”;<br>}<br>  1)在栈区开辟空间保存对象的引用<br>  2)在堆区开辟空间保存对象本身的数据<br>  3)堆区的地址赋值给栈区的对象的引用<br>  4)为对象的属性进行默认初始化(系统完成)<br>  5)为对象的属性进行显示初始化，比如人的最大年龄100<br>  6)调用普通代码块{}<br>  7)调用构造器</p><p>九. 构造方法<br>    构造器：根据用户的需求传入数据,<br>            然后根据传入数据进行属性的初始化。<br>       作用：为属性进行初始化<br>    1）方法名和类名相同<br>    2）没有返回值类型<br>    3）构造的重载(根据不同的情况调用不同的构造器进行相应的初始化)<br>        调用本类的构造器:this(参数列表)<br>    4)系统会提供一个无参的构造器，<br> 但是如果本类实现了其他的构造器，系统提供的无参构造器失效。<br>public class Test{<br>  public Test(){}<br>  public void Test(){} //普通的方法<br>}<br>一：继承<br>好处：代码复用，简化编程<br>代码复用用在哪些地方：<br>   1)复用父类的属性<br>   2)复用父类的方法(直接调用父类的方法)<br>   3)重写父类的方法<br>实现：class 子类 extends 父类<br>     单继承<br>关系：子类 is a 父类  或者 子类is a like 父类<br>     class Student extends Person<br>      student is a Person<br>      Person is a Student（error）<br>子类继承父类哪些：<br>    1）构造器不能继承<br>    2）方法和属性全部继承</p><p>继承注意的问题：<br>   1)创建一个子类对象必须先创建一个父类对象<br>   2)子类的构造器会默认调用父类的无参构造器<br>       super();<br>   3)父类的无参构造器失效，<br>   子类构造器就需要显式的调用父类存在的其他构造器<br>       super(参数列表); 必须放在构造器的第一行<br>   4)当一个子类继承了一个父类后，<br>    父类中所有的字段和方法都被子类继承拥有，<br>    子类可以任意的支配使用，<br>    每个子类对象中都拥有了父类中的所有字段。<br>    当构造一个子类的实例对象时，<br>    该对象的实例变量包括了子类本身以及父类中的所有实例变量，<br>    实例方法也包括了子类和父类中的所有实例方法。<br>    子类构造器用来初始化子类中所有的实例变量，<br>    而父类构造器super(实参)用来初始化父类中所有的实例变量。<br>    那么在堆中为子类实例对象分配的内存区域中<br>    包括了子类和父类中所有初始化后的实例变量。<br>   5)在构造器同时出现this和super:不能够。</p><p>二：super代表父类对象<br>    this代表当前对象<br> 1)调用父类的属性(很少用)<br>     super.name=name;<br> 2)调用父类的构造器<br>    super(参数列表);<br> 3）调用父类的方法(子类中包含和父类相同的方法名)<br>    super.方法名(参数列表);</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十三天笔记</title>
      <link href="/2018/10/18/index13/"/>
      <url>/2018/10/18/index13/</url>
      
        <content type="html"><![CDATA[<p>五. this关键字:当前对象<br>    1)区分实例变量和局部变量<br>    this.name=name;<br>    2)调用本类的构造器<br>       this(参数列表);<br>    3)调用本类的方法<br>       this.方法名()</p><p>六. 数据隐藏<br>  好处：防止外界进行非法修改<br>  如何实现：1)数据的访问修饰符private<br>            2)提供统一的操作(属性的set,get)<br>  数据隐藏就是封装的一个方面，封装的另一个方面隐藏方法。</p><p>七. 方法重载<br>   对于类的方法(包括从父类中继承的方法),<br>   如果有两个方法的方法名相同，但参数不一致，<br>   那么可以说，一个方法是另一个方法的重载方法。<br>   这种现象叫重载。<br>   方法的重载满足的条件：<br>   1)在同一个类中<br>   2)方法名相同<br>   3)参数列表不相同<br>        a)参数个数不相同 ||<br>        b)参数类型不相同 ||<br>        c)参数列表的顺序不相同<br>   4)返回值类型可以不同<br>   5)访问修饰符可以不同</p><pre><code>在一个类中不允许定义两个方法名相同，并且参数签名也完全相同的方法。因为假如存在这样的两个方法，Java虚拟机在运行时就无法决定到底执行哪个方法。参数签名是指参数的类型、个数和顺序。</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十二天笔记</title>
      <link href="/2018/10/18/index12/"/>
      <url>/2018/10/18/index12/</url>
      
        <content type="html"><![CDATA[<p>java第十二天笔记</p><h2 id="一-OOP中的基本概念"><a href="#一-OOP中的基本概念" class="headerlink" title="一. OOP中的基本概念"></a>一. OOP中的基本概念</h2><p>​    Java的编程语言是面向对象的，采用这种语言进行编程称为<br>面向对象编程(Object-Oriented Programming, OOP)， 它允许设<br>计者将面向对象设计实现为一个可运行的系统。Java的编程单位<br>是类，对象最后要通过类进行实例化(即“创建”)。<br>面向对象编程有三个特性：封装，继承，多态的概念<br>封装：对类中的属性和方法的具体实现进行封装（隐藏）<br>      外界不可见<br>继承：继承父类中的属性和方法 extends<br>      class 子类 extends 父类<br>      都是单继承<br>多态：同一个领域中(继承同一个类或者实现同一个接口)的不同对象调用相同的方法表现不同<br>class 鸟 implments Common{<br>   public void fly(){<br>    …..<br>  }<br>}<br>class 飞机 implments Common{<br>    public void fly(){<br>    …..<br>  }<br>}</p><p>二. 类和对象<br>   类是具有相同属性和行为的对象的集合。<br>   对象是类的具体化，对象是唯一的。<br>   面向对象的开发方法把软件系统看成各种对象的集合，<br>   对象就是最小的子系统，一组相关的对象能够组合成<br>   更复杂的子系统。面向对象的开发方法将软件系统看<br>   成各种对象的集合，接近人的自然思维方式。</p><pre><code>对象是对问题领域中事件的抽象。对象具有以下特性：1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。    例如学生，成绩单、教师、课和教室。2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。3) 对象具有属性和行为。   例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。   小张的属性包括姓名、性别、年龄、身高和体重，   行为包括学习、唱歌。   例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。   这部手机的属性包括品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，   打电话call()，收发短信receiveMessage()和发短信sendMessage().4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。   对象的某些行为会改变对象自身的状态，即属性的取值。   例如小张本来体重为40kg，经为减肥后，体重减35kg.    肥胖状态: 40kg          |          | 减肥行为          |                 肥胖状态: 35kg 5) 每个对象都是某个类的实例。小张和小王都属于学生类、中国和美国都属于国家类、中文和英文都属于语言类。同一个类的所有实例都有相同属性，但属性取值不一事实上相同，但是它们的状态不一定相同。例如小张和小王都属于学生类，都有姓名、性别、年龄、身高和体重这些属性，但是他们的属性取值不同。同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。类是一组具有相同属性和行为对象的模板。面向对象编程的主要任务就是定义对象模型中的各个类。   1) 类是一种类型：是引用类型；2) 类是元数据：描述数据的数据，数据在面向对象领域里以对象的形式存在，类是对象共有属性和方法的抽象描述。Java程序是各种对象相互交互作用、而不是类。举例：1) 早上到公司上班，在电梯中碰到总经理我们会说，张总早或王总早，会不会说人早呀！那非得把你抄鱿鱼不可。2) 我们要看电视，是买台电视机，而不是买制作电视机的模具；在java中，类的申明和实现在同一时间，而且必须在一起，前面我们已经做过很多的例子。在C++中，类的申明和实现可以被分开，不知道也没有关系，这只是让我们了解下两者的区别。</code></pre><p>三. 定义方法形式<br>格式： 修饰符s 返回类型 方法名（参数列表）异常抛出类型{方法体}</p><pre><code>参数列表：传入数据返回值类型：传出数据的类型          没有返回值，必须写void修饰符：访问修饰符public,private或者static,final。       没有优先级</code></pre><p>四. 参数传递：实参传递给形参<br>   形参：方法声明时的参数<br>   实参：方法调用时传递的参数<br>1）值传递：传递的是数值<br>          参数是基本数据类型的时候，采用值传递<br>2）地址传递：传递的是地址<br>          参数是引用数据类型的时候，采用地址传递</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十一天笔记</title>
      <link href="/2018/10/18/index11/"/>
      <url>/2018/10/18/index11/</url>
      
        <content type="html"><![CDATA[<p>二维数组（随机点名系统，学生的位置x,y）<br>   存放一维数组的数组<br>   int[][] a = new int[2][3];<br>   a[0].length<br>   a.length</p><p>   int[][]<br>   int[][][]<br>a)管理学生寝室<br>   管理每层楼学生的信息<br>   MultiArray.java<br>b)输出方正矩形：<br>  0 2 2 2 2 2<br>  1 0 2 2 2 2<br>  1 1 0 2 2 2<br>  1 1 1 0 2 2<br>  1 1 1 1 0 2<br>  1 1 1 1 1 0</p><p>c)输出10行杨辉三角<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>…………</p><p>锯齿形数组</p><p>3)System.arraycopy()<br>    数组的长度一旦定义了，就无法修改。<br>    所以需要arraycopy()来重新分配一个新的数组，<br>    然后将其内容拷贝进去。<br>   int[] a = new int[5];<br>   int[] b = new int[5];<br>   a=b与System.arraycopy(a,0,b,0,5)有什么区别？</p><p>   a=b是将数组b的值赋值给a数组<br>　　　System.arraycopy(a,0,b,0,5)是将a数组的值都copy到b数组中。　　　</p><p>   比如说我将a[1]=2;请问b[1]的值是多少？</p><p>如果是a=b则，b[1]=2（b1也随着改变）<br>如果是System.arraycopy(a,0,b,0,5)则，b[1]=数组b[1]的初始值，不会改变</p><p>4)使用数组模拟队,先进先出<br>   1/3的需求分析<br>   1/3的coding<br>   1/3的测试<br> class Queue(){<br>      //入队<br>      void add(int value){}<br>      //出队<br>      int remove(){}<br>      //当前队中元素个数<br>      int size()<br>      //输出类型<br>      void print()<br> }</p><p> class Student{}是以属性为主的类<br> class Queue{}是以方法为主的类</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第十天笔记</title>
      <link href="/2018/10/18/index10/"/>
      <url>/2018/10/18/index10/</url>
      
        <content type="html"><![CDATA[<p>5)可变长参数 …  参数的个数可变<br>两个int相加?<br>public int add(int a,int b){}<br>三个int相加?<br>public int add(int a,int b,int c){}<br>四个int相加?<br>public int add(int a,int b,int c,int d){}<br>五个int相加?<br>public int add(int a,int b,int c,int d,int e){}<br>……….<br>上面的方案代码非常冗余。类似的代码重复写。<br>jdk1.5之前的解决方案：通过数组解决的<br> public int add(int[] a){<br> }</p><p>add(new int[]{5,8,9});<br>add(new int[]{5,8});</p><p>缺点:每次都要创建新的数组，<br>    创建数组需要在堆区开辟连续的内存空间。<br>    参数调用之后该变量就没用了，这样会<br>    浪费内存空间。<br>jdk1.5之后的解决方案：通过…解决的<br> public int add(int… a){<br> }<br>调用: add(1,4);<br>      add(1,4,6);<br>      add(7,6,8,89,76);</p><p>注意:1)可变长参数的使用和数组的使用是一样<br>     2)一个方法中只能定义一个可变长参数，<br>       并且要定义最后一个参数。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第九天笔记</title>
      <link href="/2018/10/18/index9/"/>
      <url>/2018/10/18/index9/</url>
      
        <content type="html"><![CDATA[<p>第四章： Array<br>一：什么是数组，什么时候使用数组？<br>数组是用来保存一组数据类型相同的元素的有序集合，<br>      数组中的每个数据称为元素。<br>      有序集合可以按照顺序或者下标取数组中的元素<br>在Java中，数组也是Java对象。数组中的元素可以是任意类型(<br>包括基本类型和引用类),但同一个数组里只能存放类型相同的元素。<br>二：什么时候用数组？<br>  1)保存一堆数据类型相同的数据的时候<br>  2)数据要求有顺序<br>三：数组和链表的区别<br>a)在内存开辟难易程度上？<br>   数组内存分配必须是一块连续的内存空间。<br>   链表内存分配不一定是连续的内存空间。<br>b)在项目中如何选择？<br>    项目重点在数据的增删改，选择链表。不需要数据的大量搬移<br>    项目重点在数据的查询，选择数组，检索效率非常高。<br>四：创建数组大致包括如下步骤：<br>. 声明一个数组类型的引用变量，简称为数组变量；<br>. 用new语句构造数组的实例。new语句为数组分配内存，并且为数组中的每个元素赋予默认值；<br>. 初始化，即为数组的每个元素设置合适的初始值。<br>  a)数组变量的声明；<br>    1) 一个存放同一类型数据的集合<br>       a. 即可以是基本类型，也可以是对象类型；<br>       b. 数组中的每个数据为元素；<br>    2) 数组是一个对象，成员是数组长度和数组中的元素;<br>    3) 申明了一个数组变量并不是创建了一个对象;<br>    4) 申明数组的方式;<br>       int[] IArray 或者 int IArray[] 基本数据类型数组，<br>                    数组中存放的是基本数据类型。<br>       Teacher[] tArray 或者 Teacher tArray[]类数组，<br>                    数组中存放的是Teacher类创建的若干个的对象。<br>    注意：1) 声明数组变量的时侯，不能指定数组的长度，以下声明方式是非法的。<br>             int x[1];<br>             int[2] x;<br>   b)初始化数组<br>    初始化：自变量创建后首次赋值的过程；<br>      创建数组对象；数组对象和其他Java对象一样，也用new语句创建；<br>       int[] iArray = new int[2];<br>       new语句执行以下步骤：<br>       a. 在堆区中为数组分配内存空间，以上代码创建了一个包含2个元素的int数组；<br>          每个元素都是int类型，占4个字节，因此整个数组对象在内存中占用8个字节。<br>       b. 为数组中的每个元素赋予其数据类型的默认值。<br>          byte/short/int/long     0<br>          float            0.0f<br>          double                0.0d<br>          String                null<br>          char                ‘\u0000’<br>          boolean               false<br>       c. 返回数组对象的引用<br>  c)初始化数组对象；<br>       数组中的每个元素都有一个索引，或者称为下标。<br>       数组中的第一个元素的索引为0，第二个元素的索引为1, 依次类推。<br>       通过索引可以访问数组中的元素或者给数组中元素内容赋值。<br>       1) 声明、创建、初始化分开：<br>          int[] iArray;<br>          iArray = new int[2];<br>          iArray[0] = 0;<br>          iArray[1] = 1;<br>       2) 声明、创建的同时并初始化数组；<br>          int[] iArray = {0, 1};<br>          Student sArray[] = new Student[] {<br>                      new Student(“George”, “Male”, 20), new Student()};<br>          Student[] stArray = { new Student(), new Student()} ;</p><p>  注意：a. 非法的数组初始化方式：<br>       int[] x = new int[5]{5,4,3,2,1};//编译出错，不能在[]中指定数组的长度；<br>         int[] x;<br>         x = {5,4,3,2,1}; //{5,4,3,2,1}必须在声明数组变量的语句中使用，不能单独使用</p><p>五. 数组的边界：<br>    1) 一个数组的下标从0开始，数组通过数组的对象引用变量的下标访问数组。<br>       数组中第一个元素的索引为0, 第二元素的索引为1，<br>       依次类推。如果一个数组长度是5，要访问最后一个数组元素可以通过<br>       下标4来访问，如果通过下标5访问，超出了数组的边界，在运行时会抛出<br>       ArrayIndexOutOfBoundsException。</p><pre><code>2) 通过调用数组的length方法可以获得一个数组的元素个数（数组长度）。     所有Java数组都有一个length属性，表示数组的长度. 该属性只能读取，但是不能修改。</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第八天笔记</title>
      <link href="/2018/10/18/index6/"/>
      <url>/2018/10/18/index6/</url>
      
        <content type="html"><![CDATA[<p>f) 逻辑操作符<br>   短路操作符，如果能根据操作左边的布尔表达式<br>   就能推算出整个表达式的布尔值，将不执行操作<br>   符右边的布尔表达式；<br>&amp;&amp;:左边的布尔表达式的值为false, 整个表达式值肯定为false,<br>         此时会忽略执行右边的布尔表达式。<br>||:左边的布尔表达式的值为true, 整个表达式值肯定为true,<br>         此时会忽略执行右边的布尔表达式。<br>if(条件1&amp;&amp;条件2){}<br>   if条件1为假，不会执行条件2<br>   if条件1为真，会执行条件2<br>if(条件1||条件2){}<br>   if条件1为真，不会执行条件2<br>   if条件1为假，会执行条件2 </p><p>g) 条件操作符<br>布尔表达式 ? 表达式1 : 表达式2<br>如果布尔表达式的值为true,就返回表达式1的值,否则返回表达式2的值。<br>int score = 61;<br>String result = score&gt;=60?”及格”:”不及格”;</p><p>h)++,–<br>前++与后++<br>前–与后–<br>int a=10;</p><p>b=++a   =====&gt;a=11,b=11,先计算，后赋值<br>b=a++   =====&gt;a=11,b=10，先赋值，后计算<br>System.out.println(“a:”+a+” b:”+b);</p><p>三.数据类型的转换<br>    1）基本数据类型转换<br>      隐式的数据类型转换：精度小的数据给精度大的数据<br>      强制（显式）的数据类型转换：(type)精度大的数据给精度小的数据<br>       System.out.println((int)(char)(byte)-1);<br>       数据类型在转换的时候注意：<br>              a)如果将精度小的数据转为精度大的数据时。<br>                  如果转之前是有符号数，在前面补符号位<br>                  如果转之前是无符号数，在前面补0<br>              b)如果将精度大的数据转为精度小的数据时。<br>                  从低位窃取位数<br>  2）引用数据类型转换<br>      隐式的数据类型转换：子类转换父类<br>      强制（显式）的数据类型转换：父类转换子类<br>      String str=”hello”;<br>      Object o=str;<br>      String str2=(String)o;</p><p> System.out.println((int)(char)(byte)-1);</p><p>0000 0000 0000 0000 1111 1111 1111 1111<br>1+2+4+8+16+32+64+128+<br>256+512+1024+2048+<br>4096+8192+16384+32768</p><p>int c=a&gt;b?a:b;<br>等价于<br>if(a&gt;b)c=a;<br>else c=b;</p><p>1.语句<br>  a)条件语句:有些代码只有满足特定条件的情况下才会被执行<br>    1)if…else<br>        a. if后面的表达式必须是布尔表达式，而不能为数字类型，例如下面的if(x)是非法的。<br>    b. 假如if语句或else语句的程序代码块中包括多条语句，则必须放在大括号{}内。<br>           若程序代码块只有一条语句则可以不用大括号{}。流程控制语句(如if…else语句)<br>           可作为一条语句看待。<br>        c.只可能执行一个分支，不可能执行多条分支</p><pre><code>2)switch  a. switch后条件的类型必须是byte, short, char或者int;     jdk1.7之后可以使用String类型。  b. 各个case子句的值不同,数据类型必须和switch后条件的数据类型相同；  c. 当switch表达式的值不与任何case子句匹配时，程序执行default子句，     假如没有default子句，则程序直接退出switch语句。     default子句可以位于switch语句中的任何位置。  d. 如果switch表达式与某个case表达式匹配，或者与default情况匹配，     就从这个case子句或default子句开始执行。     假如遇到break，就退出整个switch语句，否则依次执行switch语句中后续的case子句，     不再检查case表达式的值。  e. switch语句的功能也可以用if...else语句来实现。     但switch语句会使程序更简洁，可读性更强。而if...else功能更为强大。</code></pre><p>  b)循环语句<br>  循环语句的作用是反复执行一段代码，直到不满足循环条件为止。<br>  循环语句一般应包括如下四部分内容：<br>     i)初始化部分：用来设置循环的一些初始条件，<br>                    比如循环控制变量的初始值；<br>     ii)循环条件:这是一个布尔表达式，<br>                 每一次循环都要对该表达式求值，<br>         以判断到底继续循环还是终止循环。<br>     iii) 循环体：这是循环操作的主体内容，可以是一条语句，也可以是多条语句；<br>     iv) 迭代部分:用来改变循环控制变量的值，<br>                  从而改变循环条件表达式的值；<br>    1)for<br>       语法：for(初始化部分；循环条件；迭代部分) {<br>                               循环体<br>             }<br>    2)while<br>       语法：[初始化部分]<br>           while(循环条件) {<br>                 循环体,包括迭代部分<br>           }</p><pre><code>当循环条件为true时，就重复执行循环，否则终止循环；                 </code></pre><p>​<br>    3)do..while<br>       和while非常类似，只不过先执行循环体，然后再判断循环条件。<br>        语法：[初始化部分]<br>            do {<br>                循环体,包括迭代部分<br>            } while(循环条件);<br>    4)循环语句中流程跳转<br>        a) break: 终止当前或指定循环；<br>        b) continue: 跳过本次循环，执行下一次循环，<br>                 或执行标号标识的循环体。<br>    c) label: 标号用来标识程序中的语句，标号的名字可以是任意的合法标识符。<br>           continue语句中的标识必须定义在while、do…while和for循环语句前面；<br>           break语句中的标识必须定义在while、do…while和for循环语句或switch语句前面；</p><p><br></p><br><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><p></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第六天笔记</title>
      <link href="/2018/10/18/index5/"/>
      <url>/2018/10/18/index5/</url>
      
        <content type="html"><![CDATA[<p>第二章（续）<br>一.基本数据类型变量和引用数据类型变量：<br>   1)使用基本数据类型定义的变量叫做基本数据类型变量<br>    int a=10;<br>       保存是数据本身的数值(二进制)<br>   2）使用引用数据类型定义的变量叫做引用数据类型变量<br>    Teacher t=new Teacher();<br>       保存是堆区开辟的地址<br>   new关键字：<br>     a)在栈区开辟空间保存对象的引用<br>     b)在堆区开辟空间保存对象本身<br>     c)堆区的地址赋值给栈区的对象的引用<br>二：运行时数据区<br>一个完整的Java程序运行过程会涉及以下内存区域<br>方法区/代码区：存放类的信息<br>堆区：用来存放动态产生的数据，比如new出来的对象。<br>     注意创建出来的对象只包含属于各自的成员变量，<br>     并不包括成员方法。因为同一个类的对象拥有各自<br>     的成员变量，存储在各自的堆中，但是他们共享该<br>     类的方法，并不是每创建一个对象就把成员方法复制一次。<br>栈区：保存局部变量的值，包括：<br>     1.用来保存基本数据类型的值；<br>     2.保存类的实例，即堆区对象的引用(指针)。<br>       也可以用来保存加载方法时的帧<br>常量池：JVM为每个已加载的类型维护一个常量池，<br>        常量池就是这个类型用到的常量的一个有序集合。<br>    常量池存在于堆中。<br>PC寄存器：指向下一条需要执行的指令，将该数据传递给CPU</p><p>第三章： Expressions and Flow Control<br>一：局部变量和实例变量<br>定义变量是指设定变量的数据类型和变量的名字，<br>Java语言要求变量遵循先定义，再初始化，然后使用的规则。<br>作用域：指它的存在范围，只有在这个范围内，程序代码才能访问它。<br>变量的生命周期是指从一个变量被创建并分配内存空间开始，<br>            到这个变量被销毁并清除其所占用内存空间的过程<br>局部变量(参数变量也可以看成是局部变量)：<br>   1)位置：定义在方法中或者在方法中的{}<br>   2)使用：先赋值后使用<br>   3)作用域：定义的方法中或者定义的{}中<br>   4)生命周期：从变量的定义到方法调用结束<br>实例变量：<br>   1)位置：定义方法外，类里面<br>   2)使用：系统会进行默认初始化<br>   3)作用域：作用于整个类<br>   4)生命周期：从对象创建的时候到gc回收内存结束<br>局部变量的例子：<br>public void method1() {<br>    int a = 0;   //局部变量，作用域为整个method01方法；<br>     { int b = 0; //局部变量，作用域为所处的代码块；<br>         b = a;<br>     }<br>     b = 20;   //编译出错，b不能被访问；<br>}<br>实例变量的例子：<br>class Test {<br>          private int n1=0;<br>          private int n2=0;</p><pre><code>public int add() {   int result = n2 + n2;   return result; }</code></pre><p>}</p><p>二：操作符:操作符能与相应类型的数据组成表达式，来完成相应的运算。<br>a)数学运算操作符<br>   +数据类型值相加或字符串连接;<br>System.out.println(1+2+”a”);          //输出3a<br>System.out.println(1+2.0+”a”);        //输出3.0a<br>System.out.println(1+2.0+”a”+true);   //输出3.0atrue<br>System.out.println(“a”+1+2);          //输出a12<br>System.out.println(1+”a”+2);          //输出1a2<br>  /整除, 如操作数均为整数，运算结果为商的整数部分<br>int a1=12/5;      //a1变量的取值为2<br>int a2=13/5;      //a2变量的取值为2<br>int a3=-12/5;     //a3变量的取值为-2<br>int a4=-13/5;     //a4变量的取值为-2<br>int a5=1/5;       //a5变量的取值为0<br>double a6=-12/5;   //a6变量的取值为-2.0<br>double a7=-12/5.0; //a7变量的取值为-2.4<br>   %取模操作符, 如操作数均为整数，运算结果为商的整数部分<br>int a1=1%5;      //a1变量的取值为1<br>int a2=13%5;     //a2变量的取值为3<br>double a3=1%5;    //a3变量的取值为1.0<br>double a4=12%5.1;  //a4变量的取值为1.8000000000000007</p><p>b) 赋值操作符：<br>      = :int x=0,i=1,j=1;<br>      <em>=:这里的”</em>=”由操作符”<em>“和”=”复合而成，它等价于 a=a</em>b;<br>         这种复合操作符能使程序变得更加简洁。<br>      /=:a/=b 等价于 a=a/b;<br>      %=:a%=b 等价于 a=a%b;<br>         …<br> 注意：+=和+的区别<br>    如:short a=0;<br>       int b=123456;<br>       a+=b;和a=a+b的区别<br>         +=系统会进行隐式的数据类型转换，向=左边的数据类型进行转换。<br>         a+b会向数据类型高的类型转换</p><p>c) 比较操作符</p><blockquote><p> 大于<br>= 大于等于<br>   &lt;  小于<br>   &lt;= 小于等于<br>以上操作符只适用于整数类型和浮点数类型；<br> int a=1,b=1;<br> double d=1.0;<br> boolean result1 = a&gt;b;  //result1的值为false;<br> boolean result2 = a&lt;b;  //result2的值为false;<br> boolean result3 = a&gt;=d; //result3的值为true;<br> boolean result4 = a&lt;=b; //result4的值为true;              </p></blockquote><p>instanceof: 判断一个引用类型所引用的对象是否是一个类的实例。<br>            该操作符左边是一个对象，右边是一个类名或接口名。形式如下：<br>  如：String str=”hello”<br>     System.out.println(str instanceof String);<br>     System.out.println(str instanceof Object);<br>     System.out.println(str instanceof Student); //false<br>  java.lang.Object是所有类的父类，<br>      每一个类都会默认继承Object<br>  子类是一个父类 是is a的关系</p><p>d)相等操作符<br>== 等于<br>!= 不等于<br>既可以是基本类型，也可以是引用类型：<br>基本数据类型比较是真正的数值<br>引用类型比较的是地址，如果要比较引用类型真正的数据使用equals<br>如：int a=1,b=1;<br>System.out.println(a==b);  //输出true;<br>如：String s1=”hello”;<br>   String  s2=”hello”;<br>   String s3=new String(“hello”);<br>   String s4=new String(“hello”);<br>   System.out.println(s1==s2); //true<br>   System.out.println(s3==s4); //false<br>   System.out.println(s1==s3); //false<br>    System.out.println(s3.equals(s4)); //true<br>e) 移位操作符，针对二进制操作  </p><blockquote><blockquote><p>算术右移位运算，也称做带符号右移位运算。最高为补符号位。</p><blockquote><p>逻辑右移位运算，也称为不带符号右移位运算。<br>&lt;&lt; 左移位运算，也称为不带符号左移位运算。</p></blockquote></blockquote></blockquote><p>f) 位运算操作符<br>&amp; :与运算，运算规则为：1&amp;1-&gt;1, 1&amp;0-&gt;0, 0&amp;1-&gt;0, 0&amp;0-&gt;0;<br>|:或运算，运算规则为：1|1-&gt;1, 1|0-&gt;1, 0|1-&gt;1, 0|0-&gt;0;<br>^:异或运算，运算规则为：1^1-&gt;0, 1^0-&gt;1, 0^1-&gt;1, 0^0-&gt;0;<br>            两个值相同为0,不同为1；<br>~ : 取反运算, ~1-&gt;0, ~0-&gt;1;</p><p>例如：8&gt;&gt;2====&gt;8/2^2=2<br>8:0000…00001000<br>  0000………10 ====&gt;2<br>8&gt;&gt;&gt;3=====&gt;8/2^3=1<br>8:0000…00001000<br>  00000000.000001=====&gt;1<br>8&lt;&lt;2======&gt;8*2^2=32<br>8:0000…00001000<br>  000000000100000======&gt;32<br>1&amp;1=1 1&amp;0=0 0&amp;0=0<br>1|1=1 1|0=1 0|0=0<br>1^1=0 1^0=1 0^0=0<br>~1=0<br>~0=1<br>8&amp;2=0  8|2=10  8^2=10<br>~8=<br>~2=</p><p>1010<br>10===&gt;第三位置1===&gt;14<br>10===&gt;第二位清0===&gt;8<br>10===&gt;第一位置反===&gt;11<br>10===&gt;输出相应的二进制</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第五天笔记</title>
      <link href="/2018/10/18/index4/"/>
      <url>/2018/10/18/index4/</url>
      
        <content type="html"><![CDATA[<p>一：方法的定义和方法的调用<br>   方法的定义：修饰符  方法的返回值 方法名(参数列表){<br>            方法体<br>        }<br>      如果没有方法的返回值就写成:void<br>      参数列表：参数类型 参数名<br>   方法的调用：方法名(参数值)<br>二：javac -d . First.java<br>  -d指定生成的class文件存放的路径<br>     连同包一起编译。<br>java com.briup.ch01.First<br>   java运行class文件，先类加载。<br>   将class文件加载内存中。<br>   在CLASSPATH配置的路径下找class文件。<br>CLASSPATH与-d后面指定的路径是一样</p><p>第二天：<br>目标： 1. 标识符、关键字和类型介绍；</p><pre><code>2. 如何构建类?</code></pre><p>第二章： Identifiers, Keywords and Types<br>目标：1. 注释作用：使部分内容只为程序员可见，<br>         不为编译器所编译、虚拟机所执行；增加程序的可读性<br>     位置：类声明前后、方法声明前后、属性声明前后、方法体中。<br>          几乎可以在一个源文件任意位置，但不能在一个关键字字<br>      符中插入注释。<br>     类型：1) 单行注释：//text——从”//“到本行结束的所有字符均作为注释而被编译器忽略<br>           2) 多行注释：/<em>text</em>/——从”/<em>“到”</em>/“间的所有字符会被编译器忽略<br>           3) 文档注释：/<strong> text */——从”/</strong>“到”<em>/“间的所有字符会被编译器忽略。<br>       当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的<br>       成员方法的声明)之前时，会作为JavaDoc文档的内容；<br>                  示例：1) //package declaration<br>                          package ch01;                        //允许；<br>                       2) package /</em>package declaration<em>/ch01;            //允许；<br>                       3) class /</em>class declaration<em>/ FirstJavaProgram {        //允许；<br>                          …}<br>                       4) System.out./</em>out content to console<em>/println(“Hello Java”);     //允许；<br>                       5) System.out.print/</em>out content to console*/ln(“Hello Java”);     //不允许；</p><pre><code>           javadoc -author -version -d doc *.java2. 分号、块和空格1) 每个语句短语以;结束 ;    2) 代码段以{}结束;    3) 空白处（空格、tab键、新行和回车(几个语句短语连接在一起））是无关紧要的。3. 标识符:类、方法和变量的名字   1) java标识符以字母、_和$开头，不能以数字开头，后跟字母、数字、“_”和“$”的组合;   2) 大小写敏感   3) 没有长度限制。   4) 不能使用java的关键字   举例：  合法标识符       非法标识符            try                    try#            GROUP_7                7GROUP            openDoor               open-door            boolean1               boolean</code></pre><ol start="4"><li><p>关键字<br>Java语言的关键字是程序代码中的特殊字符。包括：</p><pre><code>. 类和接口的声明——class, extends, implements, interface. 包引入和包声明——import, package. 数据类型——boolean, byte, char, double, float, int, long, short. 某些数据类型的可选值——false, true, null. 流程控制——break, case, continue, default, do, else, for, if, return, switch, while. 异常处理——catch, finally, throw, throws, try. 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile. 操作符——instanceof. 创建对象——new. 引用——this, super. 方法返回类型——void Java语言的保留字是指预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，这有别于C++； . 程序中标识符不能以关键字命名；</code></pre><ol start="5"><li><p>基本类型：程序的基本功能是处理数据,程序用变量来表示数据；</p><pre><code>    程序中必须先定义变量才能使用；定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：            数据类型  变量名；    Java语言把数据类型分为基本类型和引用类型。</code></pre><p>  基本数据类型</p><pre><code>数值类型     整数类型:byte,short,int,long 浮点数类型:float,double布尔类型：boolean字符类型：char</code></pre><p>  引用数据类型</p><pre><code>类类型:比如String        接口类型        数组类型</code></pre></li></ol><p>接下来，我们主要关注基本数据类型，关注各种基本数据类型<br>有什么样的取值范围？占用多少内存空间？     </p><ol start="6"><li><p>boolean类型</p><pre><code>位置            boolean类型变量取值   Java源程序             只能是true或falseclass文件              用int或byte表示boolean虚拟机中           用整数0来表示false, 有任意一个非零整数表示true强调，在Java源程序中不允许把整数或null赋给boolean类型的变量，</code></pre><p>这是有别于其它语言(如c语言)的地方. 例：</p><pre><code>boolean isMarried = 0;          //编译出错，提示类型不匹配boolean isMarried = null;       //编译出错，提示类型不匹配</code></pre></li><li><p>文本数据类型——char和String</p><p>  1) 字符编码:Java语言对文本字符<br>采用Unicode字符编码。<br>由于计算机内存只能存取二进制数据，<br>因此必须为各个字符进行编码。<br>所谓字符编码，是指用一串二进制数据来表示特定的字符。<br>常见的字符编码包括：<br>a. ASCII字符编码</p><pre><code>ASCII--</code></pre><p>Amecian Standard Code for Information Interchange(<br>美国信息交换标准代码).<br>主用于表达现代英语<br>和其他西欧语言中的字符。<br>它是现今最通用的单字节编码系统，<br>它只用一个字节的7位，<br>一共表示128个字符。</p><pre><code>b. ISO-8859-1字符编码,又称为Latin-1, 是国际标准化组织(ISO)为西欧语言中的字符制定的编码，</code></pre><p>用一个字节(8位)来为字符编码，与ASCII字符编码兼容。所谓兼容，是指对于相同的字符，它的ASCII字符编码<br>和ISO-8859-1字符编码相同。</p><pre><code>c. GB2312字符编码   它包括对简体中文字符的编码，</code></pre><p>  一共收录了7445个字符(6763个汉字+682个其他字符. 它与ASCII字符编码兼容。</p><pre><code>d. GBK字符编码    对GB2312字符编码的扩展，</code></pre><p>   收录了21886个字符(21003个字符+其它字符), 它与GB2312字符编码兼容。</p><pre><code> e. Unicode字符编码：        由国际Unicode协会编制，收录了全世界所有语言文字中的字符，是一种跨平台的字符编码。        UCS(Universal Character Set)是指采用Unicode字符编码的通用字符集。        Unicode具有两种编码方案：        . 用2个字节(16位)编码，被称为UCS-2, Java语言采用;        . 用4个字节(32位)编码，被称为UCS-4; f. UTF字符编码     有些操作系统不完全支持16位或32位的Unicode字符编码，UTF(UCS Transformation Format)字符编码能够把     Unicode字符编码转换为操作系统支持的编码，常见的UTF字符编码包括UTF-8, UTF-7和UTF-16.</code></pre><p> 2) char的几种可能取值<br>Java语言采用UCS-2字符编码，字符占2个字节。</p><pre><code>字符a的二进制数据形式为 0000 0000 0110 0001     十六进制数据形式为 0x0061       十进制数据形式为 97以下4种赋值方式是等价的：char c = &apos;a&apos;;char c = &apos;\u0061&apos;;      //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 0x0061;        //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 97;            //设定&quot;a&quot;的十进制数据的Unicode字符编码</code></pre><p> 3) 转义字符</p><pre><code>Java编程人员在给字符变量赋值时，通常直接从键盘输入特定的字符，</code></pre><p>而不会使用Unicode字符编码，因为很难记住各种字符的Unicode<br>字符编码值。对于有些特殊字符，比如单引号，如不知道它的<br>Unicode字符编码，直接从键盘输入编译错误：<br>   char c = ‘’’;           //编码出错</p><pre><code>为了解决这个问题，可采用转义字符来表示单引号和其他特殊字符： char c = &apos;\&apos;&apos;;char c = &apos;\\&apos;;转义字符以反斜杠开头，常用转义字符：\n           换行符，将光标定位到下一行的开头；\t           垂直制表符，将光标移到下一个制表符的位置；\r           回车，将光标定位到当前行的开头，不会移到下一行；\\           反斜杠字符\&apos;           单引号字符</code></pre><ol start="8"><li><p>整数类型<br> byte, short, int和long都是整数类型，并且都是有符号整数。<br>与有符号整数对应的是无符号整数，两者的区别在于<br> 把二进制数转换为十进制整数的方式不一样。<br>. 有符号整数把二进制数的首位作为符号数，<br>当首位是0时，对应十进制的正整数，<br>当首位是1时，对应十进制的负整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是-128 - 127。<br>. 无符号整数把二进制数的所有位转换为正整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是0 - 255。</p><pre><code>在Java语言中，为了区分不同进制的数据，八进制数以“0”开头，十六制以“0x”开头。举例： 一个字节的二进制数        八进制数         十六进制数        有符号十进制数       无符号十进制数0000 0000                 0000             0x00              0                    01111 1111                 0377             0xFF              -1                   2550111 1111                 0177             0x7F              127                  1271000 0000                 0200             0x80              -128                 128</code></pre><p>  如果一个整数值在某种整数类型的取值范围内，就可以把它直接赋给这种类型的变量，否则必须进行强制类型的转换。</p><pre><code>byte = 13;如129不在byte类型的取值范围(-128-127)范围内，则必须进行强制类型的转换。byte b = (byte)129;    //变量b的取值为-127.如果一个整数后面加上后缀——大写&quot;L&quot;或小写&quot;l&quot;, 就表示它是一个long类型整数。以下两种赋值是等价的：long var = 100L;         //整数100后面加上大写的后缀&quot;L&quot;，表示long型整数；long var = 100l;         //整数100后面加上大写的后缀&quot;l&quot;，表示long型整数；Java语言允许把八进制数(以&quot;0&quot;开头), 十六进制数(以&quot;0x&quot;开头)和十进制数赋给整数类型变量，例如：int a1 = 012;                 //012为八进制数，变量a1的十进制取值为10int a2 = 0x12;                //0x12为十六进制数，变量a2的十进制取值为18int a3 = 12;                  //12为十进制数，变量a3的十进制取值为12int a4 = 0xF1;                //0xF1为十六制数，变量a4的十进制取值为241byte b = (byte)0xF1           //0xF1为十六制数，变量b的十进制取值为-15</code></pre><p>注意：<br>数据类型的转换：<br>1)强制类型转换:精度高向精度低的转换<br>byte b = (byte)129;<br>2)隐式类型转换:精度低向精度高的转换<br>byte&lt;short&lt;int&lt;long&lt;float&lt;double</p></li></ol></li><li><p>浮点类型</p><p> 浮点类型表示有小数部分的数字。Java中有两种浮点类型：</p><p> . float: 占4个字节，共32位，称为单精度浮点数;<br> . double: 占8个字节，共64位，称为双精度浮点数；</p><p>  float和double类型都遵循IEEE754标准，该标准分别为32位和64位浮点数规定了二进制数据表示形式。</p><p>  float=1(数字符号)+8(指数，底数为2)+23(尾数)<br>  double=1(数字符号)+11(指数，底数为2)+52(尾数)</p><p>  在默认情况下，小数及采用十进制科学计数法表示的数字都是double类型，<br>可以把它直接赋值给double类型变量。</p><pre><code>double d1 = 1000.1;double d2 = 1.0001E+3;            //采用十进制科学计数法表示的数字，d2实际取值为1000.1double d3 = 0.0011;double d4 = 0.11E-2;              //采用十进制科学计数法表示的数字，d4实际取值为0.0011如果把double类型的数据直接赋给float类型变量，有可能会造成精度的丢失，因此必须进行强制类型的转换，否则会导致编译错误，例如：float f1 = 1.0                    //编译错误，必须进行强制类型转换；float f2 = 1;                     //合法，把整数1赋值给f2，f2的取值1.0;float f3 = (float)1.0;            //合法，f3的取值为1.0;float f4 = (float)1.5E+55;        //合法, 1.5E+55超出了float类型的取值范围，                                    f4的取值为正无穷大System.out.println(f3);           //打印1.0;System.out.println(f4);           //打印Infinity</code></pre></li></ol></li></ol><pre><code>                Float.NaN                         非数字                Float.POSITIVE_INFINITY           无穷大                Float.NEGATIVE_INFINITY           负无穷大                float f1 = (float)(0.0/0.0);      //f1的取值为Float.NaN                float f2 = (float)(1.0/0.0);      //f2的取值为Float.POSITIVE_INFINITY                float f3 = (float)(-1.0/0.0);     //f3的取值为Float.NEGATIVE_INFINITY                System.out.println(f1);           //打印NaN;                System.out.println(f2);           //打印Infinity                System.out.println(f3);           //打印-Infinity                Java语言之所以提供以上特殊数字， 是为了提高Java程序的健壮性，并且简化编程。当数字运算出错时，可以用浮                点数取值范围内的特殊数字来表示所产生的结果。否则，如果Java程序在进行数学运算遇到错误时就抛出异常，会影                响程序的健壮性，而且程序中必须提供捕获数学运算异常的代码块，增加了编程工作量。     10. 变量的申明和赋值              程序的基本功能是处理数据              程序用变量来表示数据；              程序中必须先定义变量才能使用；              定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：              数据类型  变量名；              Java语言要求变量遵循先定义，再初始化，然后使用的规则。变量的初始化是指自从变量定义以后，首次给它赋初始              值的过程。例：              int a;          //定义变量a              a = 1;          //初始化变量a              a++;            //使用变量a              int b=a;        //定义变量b, 初始化变量b, 使用变量a;              b++;            //使用变量b      11. 推荐命名规则              1) 类名以大写字母开头；              2) 接口名以大写字母开头；              3) 方法名以小写字母开头；              4) 变量名以小写字母开头；              5) 常量名全部大写，多个单词以&quot;_&quot;连接；     12. 理解对象              明白什么是面向对象编程              面向对象的开发方法把软件系统看成各种对象的集合，      对象就是最小的子系统，一组相关的对象能够组合成更复杂的              子系统。面向对象的开发方法将软件系统看成各种对象的集合，      接近人的自然思维方式。              对象是对问题领域中事件的抽象。对象具有以下特性：              1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。         例如学生，成绩单、教师、课和教室。              2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。              3) 对象具有属性和行为。                 例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。         小张的属性包括姓名、性别、年龄、身高和体重，行为包括学习、唱歌。                 例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。这部手机的属性包括        品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，打电话call()，收发         短信receiveMessage()和发短信sendMessage().              4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。         对象的某些行为会改变对象自身的状态，即属性的取值。                 例如小张本来体重为40kg，经为减肥后，体重减到45kg.                  肥胖状态: 40kg                        |                        | 减肥行为                        |                                             肥胖状态: 35kg               5) 每个对象都是某个类的实例。小张和小王都属于学生类、         中国和美国都属于国家类、中文和英文都属于语言类。                 类是具有相同属性和行为的对象的集合。                 同一个类的所有实例都有相同属性，但属性取值不一事实上相同，         但是它们的状态不一定相同。例如小张和小王都属                 于学生类，都有姓名、性别、年龄、身高和体重这些属性，         但是他们的属性取值不同。                 同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。          13. 创建类              类是一组具有相同属性和行为对象的模板。      面向对象编程的主要任务就是定义对象模型中的各个类。              package sample;              public class Teacher {                  /**attributes of a teacher*/                  private String name;                  private int age;                  private double salary;                   /** Creates a new instance of Teacher */                  public Teacher(String name, int age, double salary) {                      this.salary = salary;                      this.age = age;                      this.name = name;                  }                  /**operations on properties */                  /** get the name of this teacher */                  public String getName() { return name; }                  /**get the salary of this teacher */                  public double getSalary() { return salary; }                  /**get the age of teacher teacher */                  public int getAge() { return age; }                   ……              }              代码解析：               1) package sample;                 包声明语句，将Java类放到特定的包中，便于类的组织、权限访问和区分名字相同的类。              2) public class Teacher {...}                 类的声明语句，类名为Teacher,         public修饰符意味着这个类可以被公开访问；                 声明类的格式：                 class 类名 {                     类内容                 }              3) private String name;           类的属性(也称为成员变量)的声明语句；       Teacher类有一个name属性，字符串类型，       private修饰符意味着这个属性不能被公开访问。              4) public String getName() { return name; }            方法的声明语句和方法体            方法名为getName，不带参数，    String表明返回类型为String。    public表明这个方法可以被公开访问。    getName后紧跟的大括号为方法体，代表getName的具体实现。                 声明方法的格式：                  返回值类型 方法名 (参数列表) {                     方法体                 }                 返回值类型是方法的返回数据的类型, 如果返回值类型为void, 表示没有返回值。                 方法名是任意合法的标识符;                 参数列表可包含零个或多个参数，参数之间以逗号&quot;,&quot;分开。                 方法体每个语句用&quot;;&quot;结束；                 方法体中使用return语句返回数据或结束本方法的执行；              注：不介绍构造方法。在面向对象章节会提到。          14. 创建实例              public static void main(String[] args) {                      Teacher gzhu = new Teacher(&quot;George Zhu&quot;, 30, 10000);                      System.out.println(&quot;Teacher: &quot; + gzhu.getName());                      System.out.println(&quot;\tAge: &quot; + gzhu.getAge());                      System.out.println(&quot;\tSalary: &quot; + gzhu.getSalary());              }           main()方法是Java应用程序的入口点，       每个Java应用程序都是从main()方法开始运行的。       作为程序入口的main()方法必须同时符合以下几个条件：              . 用public static修饰；              . 返回类型为void;              . 方法名为main;              . 参数类型为String[];              包含main方法的类又叫主程序类。              类创建好之后，通过new关键字创建具体对象。它有以下作用：              . 为对象分配内存空间，将对象的实例变量自动初始化为其变量类型的默认值；              . 如实例变量显示初始化，将初始化值赋给实例变量；              . 调用构造方法；              . 返回对象的引用；              注：结合实例，并画内存分配图讲解。          15. 基本类型和引用类型的区别                   1) 基本类型代表简单的数据类型，比如整数和字符。                 引用类型代表复杂数据类型，引用类型所引用的         实例包括操纵这种数据类型的行为。                 通过&quot;.&quot;运算符，就能访问引用变量所引用的实例的方法.              2) 基本类型Java虚拟机会为其分配数据类型实际占用的内存空间；                 引用类型仅是一个指向堆区中某个实例的指针。                 例：public class Counter {                        int count = 13;                     }                     Counter counter = new Counter();                     counter引用变量-------------&gt; Counter实例                                                    count变量(占4个字节,值为13)            counter引用变量的取值为Counter实例的内存地址。            counter引用变量本身也占一定的内存空间，    到底占用多少内存空间取决于Java虚拟机的实现，这对Java程序是透明的。             注：counter引用变量到底位于Java虚拟机的运行时数据区的哪个区？         取决于counter变量的作用域，         如果是局部变量，则位于Java栈区；                 如果是静态成员变量，则位于方法区；                 如果是实例成员变量，则位于堆区；面向对象编程的步骤：  1）从需求中寻找名词性短语，构建class,有相应的属性和行为  2）产生对象  3）访问属性，方法(.)</code></pre><p> 第二章（续）<br>一.基本数据类型变量和引用数据类型变量：<br>   1)使用基本数据类型定义的变量叫做基本数据类型变量<br>    int a=10;<br>       保存是数据本身的数值(二进制)<br>   2）使用引用数据类型定义的变量叫做引用数据类型变量<br>    Teacher t=new Teacher();<br>       保存是堆区开辟的地址<br>   new关键字：<br>     a)在栈区开辟空间保存对象的引用<br>     b)在堆区开辟空间保存对象本身<br>     c)堆区的地址赋值给栈区的对象的引用<br>二：运行时数据区<br>一个完整的Java程序运行过程会涉及以下内存区域<br>方法区/代码区：存放类的信息<br>堆区：用来存放动态产生的数据，比如new出来的对象。<br>     注意创建出来的对象只包含属于各自的成员变量，<br>     并不包括成员方法。因为同一个类的对象拥有各自<br>     的成员变量，存储在各自的堆中，但是他们共享该<br>     类的方法，并不是每创建一个对象就把成员方法复制一次。<br>栈区：保存局部变量的值，包括：<br>     1.用来保存基本数据类型的值；<br>     2.保存类的实例，即堆区对象的引用(指针)。<br>       也可以用来保存加载方法时的帧<br>常量池：JVM为每个已加载的类型维护一个常量池，<br>        常量池就是这个类型用到的常量的一个有序集合。<br>    常量池存在于堆中。<br>PC寄存器：指向下一条需要执行的指令，将该数据传递给CPU</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第四天笔记</title>
      <link href="/2018/10/18/index3/"/>
      <url>/2018/10/18/index3/</url>
      
        <content type="html"><![CDATA[<p>目标： 1. 标识符、关键字和类型介绍；</p><pre><code>2. 如何构建类?</code></pre><p>第二章： Identifiers, Keywords and Types<br>目标：1. 注释作用：使部分内容只为程序员可见，<br>         不为编译器所编译、虚拟机所执行；增加程序的可读性<br>     位置：类声明前后、方法声明前后、属性声明前后、方法体中。<br>          几乎可以在一个源文件任意位置，但不能在一个关键字字<br>      符中插入注释。<br>     类型：1) 单行注释：//text——从”//“到本行结束的所有字符均作为注释而被编译器忽略<br>           2) 多行注释：/<em>text</em>/——从”/<em>“到”</em>/“间的所有字符会被编译器忽略<br>           3) 文档注释：/<strong> text */——从”/</strong>“到”<em>/“间的所有字符会被编译器忽略。<br>       当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的<br>       成员方法的声明)之前时，会作为JavaDoc文档的内容；<br>                  示例：1) //package declaration<br>                          package ch01;                        //允许；<br>                       2) package /</em>package declaration<em>/ch01;            //允许；<br>                       3) class /</em>class declaration<em>/ FirstJavaProgram {        //允许；<br>                          …}<br>                       4) System.out./</em>out content to console<em>/println(“Hello Java”);     //允许；<br>                       5) System.out.print/</em>out content to console*/ln(“Hello Java”);     //不允许；</p><pre><code>           javadoc -author -version -d doc *.java2. 分号、块和空格1) 每个语句短语以;结束 ;    2) 代码段以{}结束;    3) 空白处（空格、tab键、新行和回车(几个语句短语连接在一起））是无关紧要的。3. 标识符:类、方法和变量的名字   1) java标识符以字母、_和$开头，不能以数字开头，后跟字母、数字、“_”和“$”的组合;   2) 大小写敏感   3) 没有长度限制。   4) 不能使用java的关键字   举例：  合法标识符       非法标识符            try                    try#            GROUP_7                7GROUP            openDoor               open-door            boolean1               boolean</code></pre><ol start="4"><li><p>关键字<br>Java语言的关键字是程序代码中的特殊字符。包括：</p><pre><code>. 类和接口的声明——class, extends, implements, interface. 包引入和包声明——import, package. 数据类型——boolean, byte, char, double, float, int, long, short. 某些数据类型的可选值——false, true, null. 流程控制——break, case, continue, default, do, else, for, if, return, switch, while. 异常处理——catch, finally, throw, throws, try. 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile. 操作符——instanceof. 创建对象——new. 引用——this, super. 方法返回类型——void Java语言的保留字是指预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，这有别于C++； . 程序中标识符不能以关键字命名；</code></pre><ol start="5"><li><p>基本类型：程序的基本功能是处理数据,程序用变量来表示数据；</p><pre><code>    程序中必须先定义变量才能使用；定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：            数据类型  变量名；    Java语言把数据类型分为基本类型和引用类型。</code></pre><p>  基本数据类型</p><pre><code>数值类型     整数类型:byte,short,int,long 浮点数类型:float,double布尔类型：boolean字符类型：char</code></pre><p>  引用数据类型</p><pre><code>类类型:比如String        接口类型        数组类型</code></pre></li></ol><p>接下来，我们主要关注基本数据类型，关注各种基本数据类型<br>有什么样的取值范围？占用多少内存空间？     </p><ol start="6"><li><p>boolean类型</p><pre><code>位置            boolean类型变量取值   Java源程序             只能是true或falseclass文件              用int或byte表示boolean虚拟机中           用整数0来表示false, 有任意一个非零整数表示true强调，在Java源程序中不允许把整数或null赋给boolean类型的变量，</code></pre><p>这是有别于其它语言(如c语言)的地方. 例：</p><pre><code>boolean isMarried = 0;          //编译出错，提示类型不匹配boolean isMarried = null;       //编译出错，提示类型不匹配</code></pre></li><li><p>文本数据类型——char和String</p><p>  1) 字符编码:Java语言对文本字符<br>采用Unicode字符编码。<br>由于计算机内存只能存取二进制数据，<br>因此必须为各个字符进行编码。<br>所谓字符编码，是指用一串二进制数据来表示特定的字符。<br>常见的字符编码包括：<br>a. ASCII字符编码</p><pre><code>ASCII--</code></pre><p>Amecian Standard Code for Information Interchange(<br>美国信息交换标准代码).<br>主用于表达现代英语<br>和其他西欧语言中的字符。<br>它是现今最通用的单字节编码系统，<br>它只用一个字节的7位，<br>一共表示128个字符。</p><pre><code>b. ISO-8859-1字符编码,又称为Latin-1, 是国际标准化组织(ISO)为西欧语言中的字符制定的编码，</code></pre><p>用一个字节(8位)来为字符编码，与ASCII字符编码兼容。所谓兼容，是指对于相同的字符，它的ASCII字符编码<br>和ISO-8859-1字符编码相同。</p><pre><code>c. GB2312字符编码   它包括对简体中文字符的编码，</code></pre><p>  一共收录了7445个字符(6763个汉字+682个其他字符. 它与ASCII字符编码兼容。</p><pre><code>d. GBK字符编码    对GB2312字符编码的扩展，</code></pre><p>   收录了21886个字符(21003个字符+其它字符), 它与GB2312字符编码兼容。</p><pre><code> e. Unicode字符编码：        由国际Unicode协会编制，收录了全世界所有语言文字中的字符，是一种跨平台的字符编码。        UCS(Universal Character Set)是指采用Unicode字符编码的通用字符集。        Unicode具有两种编码方案：        . 用2个字节(16位)编码，被称为UCS-2, Java语言采用;        . 用4个字节(32位)编码，被称为UCS-4; f. UTF字符编码     有些操作系统不完全支持16位或32位的Unicode字符编码，UTF(UCS Transformation Format)字符编码能够把     Unicode字符编码转换为操作系统支持的编码，常见的UTF字符编码包括UTF-8, UTF-7和UTF-16.</code></pre><p> 2) char的几种可能取值<br>Java语言采用UCS-2字符编码，字符占2个字节。</p><pre><code>字符a的二进制数据形式为 0000 0000 0110 0001     十六进制数据形式为 0x0061       十进制数据形式为 97以下4种赋值方式是等价的：char c = &apos;a&apos;;char c = &apos;\u0061&apos;;      //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 0x0061;        //设定&quot;a&quot;的十六进制数据的Unicode字符编码char c = 97;            //设定&quot;a&quot;的十进制数据的Unicode字符编码</code></pre><p> 3) 转义字符</p><pre><code>Java编程人员在给字符变量赋值时，通常直接从键盘输入特定的字符，</code></pre><p>而不会使用Unicode字符编码，因为很难记住各种字符的Unicode<br>字符编码值。对于有些特殊字符，比如单引号，如不知道它的<br>Unicode字符编码，直接从键盘输入编译错误：<br>   char c = ‘’’;           //编码出错</p><pre><code>为了解决这个问题，可采用转义字符来表示单引号和其他特殊字符： char c = &apos;\&apos;&apos;;char c = &apos;\\&apos;;转义字符以反斜杠开头，常用转义字符：\n           换行符，将光标定位到下一行的开头；\t           垂直制表符，将光标移到下一个制表符的位置；\r           回车，将光标定位到当前行的开头，不会移到下一行；\\           反斜杠字符\&apos;           单引号字符</code></pre><ol start="8"><li><p>整数类型<br> byte, short, int和long都是整数类型，并且都是有符号整数。<br>与有符号整数对应的是无符号整数，两者的区别在于<br> 把二进制数转换为十进制整数的方式不一样。<br>. 有符号整数把二进制数的首位作为符号数，<br>当首位是0时，对应十进制的正整数，<br>当首位是1时，对应十进制的负整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是-128 - 127。<br>. 无符号整数把二进制数的所有位转换为正整数。<br>对于一个字节的二进制数, 它对应的十进制数的取值范围是0 - 255。</p><pre><code>在Java语言中，为了区分不同进制的数据，八进制数以“0”开头，十六制以“0x”开头。举例： 一个字节的二进制数        八进制数         十六进制数        有符号十进制数       无符号十进制数0000 0000                 0000             0x00              0                    01111 1111                 0377             0xFF              -1                   2550111 1111                 0177             0x7F              127                  1271000 0000                 0200             0x80              -128                 128</code></pre><p>  如果一个整数值在某种整数类型的取值范围内，就可以把它直接赋给这种类型的变量，否则必须进行强制类型的转换。</p><pre><code>byte = 13;如129不在byte类型的取值范围(-128-127)范围内，则必须进行强制类型的转换。byte b = (byte)129;    //变量b的取值为-127.如果一个整数后面加上后缀——大写&quot;L&quot;或小写&quot;l&quot;, 就表示它是一个long类型整数。以下两种赋值是等价的：long var = 100L;         //整数100后面加上大写的后缀&quot;L&quot;，表示long型整数；long var = 100l;         //整数100后面加上大写的后缀&quot;l&quot;，表示long型整数；Java语言允许把八进制数(以&quot;0&quot;开头), 十六进制数(以&quot;0x&quot;开头)和十进制数赋给整数类型变量，例如：int a1 = 012;                 //012为八进制数，变量a1的十进制取值为10int a2 = 0x12;                //0x12为十六进制数，变量a2的十进制取值为18int a3 = 12;                  //12为十进制数，变量a3的十进制取值为12int a4 = 0xF1;                //0xF1为十六制数，变量a4的十进制取值为241byte b = (byte)0xF1           //0xF1为十六制数，变量b的十进制取值为-15</code></pre><p>注意：<br>数据类型的转换：<br>1)强制类型转换:精度高向精度低的转换<br>byte b = (byte)129;<br>2)隐式类型转换:精度低向精度高的转换<br>byte&lt;short&lt;int&lt;long&lt;float&lt;double</p></li></ol></li><li><p>浮点类型</p><p> 浮点类型表示有小数部分的数字。Java中有两种浮点类型：</p><p> . float: 占4个字节，共32位，称为单精度浮点数;<br> . double: 占8个字节，共64位，称为双精度浮点数；</p><p>  float和double类型都遵循IEEE754标准，该标准分别为32位和64位浮点数规定了二进制数据表示形式。</p><p>  float=1(数字符号)+8(指数，底数为2)+23(尾数)<br>  double=1(数字符号)+11(指数，底数为2)+52(尾数)</p><p>  在默认情况下，小数及采用十进制科学计数法表示的数字都是double类型，<br>可以把它直接赋值给double类型变量。</p><pre><code>double d1 = 1000.1;double d2 = 1.0001E+3;            //采用十进制科学计数法表示的数字，d2实际取值为1000.1double d3 = 0.0011;double d4 = 0.11E-2;              //采用十进制科学计数法表示的数字，d4实际取值为0.0011如果把double类型的数据直接赋给float类型变量，有可能会造成精度的丢失，因此必须进行强制类型的转换，否则会导致编译错误，例如：float f1 = 1.0                    //编译错误，必须进行强制类型转换；float f2 = 1;                     //合法，把整数1赋值给f2，f2的取值1.0;float f3 = (float)1.0;            //合法，f3的取值为1.0;float f4 = (float)1.5E+55;        //合法, 1.5E+55超出了float类型的取值范围，                                    f4的取值为正无穷大System.out.println(f3);           //打印1.0;System.out.println(f4);           //打印Infinity</code></pre></li></ol></li></ol><p>​<br>                    Float.NaN                         非数字<br>                    Float.POSITIVE_INFINITY           无穷大<br>                    Float.NEGATIVE_INFINITY           负无穷大</p><pre><code>            float f1 = (float)(0.0/0.0);      //f1的取值为Float.NaN            float f2 = (float)(1.0/0.0);      //f2的取值为Float.POSITIVE_INFINITY            float f3 = (float)(-1.0/0.0);     //f3的取值为Float.NEGATIVE_INFINITY            System.out.println(f1);           //打印NaN;            System.out.println(f2);           //打印Infinity            System.out.println(f3);           //打印-Infinity            Java语言之所以提供以上特殊数字， 是为了提高Java程序的健壮性，并且简化编程。当数字运算出错时，可以用浮            点数取值范围内的特殊数字来表示所产生的结果。否则，如果Java程序在进行数学运算遇到错误时就抛出异常，会影            响程序的健壮性，而且程序中必须提供捕获数学运算异常的代码块，增加了编程工作量。 10. 变量的申明和赋值          程序的基本功能是处理数据          程序用变量来表示数据；          程序中必须先定义变量才能使用；          定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：          数据类型  变量名；          Java语言要求变量遵循先定义，再初始化，然后使用的规则。变量的初始化是指自从变量定义以后，首次给它赋初始          值的过程。例：          int a;          //定义变量a          a = 1;          //初始化变量a          a++;            //使用变量a          int b=a;        //定义变量b, 初始化变量b, 使用变量a;          b++;            //使用变量b  11. 推荐命名规则          1) 类名以大写字母开头；          2) 接口名以大写字母开头；          3) 方法名以小写字母开头；          4) 变量名以小写字母开头；          5) 常量名全部大写，多个单词以&quot;_&quot;连接； 12. 理解对象          明白什么是面向对象编程          面向对象的开发方法把软件系统看成各种对象的集合，  对象就是最小的子系统，一组相关的对象能够组合成更复杂的          子系统。面向对象的开发方法将软件系统看成各种对象的集合，  接近人的自然思维方式。          对象是对问题领域中事件的抽象。对象具有以下特性：          1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。     例如学生，成绩单、教师、课和教室。          2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。          3) 对象具有属性和行为。             例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。     小张的属性包括姓名、性别、年龄、身高和体重，行为包括学习、唱歌。             例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。这部手机的属性包括    品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，打电话call()，收发     短信receiveMessage()和发短信sendMessage().          4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。     对象的某些行为会改变对象自身的状态，即属性的取值。             例如小张本来体重为40kg，经为减肥后，体重减到45kg.              肥胖状态: 40kg                    |                    | 减肥行为                    |                                         肥胖状态: 35kg           5) 每个对象都是某个类的实例。小张和小王都属于学生类、     中国和美国都属于国家类、中文和英文都属于语言类。             类是具有相同属性和行为的对象的集合。             同一个类的所有实例都有相同属性，但属性取值不一事实上相同，     但是它们的状态不一定相同。例如小张和小王都属             于学生类，都有姓名、性别、年龄、身高和体重这些属性，     但是他们的属性取值不同。             同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。      13. 创建类          类是一组具有相同属性和行为对象的模板。  面向对象编程的主要任务就是定义对象模型中的各个类。          package sample;          public class Teacher {              /**attributes of a teacher*/              private String name;              private int age;              private double salary;               /** Creates a new instance of Teacher */              public Teacher(String name, int age, double salary) {                  this.salary = salary;                  this.age = age;                  this.name = name;              }              /**operations on properties */              /** get the name of this teacher */              public String getName() { return name; }              /**get the salary of this teacher */              public double getSalary() { return salary; }              /**get the age of teacher teacher */              public int getAge() { return age; }               ……          }          代码解析：           1) package sample;             包声明语句，将Java类放到特定的包中，便于类的组织、权限访问和区分名字相同的类。          2) public class Teacher {...}             类的声明语句，类名为Teacher,     public修饰符意味着这个类可以被公开访问；             声明类的格式：             class 类名 {                 类内容             }          3) private String name;       类的属性(也称为成员变量)的声明语句；   Teacher类有一个name属性，字符串类型，   private修饰符意味着这个属性不能被公开访问。          4) public String getName() { return name; }        方法的声明语句和方法体        方法名为getName，不带参数，String表明返回类型为String。public表明这个方法可以被公开访问。getName后紧跟的大括号为方法体，代表getName的具体实现。             声明方法的格式：              返回值类型 方法名 (参数列表) {                 方法体             }             返回值类型是方法的返回数据的类型, 如果返回值类型为void, 表示没有返回值。             方法名是任意合法的标识符;             参数列表可包含零个或多个参数，参数之间以逗号&quot;,&quot;分开。             方法体每个语句用&quot;;&quot;结束；             方法体中使用return语句返回数据或结束本方法的执行；          注：不介绍构造方法。在面向对象章节会提到。      14. 创建实例          public static void main(String[] args) {                  Teacher gzhu = new Teacher(&quot;George Zhu&quot;, 30, 10000);                  System.out.println(&quot;Teacher: &quot; + gzhu.getName());                  System.out.println(&quot;\tAge: &quot; + gzhu.getAge());                  System.out.println(&quot;\tSalary: &quot; + gzhu.getSalary());          }       main()方法是Java应用程序的入口点，   每个Java应用程序都是从main()方法开始运行的。   作为程序入口的main()方法必须同时符合以下几个条件：          . 用public static修饰；          . 返回类型为void;          . 方法名为main;          . 参数类型为String[];          包含main方法的类又叫主程序类。          类创建好之后，通过new关键字创建具体对象。它有以下作用：          . 为对象分配内存空间，将对象的实例变量自动初始化为其变量类型的默认值；          . 如实例变量显示初始化，将初始化值赋给实例变量；          . 调用构造方法；          . 返回对象的引用；          注：结合实例，并画内存分配图讲解。      15. 基本类型和引用类型的区别               1) 基本类型代表简单的数据类型，比如整数和字符。             引用类型代表复杂数据类型，引用类型所引用的     实例包括操纵这种数据类型的行为。             通过&quot;.&quot;运算符，就能访问引用变量所引用的实例的方法.          2) 基本类型Java虚拟机会为其分配数据类型实际占用的内存空间；             引用类型仅是一个指向堆区中某个实例的指针。             例：public class Counter {                    int count = 13;                 }                 Counter counter = new Counter();                 counter引用变量-------------&gt; Counter实例                                                count变量(占4个字节,值为13)        counter引用变量的取值为Counter实例的内存地址。        counter引用变量本身也占一定的内存空间，到底占用多少内存空间取决于Java虚拟机的实现，这对Java程序是透明的。         注：counter引用变量到底位于Java虚拟机的运行时数据区的哪个区？     取决于counter变量的作用域，     如果是局部变量，则位于Java栈区；             如果是静态成员变量，则位于方法区；             如果是实例成员变量，则位于堆区；</code></pre><p>​<br>    面向对象编程的步骤：<br>      1）从需求中寻找名词性短语，构建class,有相应的属性和行为<br>      2）产生对象<br>      3）访问属性，方法(.)             </p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第三天笔记</title>
      <link href="/2018/10/18/index2/"/>
      <url>/2018/10/18/index2/</url>
      
        <content type="html"><![CDATA[<p>一：方法的定义和方法的调用<br>   方法的定义：修饰符  方法的返回值 方法名(参数列表){<br>            方法体<br>        }<br>      如果没有方法的返回值就写成:void<br>      参数列表：参数类型 参数名<br>   方法的调用：方法名(参数值)<br>二：javac -d . First.java<br>  -d指定生成的class文件存放的路径<br>     连同包一起编译。<br>java com.briup.ch01.First<br>   java运行class文件，先类加载。<br>   将class文件加载内存中。<br>   在CLASSPATH配置的路径下找class文件。<br>CLASSPATH与-d后面指定的路径是一样</p><p>第二天：<br>目标： 1. 标识符、关键字和类型介绍；</p><pre><code>2. 如何构建类?</code></pre><p>第二章： Identifiers, Keywords and Types<br>目标：1. 注释作用：使部分内容只为程序员可见，<br>         不为编译器所编译、虚拟机所执行；增加程序的可读性<br>     位置：类声明前后、方法声明前后、属性声明前后、方法体中。<br>          几乎可以在一个源文件任意位置，但不能在一个关键字字<br>      符中插入注释。<br>     类型：1) 单行注释：//text——从”//“到本行结束的所有字符均作为注释而被编译器忽略<br>           2) 多行注释：/<em>text</em>/——从”/<em>“到”</em>/“间的所有字符会被编译器忽略<br>           3) 文档注释：/<strong> text */——从”/</strong>“到”<em>/“间的所有字符会被编译器忽略。<br>       当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的<br>       成员方法的声明)之前时，会作为JavaDoc文档的内容；<br>                  示例：1) //package declaration<br>                          package ch01;                        //允许；<br>                       2) package /</em>package declaration<em>/ch01;            //允许；<br>                       3) class /</em>class declaration<em>/ FirstJavaProgram {        //允许；<br>                          …}<br>                       4) System.out./</em>out content to console<em>/println(“Hello Java”);     //允许；<br>                       5) System.out.print/</em>out content to console*/ln(“Hello Java”);     //不允许；</p><pre><code>           javadoc -author -version -d doc *.java2. 分号、块和空格1) 每个语句短语以;结束 ;    2) 代码段以{}结束;    3) 空白处（空格、tab键、新行和回车(几个语句短语连接在一起））是无关紧要的。3. 标识符:类、方法和变量的名字   1) java标识符以字母、_和$开头，不能以数字开头，后跟字母、数字、“_”和“$”的组合;   2) 大小写敏感   3) 没有长度限制。   4) 不能使用java的关键字   举例：  合法标识符       非法标识符            try                    try#            GROUP_7                7GROUP            openDoor               open-door            boolean1               boolean</code></pre><ol start="4"><li>关键字<br>Java语言的关键字是程序代码中的特殊字符。包括：<pre><code>. 类和接口的声明——class, extends, implements, interface. 包引入和包声明——import, package. 数据类型——boolean, byte, char, double, float, int, long, short. 某些数据类型的可选值——false, true, null. 流程控制——break, case, continue, default, do, else, for, if, return, switch, while. 异常处理——catch, finally, throw, throws, try. 修饰符——abstract, final, native, private, protected, public, static, synchronized, transient, volatile. 操作符——instanceof. 创建对象——new. 引用——this, super. 方法返回类型——void Java语言的保留字是指预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 . 所有关键字都是小写； . friendly, sizeof不是Java语言的关键字，这有别于C++； . 程序中标识符不能以关键字命名；</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/18/hello-world/"/>
      <url>/2018/10/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java第二天笔记</title>
      <link href="/2018/10/17/index1/"/>
      <url>/2018/10/17/index1/</url>
      
        <content type="html"><![CDATA[<p>第一章  corejava的入门<br>一：什么是语言<br>语言=os+数据结构+算法+思想<br>os:操作系统<br>数据结构：队，栈，二叉树，链表<br>算法:做游戏开发时非常重要<br>面试题：int a&gt;0,b&gt;0只使用一条输出语句输出a,b的最大值<br>       System.out.println((|a+b|+|a-b|)/2);<br>二：安装jdk<br>1)根据不同的操作系统下载不同的jdk<br>   Java有三个版本：<br>      Java SE:开发桌面应用程序，比如QQ<br>      Java EE:开发企业级应用程序<br>      Java ME:开发移动应用<br>2)安装jdk<br>   如果是windows,直接双击<br>   如果是unix,在shell中运行<br>        a)拷贝到家目录<br>      b)sudo chmod 777 /opt<br>      c)cp jdk_6u32_liunx_i586.bin /opt<br>      d)cd /opt<br>      e)sudo ./jdk_6u32_liunx_i586.bin<br>   如果是unix的.tar.gz文件：<br>       a)将tar.gz拷贝到家目录并解压<br>       b)sudo chmod 777 /opt<br>       c)sudo mv jdk1.7.0_04 /opt<br>3)配置环境变量<br>         在.bashrc中配置环境变量，打开该文件，追加内容<br>     vi ~/.bashrc<br>        //添加以下内容<br>        CLASSPATH=.<br>       JAVA_HOME=/opt/jdk1.6.0_32<br>      PATH=$PATH:$JAVA_HOME/bin<br>      export CLASSPATH JAVA_HOME PATH<br>   CLASSPATH指定类加载的路径<br>   JAVA_HOME指定JDK的安装目录<br>三：JDK：java Development kit<br>  Sun公司在推出Java语言的同时，也推出了Java的一系列开发工具，<br>  如JDK——  Java Development Kit(Java开发工具包)。<br> 可以从网上免费下载。通常以JDK的版本来定义Java的版本。<br> 时间      版本           在Java标准函数库中的类(class)的数量</p><p>1996     JDK1.0(Java1.0)        250        重点applet<br>1997    JDK1.1(Java1.1)     500        比较适于开发图形界面<br>1998    JDK1.2(Java2)       2300    可达到平台原始速度，<br>            可用于书写正规企业级应用程序或移动应用程序<br>2000    JDK1.3(Java2)<br>2002    JDK1.4(Java2)                计算能力大幅度提升<br>2004    JDK1.5(Java5.0)代号Tiger老虎3500  对语言本身作重大改变，                    更稳定、更安全、更高效<br>2006    JDK1.6(Java6.0)代号Mustang野马<br>2011    JDK1.7(Java7.0)代号Dolphin海豚<br>2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。<br>补充：JDK主要包括内容：<br>a)Java虚拟机：负责解析和执行Java程序.<br>              Java虚拟机可运行在各种平台上<br>b)JDK类库：提供最基础的Java类及各种实用类。<br>            这些类放在$JAVA_HOME/jre/lib/rt.java<br>          java.lang, java.io, java.util,<br>          javax.swing,java.sql包中的类都位于JDK类库中。<br>c)开发工具:这些开发工具都是可执行程序.<br>            主要包括：位于$JAVA_HOME/bin<br>             javac.exe    编译工具；<br>　　　　     java.exe     运行工具；<br>             javadoc.exe  生成JavaDoc文档的工具<br>             jar.exe      打包工具等。</p><p>四： 理解Java语言特征；<br>Java语言包括语法规则和语法规则的实现。<br>Sun公司对Java语言有自己的一份参考实现：JDK。<br>a. 编程语言：语言本质即规则: 字符集、词法规则、句法规则(条件语句、循环语句等);桌面应用程序  ：拥有图形化用户接口的软件；服务器应用程序：通过浏览器访问运行；<br>b. 开发环境：开发程序，不管是桌面应用还是服务器应用，均需要JDK的支持。<br>c. 应用环境：面向应用程序，而不是开发系统程序或者硬件编程，比如说驱动就是系统程序，系统程序一般用c语言<br>d. 部署环境：服务器应用程序需部署运行在服务器应用程序上，服务器本身也是一个Java程序,用Java语言编写的服务器应用程序部署运行时也需要Java语言的支持，将java代码打成一个包，部署到服务器这个过程叫做部署环境</p><p>五. 为什么发明Java?<br>为什么发明了java，换而言之，java有哪些优点呢？<br>a. 提供一个解释环境》JVM<br>1) 加速开发: Java当初目的是开发适用于智能化电子消费设备上的软件，它是基于C++语言，但做了简化，能加速软件的开发过程<br>2) 一次编译到处运行: 跨平台<br>3) 多线程：多线程编程的简单性是Java成为流行的服务器端开发语言的主要原因之一<br>4) 支持动态更新: 软件代码文件的替换即更新，<br>                 类与类之间有调用，如果其中某<br>         一个改变不会影响其他程序。<br>         并且也不需要都编译打包。只需要做<br>         软件代码文件的替换操作。</p><p>b. 提供一个比较容易的方式编程<br>    1) 更健壮：没有指针、没有内存管理；<br>        在开发者层面上没有指针，但是在底层还是有指针。<br>        Java引入了引用的概念。<br>        C:malloc()手动分配内存，free()手动释放内存<br>        C++:new手动分配内存，delete()手动释放内存<br>           手动释放内存对内存回收比较好。但是也有<br>            释放错误(释放一个已经释放的内存，<br>                    释放一个没有开辟的内存)<br>        Java开发程序员不需要关心什么时候释放内存。<br>        由GC垃圾回收器来管理内存的回收。<br>    2) 纯粹的面向对象的编程：在Java中认为一切均是对象，<br>      对象有属性以及改变属性值的方法。通过Java编程围绕<br>      着构建对象的模板、实例化对象、调用对象的方法和属性等来进行。<br>c. 那么如何实现上面这些呢？<br>虚拟机JVM提供一个解释环境，让java代码可以运行。<br>垃圾回收机制让程序员无需在代码中进行内存管理。<br>代码安全校验保证java代码的安全性。</p><p>六. 理解Java虚拟机的特征；<br>  Jvm是什么？简称java 虚拟机（java virtual machine），<br>是用软件来模拟一个虚拟的环境。我们用java编写的源程<br>序经过编译以后生成字节码文件，Jvm 提供了一个解释运<br>行 java字节码文件的环境，只要在不同操作系统上安装了<br>jvm后，就能对同一个java程序进行解释运行，这就java的<br>跨平台，一次编译，到处运行。</p><p>七. 描述垃圾收集的概念；<br>什么叫垃圾回收：<br>1)垃圾：无用对象所占据的内存空间；<br>2)垃圾回收：将无用对象所占据内存空间进行回收的过程；<br>3)为什么要垃圾回收？<br> 对象创建，需要占用内存空间，在一个程序运行过程<br> 中要创建无数个对象，如果对象永久占用内存，那么内存<br> 很快会消费光，倒致后续对象无法创建或者出现内存不足<br> 的错误。因此必须采取一定措施及时回收那些无用对象的<br> 内存，这样保证内存可以被重复利用。</p><p>C++等程序由程序员显示进行内存释放，这样有可能：<br>  c:malloc()   free()<br>  c++:new   delete<br>1) 忘记内存释放，倒致无端的内存占用；<br>2) 释放核心类库占用内存，倒致系统崩溃；</p><p>Java中垃圾回收处理：<br>1) 由JVM虚拟机通过一个系统级别的垃圾回收器线程自动完成，<br>不会忘记也不会释放错，系统更加稳定；</p><p>Java中垃圾回收处理特点：<br>1) 由虚拟机通过垃圾回收器线程自动完成；<br>   是优先级别比较低的线程。没有办法去<br>   控制该线程运行。<br>   进程：是资源分配的最小单位<br>   线程：是程序运行的最小单位<br>2)GC什么情况下工作:<br>   a)内存空闲时<br>   b)内存严重不足时<br>3)只有当对象不再被使用，它的内存才有可能被回收；<br>如果虚拟机认为系统不需要额外的内存，即便对象不再使用内存<br>4) 程序无法显式迫使垃圾回收器立即执行垃圾回收，<br>  可以通过java.lang.System.gc()/java.lang.Runtime.gc()<br>  建议虚拟机回收对象；<br>5)java.lang.System.gc()或者java.lang.Runtime.gc()<br>  都只是来通知系统应该处理垃圾</p><p>java中垃圾回收处理的算法：<br>  1）标记清扫法：清扫所有的带有标记的垃圾。<br>                 不会整理内存。<br>         不会进行数据的搬移，效率快<br>  2）内存搬移法：将非垃圾的内存搬移到另外一块区域。<br>                  会整理内存<br>          会进行数据的搬移，效率慢<br>八. 阐述Java平台代码安全实现策略；<br> Java虚拟机为Java程序提供运行时环境，<br> 其中一项重要的任务就是管理类，<br> 管理类的加载、连接和初始化；<br>1) 加载：查找并加载类的二进制文件(class文件),将其置于内存中。<br>2) 连接：<br>a. 验证：确保被加载类的正确性(有正确的内部结构，并且与其他类协调一致)；<br>为什么要验证：Java虚拟机不知道某个特定的.class文件<br>到底是由正常的Java编译器生成的，还是黑客特制的。<br>类的验证能提高程序的健壮性，确保程序被安全地执行。</p><p>类验证内容：</p><ol><li>代码和jvm规范一致：语法和版本是否兼容</li><li>代码不能破坏系统的完整性</li><li>没有堆栈的上溢和下溢</li><li>参数类型是正确的</li><li>类型转换的正确的</li></ol><p>b. 准备：为类的静态变量分配内存，并将其初始化为默认值；<br>c. 解析：把类中的符号引用转换为直接引用(一个指向所调用方法在方法区内的内存位置的指针)；<br>3) 初始化：给类的静态变量赋予正确的初始值；<br>即时编译器（JIT compiler，just-in-time compiler）<br>是一个把Java的字节码（包括需要被解释的指令的程序）<br>转换成可以直接发送给处理器的指令的程序。<br>8020规则:有80%的常用功能只用有20%的常用代码是经常使用的，<br>Inter公司。这个是个专业的人区完成的，完成之后会安装<br>在JVM中，我们使用就可以了。</p><p>九. 定义类、包和应用程序；</p><p>1) Java的工作方式：</p><p>源代码: 编写Java源代码文件<br>编译器: 用编译器编译源代码。编译器会检查错误，如果有错就要改正才能产生正确的输出。<br>输出: 编译器会产生字节码。任何支持Java的装置都能够把它转译成可执行的内容。编译后的字节码与平台无关。<br>Java虚拟机: 可以读取与执行字节码。加载指定类，开始执行它的main方法，然后一直运行到main的所有程序代码结束为止。</p><p> 2) Java的程序结构：<br>a. 源文件：包含Java代码(按java语法规则编写的内容)的文件;<br> 特征：1)以java作为后缀；<br>       2)可以包含多个类/接口；<br>b.包的声明语句(可有可无，如有只能有一行，且位于最前面);<br>  包的命名规则:公司域名的倒写.组.功能<br>   package的作用:<br>          1)使用文件来进行层次管理的class<br>          2)在同一个包中不能出现相同的类名，避免命名冲突。<br>          3)一旦起了包名，类名就发生改变.<br>            包名.类名&gt;权限类名<br>c.import语句(可有可无, 可有多行，紧跟着包的声明语句);<br>d.public class类的声明<br>  1）类：Java代码组织的单位, Java代码都是以一个个类形式组织的。<br> 用Java语言编写程序其实就是编写一个个类；一个类里的语<br> 句内容用大括号括起来，一个类里带有零至多个方法。<br>  2）一个Java文件中只能有一个public class，可以有多个class<br>  3）public class修饰的类名必须和文件名一样<br>  4）类的内容语句，用大括号括起来：属性和方法<br>e.public static void main(String[] args)<br>  1)方法：类似于其它语言里的函数或过程。<br>          方法里带有零至多行语句。<br>  2)方法的结构：<br>     修饰符 返回值类型 方法名字(参数列表){<br>        方法体(业务逻辑代码)<br>     }<br>  3)方法体，用大括号括起来<br>  4)main方法:Java虚拟机执行Java程序时，首先执行调用的方法。<br>main方法又叫程序的入口方法或起点方法。不管你的程序有多大，<br>不管你的程序有多少个类，一定都会有一个main()方法来作为程序的起点。</p><p>f.System.out.println():Java中输出语句<br>  System是java.lang.System类<br>  out是System中的内部类<br>  println()是方法<br>g.Java的三大顶级元素:<br>   package<br>   import<br>   class</p><p>3) 剖析类：<br>public class FirstJavaProgram{<br>     public static void main(String[] args) {<br>            System.out.println(“Hello Java, I am your fans!”);<br>     }<br> }</p><pre><code>    public:                公开给其它类存取；class:                类声明的关键字；FirstJavaProgram:        类的名称；void:                 方法的返回值；main:                方法的名称；String[]:            数组类型；args:                参数名称；System.out.println:        打印到标准输出上(默认为命令行)&quot;Hello Java, I am your fans!&quot;:    要输出的字符串内容；;                每一行语句必须用分号结尾；</code></pre><p>十. 编码、编译以及运用Java应用程序；<br>1)编写：vi 类名.java<br>      用记事本打开 类名.java<br>2)编译：<br>   javac -d . src/类名.java<br>  -d:指定编译后的class文件存放的路径。<br>   编译时连同packge一起编译<br>3)运行：<br>   java  包名.类名</p><p>jar -cvf ch01.jar com  将com打包成ch01.jar<br>jar -xvf ch01.jar  </p><p><br></p><br><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><p></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
